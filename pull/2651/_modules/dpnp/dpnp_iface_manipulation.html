

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-554F8VNE28"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-554F8VNE28');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dpnp.dpnp_iface_manipulation &mdash; Data Parallel Extension for NumPy 0.20.0dev1+46.g2be7e2529e2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=f4be9c62"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Data Parallel Extension for NumPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start_guide.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Data Parallel Extension for NumPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dpnp.dpnp_iface_manipulation</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dpnp.dpnp_iface_manipulation</h1><div class="highlight"><pre>
<span></span><span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2016, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1"># - Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#   may be used to endorse or promote products derived from this software</span>
<span class="c1">#   without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interface of the array manipulation routines part of the DPNP</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">This module is a face or public interface file for the library</span>
<span class="sd">it contains:</span>
<span class="sd"> - Interface functions</span>
<span class="sd"> - documentation for the functions</span>
<span class="sd"> - The functions parameters check</span>

<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.tensor</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._numpy_helper</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AxisError</span><span class="p">,</span>
    <span class="n">normalize_axis_index</span><span class="p">,</span>
    <span class="n">normalize_axis_tuple</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_array</span><span class="w"> </span><span class="kn">import</span> <span class="n">dpnp_array</span>

<span class="c1"># pylint: disable=no-name-in-module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_usm_allocations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_utils.dpnp_utils_pad</span><span class="w"> </span><span class="kn">import</span> <span class="n">dpnp_pad</span>


<span class="k">class</span><span class="w"> </span><span class="nc">InsertDeleteParams</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameters used for ``dpnp.delete`` and ``dpnp.insert``.&quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">:</span> <span class="n">dpnp_array</span>
    <span class="n">a_ndim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">order</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">slobj</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">a_shape</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">exec_q</span><span class="p">:</span> <span class="n">dpctl</span><span class="o">.</span><span class="n">SyclQueue</span>
    <span class="n">usm_type</span><span class="p">:</span> <span class="nb">str</span>


<span class="c1"># pylint:disable=missing-class-docstring</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UniqueAllResult</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">inverse_indices</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>


<span class="k">class</span><span class="w"> </span><span class="nc">UniqueCountsResult</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">counts</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>


<span class="k">class</span><span class="w"> </span><span class="nc">UniqueInverseResult</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">values</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">inverse_indices</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_stack_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate a sequence type of arrays to stack.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="s2">&quot;__getitem__&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;arrays to stack must be passed as a &quot;sequence&quot; type &#39;</span>
            <span class="s2">&quot;such as list or tuple.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_delete_with_slice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility function for ``dpnp.delete`` when obj is slice.&quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span> <span class="o">=</span> <span class="n">params</span>

    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
    <span class="n">num_del</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_del</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># Invert if step is negative:</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="n">step</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">xr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">num_del</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">newshape</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># copy initial chunk</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
    <span class="c1"># copy end chunk</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">num_del</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
    <span class="c1"># copy middle pieces</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># use array indexing.</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
            <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">keep</span><span class="p">[:</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span> <span class="p">:</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">num_del</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_delete_without_slice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">single_value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility function for ``dpnp.delete`` when obj is int or array of int.&quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span> <span class="o">=</span> <span class="n">params</span>

    <span class="k">if</span> <span class="n">single_value</span><span class="p">:</span>
        <span class="c1"># optimization for a single value</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">n</span> <span class="ow">or</span> <span class="n">obj</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;size </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">+=</span> <span class="n">n</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">newshape</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
        <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;boolean array argument `obj` to delete must be &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;one-dimensional and match the axis length of </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="c1"># optimization, the other branch is slower</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span>
            <span class="p">)</span>
            <span class="n">keep</span><span class="p">[</span><span class="n">obj</span><span class="p">,]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_calc_parameters</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility function for ``dpnp.delete`` and ``dpnp.insert``.&quot;&quot;&quot;</span>

    <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s2">&quot;C&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">a_ndim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>

    <span class="n">slobj</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">InsertDeleteParams</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_array_indices</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function for ``dpnp.insert`` when indices is an array with</span>
<span class="sd">    multiple elements.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span> <span class="o">=</span> <span class="n">parameters</span>

    <span class="n">is_array</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">dpnp_array</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_array</span><span class="p">:</span>
        <span class="c1"># Can safely cast the empty list to intp</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>

    <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span>

    <span class="n">numnew</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">ind_sort</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s2">&quot;stable&quot;</span><span class="p">)</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">ind_sort</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
        <span class="n">numnew</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span>
    <span class="p">)</span>

    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
    <span class="n">old_mask</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span>
    <span class="p">)</span>
    <span class="n">old_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">new</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">newshape</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
    <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_mask</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span>

    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_insert_singleton_index</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function for ``dpnp.insert`` when indices is an array with</span>
<span class="sd">    one element.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">slobj</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span> <span class="o">=</span> <span class="n">parameters</span>

    <span class="c1"># In dpnp, `.item()` calls `.wait()`, so it is preferred to avoid it</span>
    <span class="c1"># When possible (i.e. for numpy arrays, lists, etc), it is preferred</span>
    <span class="c1"># to use `.item()` on a NumPy array</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">n</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2"> is out of bounds for axis </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2"> with size </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="n">n</span>

    <span class="c1"># Need to change the dtype of values to input array dtype and update</span>
    <span class="c1"># its shape to make ``input_arr[..., index, ...] = values`` legal</span>
    <span class="n">values</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">values</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ndmin</span><span class="o">=</span><span class="n">a_ndim</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># numpy.insert behave differently if obj is an scalar or an array</span>
        <span class="c1"># with one element, so, this change is needed to align with NumPy</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">numnew</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">newshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numnew</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
        <span class="n">newshape</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">numnew</span><span class="p">)</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">values</span>
    <span class="n">slobj</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="n">numnew</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">slobj2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a_ndim</span>
    <span class="n">slobj2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">new</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slobj2</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">new</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unique_1d</span><span class="p">(</span>
    <span class="n">ar</span><span class="p">,</span>
    <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the unique elements of a 1D array.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_first_nan_index</span><span class="p">(</span><span class="n">usm_a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the first index of NaN in the input array with at least two NaNs.</span>

<span class="sd">        Assume the input array sorted where the NaNs are always at the end.</span>
<span class="sd">        Return None if the input array does not have at least two NaN values or</span>
<span class="sd">        data type of the array is not inexact.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">usm_a</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span>
            <span class="ow">and</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">usm_a</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
                <span class="c1"># for complex all NaNs are considered equivalent</span>
                <span class="n">true_val</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                    <span class="kc">True</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">usm_type</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">dpt</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">usm_a</span><span class="p">),</span> <span class="n">true_val</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">usm_ar</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>

    <span class="n">num_of_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">return_index</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_of_flags</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">unique_values</span><span class="p">(</span><span class="n">usm_ar</span><span class="p">)</span>
        <span class="n">usm_res</span> <span class="o">=</span> <span class="p">(</span><span class="n">usm_res</span><span class="p">,)</span>  <span class="c1"># cast to a tuple to align with other cases</span>
    <span class="k">elif</span> <span class="n">num_of_flags</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">return_inverse</span><span class="p">:</span>
        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">unique_inverse</span><span class="p">(</span><span class="n">usm_ar</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">num_of_flags</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">return_counts</span><span class="p">:</span>
        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">unique_counts</span><span class="p">(</span><span class="n">usm_ar</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">unique_all</span><span class="p">(</span><span class="n">usm_ar</span><span class="p">)</span>

    <span class="n">first_nan</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
        <span class="n">first_nan</span> <span class="o">=</span> <span class="n">_get_first_nan_index</span><span class="p">(</span><span class="n">usm_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># collapse multiple NaN values in an array into one NaN value if applicable</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">usm_res</span><span class="p">[</span><span class="mi">0</span><span class="p">][:</span> <span class="n">first_nan</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">first_nan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">usm_res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="n">usm_res</span><span class="o">.</span><span class="n">indices</span><span class="p">[:</span> <span class="n">first_nan</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">first_nan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">usm_res</span><span class="o">.</span><span class="n">indices</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">return_inverse</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first_nan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># all NaNs are collapsed, so need to replace the indices with</span>
            <span class="c1"># the index of the first NaN value in result array of unique values</span>
            <span class="n">dpt</span><span class="o">.</span><span class="n">place</span><span class="p">(</span>
                <span class="n">usm_res</span><span class="o">.</span><span class="n">inverse_indices</span><span class="p">,</span>
                <span class="n">usm_res</span><span class="o">.</span><span class="n">inverse_indices</span> <span class="o">&gt;</span> <span class="n">first_nan</span><span class="p">,</span>
                <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">first_nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">usm_res</span><span class="o">.</span><span class="n">inverse_indices</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">return_counts</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">first_nan</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># all NaNs are collapsed, so need to put a count of all NaNs</span>
            <span class="c1"># at the last index</span>
            <span class="n">dpt</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">usm_res</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">first_nan</span><span class="p">:],</span> <span class="n">out</span><span class="o">=</span><span class="n">usm_res</span><span class="o">.</span><span class="n">counts</span><span class="p">[</span><span class="n">first_nan</span><span class="p">])</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">usm_res</span><span class="o">.</span><span class="n">counts</span><span class="p">[:</span> <span class="n">first_nan</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">usm_res</span><span class="o">.</span><span class="n">counts</span><span class="p">,)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_unpack_tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unique_build_sort_indices</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index_sh</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the indices of an input array (when axis is provided) which result</span>
<span class="sd">    in the unique array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">is_inexact</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">):</span>
        <span class="n">ar_cmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">):</span>
        <span class="n">ar_cmp</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ar_cmp</span> <span class="o">=</span> <span class="n">a</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compare_axis_elems</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
        <span class="n">comp</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">(</span><span class="n">ar_cmp</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ar_cmp</span><span class="p">[</span><span class="n">idx2</span><span class="p">],</span> <span class="s2">&quot;f&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">diff</span> <span class="o">=</span> <span class="n">comp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_inexact</span> <span class="ow">and</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
                <span class="n">isnan1</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ar_cmp</span><span class="p">[</span><span class="n">idx1</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isnan1</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># no NaN in ar_cmp[idx1]</span>
                    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># ar_cmp[idx1] goes to left</span>

                <span class="n">isnan2</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ar_cmp</span><span class="p">[</span><span class="n">idx2</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isnan2</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># no NaN in ar_cmp[idx2]</span>
                    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># ar_cmp[idx1] goes to right</span>

                <span class="c1"># for complex all NaNs are considered equivalent</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">isnan1</span> <span class="o">&amp;</span> <span class="n">isnan2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>  <span class="c1"># NaNs at the same places</span>
                    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># ar_cmp[idx1] goes to right</span>

                <span class="n">xor_nan_idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">isnan1</span> <span class="o">^</span> <span class="n">isnan2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">xor_nan_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ar_cmp</span><span class="p">[</span><span class="n">idx2</span><span class="p">][</span><span class="n">xor_nan_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                    <span class="c1"># first NaN in XOR mask is from ar_cmp[idx2]</span>
                    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># ar_cmp[idx1] goes to left</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># sort the array `a` lexicographically using the first item</span>
    <span class="c1"># of each element on the axis</span>
    <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">index_sh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index_sh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">current</span><span class="p">,</span> <span class="n">off</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">mid_elem</span> <span class="o">=</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">right</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">compare_axis_elems</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mid_elem</span><span class="p">):</span>
                <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">right</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="n">elem_pos</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">left</span><span class="p">,</span> <span class="n">off</span><span class="p">))</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">right</span><span class="p">,</span> <span class="n">elem_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">sorted_indices</span><span class="p">[</span><span class="n">elem_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid_elem</span>
    <span class="k">return</span> <span class="n">sorted_indices</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_unpack_tuple</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unpacks one-element tuples for use as return values.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">a</span>


<div class="viewcode-block" id="append">
<a class="viewcode-back" href="../../reference/generated/dpnp.append.html#dpnp.append">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append values to the end of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.append`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    values : {scalar, array_like}</span>
<span class="sd">        These values are appended to a copy of `arr`. It must be of the correct</span>
<span class="sd">        shape (the same shape as `arr`, excluding `axis`). If `axis` is not</span>
<span class="sd">        specified, `values` can be any shape and will be flattened before use.</span>
<span class="sd">        These values can be in any form that can be converted to an array. This</span>
<span class="sd">        includes scalars, lists, lists of tuples, tuples, tuples of tuples,</span>
<span class="sd">        tuples of lists, and ndarrays.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        The axis along which `values` are appended. If `axis` is not given,</span>
<span class="sd">        both `arr` and `values` are flattened before use.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A copy of `arr` with `values` appended to `axis`. Note that</span>
<span class="sd">        `append` does not occur in-place: a new array is allocated and</span>
<span class="sd">        filled. If `axis` is ``None``, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.insert` : Insert elements into an array.</span>
<span class="sd">    :obj:`dpnp.delete` : Delete elements from an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.append(a, [[4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    When `axis` is specified, `values` must have the correct shape.</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.append(b, [[7, 8, 9]], axis=0)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.append(b, [7, 8, 9], axis=0)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">    ValueError: all the input arrays must have same number of dimensions, but</span>
<span class="sd">    the array at index 0 has 2 dimension(s) and the array at index 1 has 1</span>
<span class="sd">    dimension(s)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">sycl_queue</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="array_split">
<a class="viewcode-back" href="../../reference/generated/dpnp.array_split.html#dpnp.array_split">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">array_split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split an array into multiple sub-arrays.</span>

<span class="sd">    Please refer to the :obj:`dpnp.split` documentation. The only difference</span>
<span class="sd">    between these functions is that ``dpnp.array_split`` allows</span>
<span class="sd">    `indices_or_sections` to be an integer that does *not* equally divide the</span>
<span class="sd">    axis. For an array of length l that should be split into n sections, it</span>
<span class="sd">    returns ``l % n`` sub-arrays of size ``l//n + 1`` and the rest of size</span>
<span class="sd">    ``l//n``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.array_split`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be divided into sub-arrays.</span>
<span class="sd">    indices_or_sections : {int, sequence of ints}</span>
<span class="sd">        If `indices_or_sections` is an integer, N, and array length is l, it</span>
<span class="sd">        returns ``l % n`` sub-arrays of size ``l//n + 1`` and the rest of size</span>
<span class="sd">        ``l//n``.</span>
<span class="sd">        If `indices_or_sections` is a sequence of sorted integers, the entries</span>
<span class="sd">        indicate where along `axis` the array is split.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to split.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sub-arrays : list of dpnp.ndarray</span>
<span class="sd">        A list of sub arrays. Each array is a view of the corresponding input</span>
<span class="sd">        array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.split` : Split array into multiple sub-arrays of equal size.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(8.0)</span>
<span class="sd">    &gt;&gt;&gt; np.array_split(x, 3)</span>
<span class="sd">    [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])]</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(9)</span>
<span class="sd">    &gt;&gt;&gt; np.array_split(x, 4)</span>
<span class="sd">    [array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="n">n_tot</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># handle array case.</span>
        <span class="n">n_sec</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">div_points</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">n_tot</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># indices_or_sections is a scalar, not an array.</span>
        <span class="n">n_sec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_sec</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;number sections must be larger than 0.&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
        <span class="n">n_each_sec</span><span class="p">,</span> <span class="n">extras</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">n_tot</span><span class="p">,</span> <span class="n">n_sec</span><span class="p">)</span>
        <span class="n">section_sizes</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">extras</span> <span class="o">*</span> <span class="p">[</span><span class="n">n_each_sec</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_sec</span> <span class="o">-</span> <span class="n">extras</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">n_each_sec</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">div_points</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="n">section_sizes</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">ary</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

    <span class="n">sub_arys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sary</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sec</span><span class="p">):</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">div_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">div_points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sub_arys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">sary</span><span class="p">[</span><span class="n">st</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">sub_arys</span></div>



<div class="viewcode-block" id="asarray_chkfinite">
<a class="viewcode-back" href="../../reference/generated/dpnp.asarray_chkfinite.html#dpnp.asarray_chkfinite">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">asarray_chkfinite</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input to an array, checking for NaNs or Infs.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.asarray_chkfinite`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array. This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists and ndarrays. Success requires no NaNs or Infs.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;, &quot;K&quot;}, optional</span>
<span class="sd">        Memory layout of the newly output array.</span>

<span class="sd">        Default: ``&quot;K&quot;``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {None, &quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Array interpretation of `a`. No copy is performed if the input is</span>
<span class="sd">        already an ndarray.</span>

<span class="sd">    Raises</span>
<span class="sd">    -------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raises ``ValueError`` if `a` contains NaN (Not a Number) or</span>
<span class="sd">        Inf (Infinity).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.asarray` : Create an array.</span>
<span class="sd">    :obj:`dpnp.asanyarray` : Converts an input object into array.</span>
<span class="sd">    :obj:`dpnp.ascontiguousarray` : Convert input to a c-contiguous array.</span>
<span class="sd">    :obj:`dpnp.asfortranarray` : Convert input to an array with column-major</span>
<span class="sd">                        memory order.</span>
<span class="sd">    :obj:`dpnp.fromiter` : Create an array from an iterator.</span>
<span class="sd">    :obj:`dpnp.fromfunction` : Construct an array by executing a function</span>
<span class="sd">                        on grid positions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>

<span class="sd">    Convert a list into an array. If all elements are finite,</span>
<span class="sd">    ``asarray_chkfinite`` is identical to ``asarray``.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2]</span>
<span class="sd">    &gt;&gt;&gt; np.asarray_chkfinite(a, dtype=np.float32)</span>
<span class="sd">    array([1., 2.])</span>

<span class="sd">    Raises ``ValueError`` if array_like contains NaNs or Infs.</span>

<span class="sd">    &gt;&gt;&gt; a = [1, 2, np.inf]</span>
<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     np.asarray_chkfinite(a)</span>
<span class="sd">    ... except ValueError:</span>
<span class="sd">    ...     print(&#39;ValueError&#39;)</span>
<span class="sd">    ValueError</span>

<span class="sd">    Creating an array on a different device or with a specified usm_type</span>

<span class="sd">    &gt;&gt;&gt; x = np.asarray_chkfinite([1, 2, 3]) # default case</span>
<span class="sd">    &gt;&gt;&gt; x, x.device, x.usm_type</span>
<span class="sd">    (array([1, 2, 3]), Device(level_zero:gpu:0), &#39;device&#39;)</span>

<span class="sd">    &gt;&gt;&gt; y = np.asarray_chkfinite([1, 2, 3], device=&quot;cpu&quot;)</span>
<span class="sd">    &gt;&gt;&gt; y, y.device, y.usm_type</span>
<span class="sd">    (array([1, 2, 3]), Device(opencl:cpu:0), &#39;device&#39;)</span>

<span class="sd">    &gt;&gt;&gt; z = np.asarray_chkfinite([1, 2, 3], usm_type=&quot;host&quot;)</span>
<span class="sd">    &gt;&gt;&gt; z, z.device, z.usm_type</span>
<span class="sd">    (array([1, 2, 3]), Device(level_zero:gpu:0), &#39;host&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">inexact</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array must not contain infs or NaNs&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span></div>



<div class="viewcode-block" id="asfarray">
<a class="viewcode-back" href="../../reference/generated/dpnp.asfarray.html#dpnp.asfarray">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">asfarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array converted to a float type.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.asfarray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.</span>
<span class="sd">        This includes an instance of :class:`dpnp.ndarray` or</span>
<span class="sd">        :class:`dpctl.tensor.usm_ndarray`, an object representing</span>
<span class="sd">        SYCL USM allocation and implementing `__sycl_usm_array_interface__`</span>
<span class="sd">        protocol, an instance of :class:`numpy.ndarray`, an object supporting</span>
<span class="sd">        Python buffer protocol, a Python scalar, or a (possibly nested)</span>
<span class="sd">        sequence of Python scalars.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        Float type code to coerce input array `a`.  If `dtype` is ``None``,</span>
<span class="sd">        :obj:`dpnp.bool` or one of the `int` dtypes, it is replaced with</span>
<span class="sd">        the default floating type (:obj:`dpnp.float64` if a device supports it,</span>
<span class="sd">        or :obj:`dpnp.float32` type otherwise).</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {None, &quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The input `a` as a float ndarray.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    This function is deprecated in favor of :obj:`dpnp.asarray` and</span>
<span class="sd">    will be removed in a future release.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.asfarray([2, 3])</span>
<span class="sd">    array([2.,  3.])</span>
<span class="sd">    &gt;&gt;&gt; np.asfarray([2, 3], dtype=dpnp.float32)</span>
<span class="sd">    array([2., 3.], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; np.asfarray([2, 3], dtype=dpnp.int32)</span>
<span class="sd">    array([2.,  3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;`dpnp.asfarray` is deprecated, &quot;</span>
        <span class="s2">&quot;and will be removed in a future release. &quot;</span>
        <span class="s2">&quot;Please use `dpnp.asarray` with an appropriate dtype instead.&quot;</span><span class="p">,</span>
        <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">_sycl_queue</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_normalized_queue_device</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">default_float_type</span><span class="p">(</span><span class="n">sycl_queue</span><span class="o">=</span><span class="n">_sycl_queue</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">_sycl_queue</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="atleast_1d">
<a class="viewcode-back" href="../../reference/generated/dpnp.atleast_1d.html#dpnp.atleast_1d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert inputs to arrays with at least one dimension.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.atleast_1d`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arys : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One or more array-like sequences. Arrays that already have one or more</span>
<span class="sd">        dimensions are preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array, or list of arrays, each with ``a.ndim &gt;= 1``.</span>
<span class="sd">        Copies are made only if necessary.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.atleast_2d` : View inputs as arrays with at least two dimensions.</span>
<span class="sd">    :obj:`dpnp.atleast_3d` : View inputs as arrays with at least three</span>
<span class="sd">                             dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array(1.0)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_1d(x)</span>
<span class="sd">    array([1.])</span>

<span class="sd">    &gt;&gt;&gt; y = np.array([3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_1d(x, y)</span>
<span class="sd">    [array([1.]), array([3, 4])]</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(9.0).reshape(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_1d(x)</span>
<span class="sd">    array([[0., 1., 2.],</span>
<span class="sd">           [3., 4., 5.],</span>
<span class="sd">           [6., 7., 8.]])</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_1d(x) is x</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ary</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 0-d arrays cannot be empty</span>
            <span class="c1"># 0-d arrays always have a size of 1, so</span>
            <span class="c1"># reshape(1) is guaranteed to succeed</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="atleast_2d">
<a class="viewcode-back" href="../../reference/generated/dpnp.atleast_2d.html#dpnp.atleast_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    View inputs as arrays with at least two dimensions.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.atleast_2d`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arys : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One or more array-like sequences. Arrays that already have two or more</span>
<span class="sd">        dimensions are preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array, or list of arrays, each with ``a.ndim &gt;= 2``.</span>
<span class="sd">        Copies are avoided where possible, and views with two or more</span>
<span class="sd">        dimensions are returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.atleast_1d` : Convert inputs to arrays with at least one</span>
<span class="sd">                             dimension.</span>
<span class="sd">    :obj:`dpnp.atleast_3d` : View inputs as arrays with at least three</span>
<span class="sd">                             dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array(3.0)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_2d(x)</span>
<span class="sd">    array([[3.]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(3.0)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_2d(x)</span>
<span class="sd">    array([[0., 1., 2.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ary</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="atleast_3d">
<a class="viewcode-back" href="../../reference/generated/dpnp.atleast_3d.html#dpnp.atleast_3d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">atleast_3d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    View inputs as arrays with at least three dimensions.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.atleast_3d`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arys : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One or more array-like sequences. Arrays that already have three or more</span>
<span class="sd">        dimensions are preserved.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array, or list of arrays, each with ``a.ndim &gt;= 3``. Copies are</span>
<span class="sd">        avoided where possible, and views with three or more dimensions are</span>
<span class="sd">        returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.atleast_1d` : Convert inputs to arrays with at least one</span>
<span class="sd">                             dimension.</span>
<span class="sd">    :obj:`dpnp.atleast_2d` : View inputs as arrays with at least three</span>
<span class="sd">                             dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array(3.0)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_3d(x)</span>
<span class="sd">    array([[[3.]]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(3.0)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_3d(x).shape</span>
<span class="sd">    (1, 3, 1)</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(12.0).reshape(4, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.atleast_3d(x).shape</span>
<span class="sd">    (4, 3, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ary</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ary</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="broadcast_arrays">
<a class="viewcode-back" href="../../reference/generated/dpnp.broadcast_arrays.html#dpnp.broadcast_arrays">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast any number of arrays against each other.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.broadcast_arrays`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    args : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A list of arrays to broadcast.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : list of dpnp.ndarray</span>
<span class="sd">        A list of arrays which are views on the original arrays from `args`.</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    Parameter `subok` is supported with default value.</span>
<span class="sd">    Otherwise ``NotImplementedError`` exception will be raised.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.broadcast_to` : Broadcast an array to a new shape.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[4], [5]])</span>
<span class="sd">    &gt;&gt;&gt; np.broadcast_arrays(x, y)</span>
<span class="sd">    [array([[1, 2, 3],</span>
<span class="sd">            [1, 2, 3]]), array([[4, 4, 4],</span>
<span class="sd">            [5, 5, 5]])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">subok</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subok=</span><span class="si">{</span><span class="n">subok</span><span class="si">}</span><span class="s2"> is currently not supported&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="n">usm_arrays</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">usm_arrays</span><span class="p">]</span></div>



<div class="viewcode-block" id="broadcast_shapes">
<a class="viewcode-back" href="../../reference/generated/dpnp.broadcast_shapes.html#dpnp.broadcast_shapes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast the input shapes into a single shape.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.broadcast_shapes`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : tuples of ints, or ints</span>
<span class="sd">        The shapes to be broadcast against each other.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple</span>
<span class="sd">        Broadcasted shape.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.broadcast_arrays` : Broadcast any number of arrays against</span>
<span class="sd">                                   each other.</span>
<span class="sd">    :obj:`dpnp.broadcast_to` : Broadcast an array to a new shape.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.broadcast_shapes((1, 2), (3, 1), (3, 2))</span>
<span class="sd">    (3, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.broadcast_shapes((6, 7), (5, 6, 1), (7,), (5, 1, 7))</span>
<span class="sd">    (5, 6, 7)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>



<span class="c1"># pylint: disable=redefined-outer-name</span>
<div class="viewcode-block" id="broadcast_to">
<a class="viewcode-back" href="../../reference/generated/dpnp.broadcast_to.html#dpnp.broadcast_to">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">broadcast_to</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Broadcast an array to a new shape.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.broadcast_to`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array to broadcast.</span>
<span class="sd">    shape : {int, tuple of ints}</span>
<span class="sd">        The shape of the desired array. A single integer ``i`` is interpreted</span>
<span class="sd">        as ``(i,)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array having a specified shape.</span>
<span class="sd">        Must have the same data type as `array`.</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    Parameter `subok` is supported with default value.</span>
<span class="sd">    Otherwise ``NotImplementedError`` exception will be raised.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.broadcast_arrays` : Broadcast any number of arrays against</span>
<span class="sd">                                   each other.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.broadcast_to(x, (3, 3))</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [1, 2, 3],</span>
<span class="sd">           [1, 2, 3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">subok</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;subok=</span><span class="si">{</span><span class="n">subok</span><span class="si">}</span><span class="s2"> is currently not supported&quot;</span><span class="p">)</span>

    <span class="n">usm_array</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">usm_array</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">new_array</span><span class="p">)</span></div>



<div class="viewcode-block" id="can_cast">
<a class="viewcode-back" href="../../reference/generated/dpnp.can_cast.html#dpnp.can_cast">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">can_cast</span><span class="p">(</span><span class="n">from_</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns ``True`` if cast between data types can occur according</span>
<span class="sd">    to the casting rule.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.can_cast`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_ : {dpnp.ndarray, usm_ndarray, dtype, dtype specifier}</span>
<span class="sd">        Source data type.</span>
<span class="sd">    to : dtype</span>
<span class="sd">        Target data type.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur.</span>

<span class="sd">        Default: ``&quot;safe&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out: bool</span>
<span class="sd">        ``True`` if cast can occur according to the casting rule,</span>
<span class="sd">        ``False`` otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.result_type` : Returns the type that results from applying</span>
<span class="sd">                              the NumPy type promotion rules to the arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic examples</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(np.int32, np.int64)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(np.float64, complex)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(complex, float)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;f8&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;f4&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    Array scalar checks the value, array does not</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(np.array(1000.0), np.float32)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(np.array([1000.0]), np.float32)</span>
<span class="sd">    False</span>

<span class="sd">    Using the casting rules</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;i8&#39;, &#39;i8&#39;, &#39;no&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i8&#39;, &#39;no&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i8&#39;, &#39;equiv&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i4&#39;, &#39;&gt;i8&#39;, &#39;equiv&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i4&#39;, &#39;&gt;i8&#39;, &#39;safe&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i4&#39;, &#39;safe&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;i4&#39;, &#39;same_kind&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;u4&#39;, &#39;same_kind&#39;)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; np.can_cast(&#39;&lt;i8&#39;, &#39;&gt;u4&#39;, &#39;unsafe&#39;)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">to</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot construct a dtype from an array&quot;</span><span class="p">)</span>

    <span class="n">dtype_from</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">from_</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">from_</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">from_</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">dtype_from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span></div>



<div class="viewcode-block" id="column_stack">
<a class="viewcode-back" href="../../reference/generated/dpnp.column_stack.html#dpnp.column_stack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">column_stack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stacks 1-D and 2-D arrays as columns into a 2-D array.</span>

<span class="sd">    Take a sequence of 1-D arrays and stack them as columns to make a single</span>
<span class="sd">    2-D array. 2-D arrays are stacked as-is, just like with :obj:`dpnp.hstack`.</span>
<span class="sd">    1-D arrays are turned into 2-D columns first.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.column_stack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tup : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A sequence of 1-D or 2-D arrays to stack. All of them must have</span>
<span class="sd">        the same first dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The array formed by stacking the given arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise (along third axis).</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; b = np.array((4, 5, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.column_stack((a, b))</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [2, 5],</span>
<span class="sd">           [3, 6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_check_stack_arrays</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">v</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Only 1 or 2 dimensional arrays can be column stacked&quot;</span>
            <span class="p">)</span>

        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="concatenate">
<a class="viewcode-back" href="../../reference/generated/dpnp.concatenate.html#dpnp.concatenate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">concatenate</span><span class="p">(</span>
    <span class="n">arrays</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join a sequence of arrays along an existing axis.</span>

<span class="sd">    Note that :obj:`dpnp.concat` is an alias of :obj:`dpnp.concatenate`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.concatenate`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : {Sequence of dpnp.ndarray or usm_ndarray}</span>
<span class="sd">        The arrays must have the same shape, except in the dimension</span>
<span class="sd">        corresponding to axis (the first, by default).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the arrays will be joined. If axis is ``None``,</span>
<span class="sd">        arrays are flattened before use.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    out : dpnp.ndarray, optional</span>
<span class="sd">        If provided, the destination to place the result. The shape must be</span>
<span class="sd">        correct, matching that of what concatenate would have returned</span>
<span class="sd">        if no out argument were specified.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        If provided, the destination array will have this dtype. Cannot be</span>
<span class="sd">        provided together with `out`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur.</span>

<span class="sd">        Default: ``&quot;same_kind&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The concatenated array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.array_split` : Split an array into multiple sub-arrays of equal</span>
<span class="sd">                              or near-equal size.</span>
<span class="sd">    :obj:`dpnp.split` : Split array into a list of multiple sub-arrays of equal</span>
<span class="sd">                        size.</span>
<span class="sd">    :obj:`dpnp.hsplit` : Split array into multiple sub-arrays horizontally</span>
<span class="sd">                         (column wise).</span>
<span class="sd">    :obj:`dpnp.vsplit` : Split array into multiple sub-arrays vertically</span>
<span class="sd">                         (row wise).</span>
<span class="sd">    :obj:`dpnp.dsplit` : Split array into multiple sub-arrays along</span>
<span class="sd">                         the 3rd axis (depth).</span>
<span class="sd">    :obj:`dpnp.stack` : Stack a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble arrays from blocks.</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise</span>
<span class="sd">                         (along third dimension).</span>
<span class="sd">    :obj:`dpnp.column_stack` : Stack 1-D arrays as columns into a 2-D array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.concatenate((a, b), axis=0)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.concatenate((a, b.T), axis=1)</span>
<span class="sd">    array([[1, 2, 5],</span>
<span class="sd">           [3, 4, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.concatenate((a, b), axis=None)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;concatenate() only takes `out` or `dtype` as an argument, &quot;</span>
            <span class="s2">&quot;but both were provided.&quot;</span>
        <span class="p">)</span>

    <span class="n">usm_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">usm_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">res</span></div>



<span class="n">concat</span> <span class="o">=</span> <span class="n">concatenate</span>  <span class="c1"># concat is an alias of concatenate</span>


<div class="viewcode-block" id="copyto">
<a class="viewcode-back" href="../../reference/generated/dpnp.copyto.html#dpnp.copyto">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">copyto</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copies values from one array to another, broadcasting as necessary.</span>

<span class="sd">    Raises a ``TypeError`` if the `casting` rule is violated, and if</span>
<span class="sd">    `where` is provided, it selects which elements to copy.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.copyto`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dst : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array into which values are copied.</span>
<span class="sd">    src : array_like</span>
<span class="sd">        The array from which values are copied.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur when copying.</span>

<span class="sd">        Default: ``&quot;same_kind&quot;``.</span>
<span class="sd">    where : {dpnp.ndarray, usm_ndarray, scalar} of bool, optional</span>
<span class="sd">        A boolean array or a scalar which is broadcasted to match</span>
<span class="sd">        the dimensions of `dst`, and selects elements to copy</span>
<span class="sd">        from `src` to `dst` wherever it contains the value ``True``.</span>

<span class="sd">        Default: ``True``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; B = [1, 2, 3]</span>
<span class="sd">    &gt;&gt;&gt; np.copyto(A, B)</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([1, 2, 3])</span>

<span class="sd">    &gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; B = [[4, 5, 6], [7, 8, 9]]</span>
<span class="sd">    &gt;&gt;&gt; np.copyto(A, B)</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">dst</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Destination array must be any of supported type, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">python_sc</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">generic</span><span class="p">)</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">dst</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">python_sc</span><span class="p">:</span>
            <span class="c1"># Python scalar needs special handling to behave similar to NumPy</span>
            <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span>
                <span class="n">dst</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unsignedinteger</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">src</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">OverflowError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot copy negative values to an unsigned int array&quot;</span>
                    <span class="p">)</span>

                <span class="n">src</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dst</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">src</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dst</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Cannot cast from </span><span class="si">{</span><span class="n">src</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">dst</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;according to the rule </span><span class="si">{</span><span class="n">casting</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">dst</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">src</span>
    <span class="k">elif</span> <span class="n">where</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># nothing to copy</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="n">where</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">dst</span><span class="o">.</span><span class="n">sycl_queue</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`where` array must be any of supported type, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">where</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">where</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`where` keyword argument must be of boolean type, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;but got </span><span class="si">{</span><span class="n">where</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">dst_usm</span><span class="p">,</span> <span class="n">src_usm</span><span class="p">,</span> <span class="n">mask_usm</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">dst</span><span class="p">),</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">src</span><span class="p">),</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">where</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">dst_usm</span><span class="p">[</span><span class="n">mask_usm</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_usm</span><span class="p">[</span><span class="n">mask_usm</span><span class="p">]</span></div>



<div class="viewcode-block" id="delete">
<a class="viewcode-back" href="../../reference/generated/dpnp.delete.html#dpnp.delete">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">delete</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with sub-arrays along an axis deleted. For a one</span>
<span class="sd">    dimensional array, this returns those entries not returned by</span>
<span class="sd">    ``arr[obj]``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.delete`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : {slice, int, array-like of ints or boolean}</span>
<span class="sd">        Indicate indices of sub-arrays to remove along the specified axis.</span>
<span class="sd">        Boolean indices are treated as a mask of elements to remove.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        The axis along which to delete the subarray defined by `obj`.</span>
<span class="sd">        If `axis` is ``None``, `obj` is applied to the flattened array.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A copy of `arr` with the elements specified by `obj` removed. Note</span>
<span class="sd">        that `delete` does not occur in-place. If `axis` is ``None``, `out` is</span>
<span class="sd">        a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.insert` : Insert elements into an array.</span>
<span class="sd">    :obj:`dpnp.append` : Append elements at the end of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Often it is preferable to use a boolean mask. For example:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(12) + 1</span>
<span class="sd">    &gt;&gt;&gt; mask = np.ones(len(arr), dtype=np.bool)</span>
<span class="sd">    &gt;&gt;&gt; mask[0] = mask[2] = mask[4] = False</span>
<span class="sd">    &gt;&gt;&gt; result = arr[mask,...]</span>

<span class="sd">    is equivalent to ``np.delete(arr, [0, 2, 4], axis=0)``, but allows further</span>
<span class="sd">    use of `mask`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 5,  6,  7,  8],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, 1, 0)</span>
<span class="sd">    array([[ 1,  2,  3,  4],</span>
<span class="sd">           [ 9, 10, 11, 12]])</span>

<span class="sd">    &gt;&gt;&gt; np.delete(arr, slice(None, None, 2), 1)</span>
<span class="sd">    array([[ 2,  4],</span>
<span class="sd">           [ 6,  8],</span>
<span class="sd">           [10, 12]])</span>
<span class="sd">    &gt;&gt;&gt; np.delete(arr, [1, 3, 5], None)</span>
<span class="sd">    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">_calc_parameters</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_delete_with_slice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">single_value</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">is_array</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">dpnp_array</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">obj</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">usm_type</span>
        <span class="p">)</span>
        <span class="c1"># if `obj` is originally an empty list, after converting it into</span>
        <span class="c1"># an array, it will have float dtype, so we need to change its dtype</span>
        <span class="c1"># to integer. However, if `obj` is originally an empty array with</span>
        <span class="c1"># float dtype, it is a mistake by user and it will raise an error later</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_array</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s2">&quot;ui&quot;</span><span class="p">:</span>
            <span class="c1"># For a size 1 integer array we can use the single-value path</span>
            <span class="c1"># (most dtypes, except boolean, should just fail later).</span>
            <span class="n">single_value</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># In dpnp, `.item()` calls `.wait()`, so it is preferred to avoid it</span>
            <span class="c1"># When possible (i.e. for numpy arrays, lists, etc), it is</span>
            <span class="c1"># preferred to use `.item()` on a NumPy array</span>
            <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">_delete_without_slice</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">single_value</span><span class="p">)</span></div>



<div class="viewcode-block" id="dsplit">
<a class="viewcode-back" href="../../reference/generated/dpnp.dsplit.html#dpnp.dsplit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dsplit</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split array into multiple sub-arrays along the 3rd axis (depth).</span>

<span class="sd">    Please refer to the :obj:`dpnp.split` documentation. ``dsplit``</span>
<span class="sd">    is equivalent to ``split`` with ``axis=2``, the array is always</span>
<span class="sd">    split along the third axis provided the array dimension is greater than</span>
<span class="sd">    or equal to 3.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.dsplit`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be divided into sub-arrays.</span>
<span class="sd">    indices_or_sections : {int, sequence of ints}</span>
<span class="sd">        If `indices_or_sections` is an integer, N, the array will be divided</span>
<span class="sd">        into N equal arrays along the third axis. If such a split is not</span>
<span class="sd">        possible, an error is raised.</span>
<span class="sd">        If `indices_or_sections` is a sequence of sorted integers, the entries</span>
<span class="sd">        indicate where along the third axis the array is split.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sub-arrays : list of dpnp.ndarray</span>
<span class="sd">        A list of sub arrays. Each array is a view of the corresponding input</span>
<span class="sd">        array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.split` : Split array into multiple sub-arrays of equal size.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(16.0).reshape(2, 2, 4)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[ 0.,  1.,  2.,  3.],</span>
<span class="sd">            [ 4.,  5.,  6.,  7.]],</span>
<span class="sd">           [[ 8.,  9., 10., 11.],</span>
<span class="sd">            [12., 13., 14., 15.]]])</span>
<span class="sd">    &gt;&gt;&gt; np.dsplit(x, 2)</span>
<span class="sd">    [array([[[ 0.,  1.],</span>
<span class="sd">             [ 4.,  5.]],</span>
<span class="sd">            [[ 8.,  9.],</span>
<span class="sd">             [12., 13.]]]),</span>
<span class="sd">     array([[[ 2.,  3.],</span>
<span class="sd">             [ 6.,  7.]],</span>
<span class="sd">            [[10., 11.],</span>
<span class="sd">             [14., 15.]]])]</span>
<span class="sd">    &gt;&gt;&gt; np.dsplit(x, np.array([3, 6]))</span>
<span class="sd">    [array([[[ 0.,  1.,  2.],</span>
<span class="sd">             [ 4.,  5.,  6.]],</span>
<span class="sd">            [[ 8.,  9., 10.],</span>
<span class="sd">             [12., 13., 14.]]]),</span>
<span class="sd">     array([[[ 3.],</span>
<span class="sd">             [ 7.]],</span>
<span class="sd">            [[11.],</span>
<span class="sd">             [15.]]]),</span>
<span class="sd">     array([])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;dsplit only works on arrays of 3 or more dimensions&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="dstack">
<a class="viewcode-back" href="../../reference/generated/dpnp.dstack.html#dpnp.dstack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dstack</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack arrays in sequence depth wise (along third axis).</span>

<span class="sd">    This is equivalent to concatenation along the third axis after 2-D arrays</span>
<span class="sd">    of shape `(M, N)` have been reshaped to `(M, N, 1)` and 1-D arrays of shape</span>
<span class="sd">    `(N,)` have been reshaped to `(1, N, 1)`. Rebuilds arrays divided by</span>
<span class="sd">    :obj:`dpnp.dsplit`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.dstack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tup : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One or more array-like sequences. The arrays must have the same shape</span>
<span class="sd">        along all but the third axis. 1-D or 2-D arrays must have the same</span>
<span class="sd">        shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The array formed by stacking the given arrays, will be at least 3-D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.column_stack` : Stack 1-D arrays as columns into a 2-D array.</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble an ndarray from nested lists of blocks.</span>
<span class="sd">    :obj:`dpnp.dsplit` : Split array along third axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; b = np.array((4, 5, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.dstack((a, b))</span>
<span class="sd">    array([[[1, 4],</span>
<span class="sd">            [2, 5],</span>
<span class="sd">            [3, 6]]])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1], [2], [3]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[4], [5], [6]])</span>
<span class="sd">    &gt;&gt;&gt; np.dstack((a, b))</span>
<span class="sd">    array([[[1, 4]],</span>
<span class="sd">           [[2, 5]],</span>
<span class="sd">           [[3, 6]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_check_stack_arrays</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>

    <span class="n">arrs</span> <span class="o">=</span> <span class="n">atleast_3d</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="expand_dims">
<a class="viewcode-back" href="../../reference/generated/dpnp.expand_dims.html#dpnp.expand_dims">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the shape of an array.</span>

<span class="sd">    Insert a new axis that will appear at the `axis` position in the expanded</span>
<span class="sd">    array shape.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.expand_dims`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : {int, tuple of ints}</span>
<span class="sd">        Position in the expanded axes where the new axis (or axes) is placed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array with the number of dimensions increased.</span>
<span class="sd">        A view is returned whenever possible.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `a` has rank (i.e, number of dimensions) `N`, a valid `axis` must reside</span>
<span class="sd">    in the closed-interval `[-N-1, N]`.</span>
<span class="sd">    If provided a negative `axis`, the `axis` position at which to insert a</span>
<span class="sd">    singleton dimension is computed as `N + axis + 1`.</span>
<span class="sd">    Hence, if provided `-1`, the resolved axis position is `N` (i.e.,</span>
<span class="sd">    a singleton dimension must be appended to the input array `a`).</span>
<span class="sd">    If provided `-N-1`, the resolved axis position is `0` (i.e., a</span>
<span class="sd">    singleton dimension is added to the input array `a`).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.squeeze` : The inverse operation, removing singleton dimensions</span>
<span class="sd">    :obj:`dpnp.reshape` : Insert, remove, and combine dimensions, and resize</span>
<span class="sd">                          existing ones</span>
<span class="sd">    :obj:`dpnp.atleast_1d` : Convert inputs to arrays with at least one</span>
<span class="sd">                             dimension.</span>
<span class="sd">    :obj:`dpnp.atleast_2d` : View inputs as arrays with at least two dimensions.</span>
<span class="sd">    :obj:`dpnp.atleast_3d` : View inputs as arrays with at least three</span>
<span class="sd">                             dimensions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (2,)</span>

<span class="sd">    The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:</span>

<span class="sd">    &gt;&gt;&gt; y = np.expand_dims(x, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([[1, 2]])</span>
<span class="sd">    &gt;&gt;&gt; y.shape</span>
<span class="sd">    (1, 2)</span>

<span class="sd">    The following is equivalent to ``x[:, np.newaxis]``:</span>

<span class="sd">    &gt;&gt;&gt; y = np.expand_dims(x, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [2]])</span>
<span class="sd">    &gt;&gt;&gt; y.shape</span>
<span class="sd">    (2, 1)</span>

<span class="sd">    ``axis`` may also be a tuple:</span>

<span class="sd">    &gt;&gt;&gt; y = np.expand_dims(x, axis=(0, 1))</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([[[1, 2]]])</span>

<span class="sd">    &gt;&gt;&gt; y = np.expand_dims(x, axis=(2, 0))</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([[[1],</span>
<span class="sd">            [2]]])</span>

<span class="sd">    Note that some examples may use ``None`` instead of ``np.newaxis``.  These</span>
<span class="sd">    are the same objects:</span>

<span class="sd">    &gt;&gt;&gt; np.newaxis is None</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="flip">
<a class="viewcode-back" href="../../reference/generated/dpnp.flip.html#dpnp.flip">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the order of elements in an array along the given axis.</span>

<span class="sd">    The shape of the array is preserved, but the elements are reordered.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.flip`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : {None, int, tuple of ints}, optional</span>
<span class="sd">         Axis or axes along which to flip over. The default,</span>
<span class="sd">         ``axis=None``, will flip over all of the axes of the input array.</span>
<span class="sd">         If `axis` is negative it counts from the last to the first axis.</span>
<span class="sd">         If `axis` is a tuple of integers, flipping is performed on all of</span>
<span class="sd">         the axes specified in the tuple.</span>

<span class="sd">         Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A view of `m` with the entries of axis reversed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.flipud` : Flip an array vertically (axis=0).</span>
<span class="sd">    :obj:`dpnp.fliplr` : Flip an array horizontally (axis=1).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.arange(8).reshape((2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 0)</span>
<span class="sd">    array([[[4, 5],</span>
<span class="sd">            [6, 7]],</span>
<span class="sd">           [[0, 1],</span>
<span class="sd">            [2, 3]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, 1)</span>
<span class="sd">    array([[[2, 3],</span>
<span class="sd">            [0, 1]],</span>
<span class="sd">           [[6, 7],</span>
<span class="sd">            [4, 5]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A)</span>
<span class="sd">    array([[[7, 6],</span>
<span class="sd">            [5, 4]],</span>
<span class="sd">           [[3, 2],</span>
<span class="sd">            [1, 0]]])</span>
<span class="sd">    &gt;&gt;&gt; np.flip(A, (0, 2))</span>
<span class="sd">    array([[[5, 4],</span>
<span class="sd">            [7, 6]],</span>
<span class="sd">           [[1, 0],</span>
<span class="sd">            [3, 2]]])</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.randn(3, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.all(np.flip(A, 2) == A[:, :, ::-1, ...])</span>
<span class="sd">    array(True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">m_usm</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">dpt</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">m_usm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span></div>



<div class="viewcode-block" id="fliplr">
<a class="viewcode-back" href="../../reference/generated/dpnp.fliplr.html#dpnp.fliplr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fliplr</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the order of elements along axis 1 (left/right).</span>

<span class="sd">    For a 2-D array, this flips the entries in each row in the left/right</span>
<span class="sd">    direction. Columns are preserved, but appear in a different order than</span>
<span class="sd">    before.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.fliplr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array, must be at least 2-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A view of `m` with the columns reversed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.flipud` : Flip an array vertically (axis=0).</span>
<span class="sd">    :obj:`dpnp.flip` : Flip array in one or more dimensions.</span>
<span class="sd">    :obj:`dpnp.rot90` : Rotate array counterclockwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.diag(np.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[1.,  0.,  0.],</span>
<span class="sd">           [0.,  2.,  0.],</span>
<span class="sd">           [0.,  0.,  3.]])</span>
<span class="sd">    &gt;&gt;&gt; np.fliplr(A)</span>
<span class="sd">    array([[0.,  0.,  1.],</span>
<span class="sd">           [0.,  2.,  0.],</span>
<span class="sd">           [3.,  0.,  0.]])</span>

<span class="sd">    &gt;&gt;&gt; A = np.random.randn(2, 3, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.all(np.fliplr(A) == A[:, ::-1, ...])</span>
<span class="sd">    array(True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input must be &gt;= 2-d, but got </span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="flipud">
<a class="viewcode-back" href="../../reference/generated/dpnp.flipud.html#dpnp.flipud">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flipud</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reverse the order of elements along axis 0 (up/down).</span>

<span class="sd">    For a 2-D array, this flips the entries in each column in the up/down</span>
<span class="sd">    direction. Rows are preserved, but appear in a different order than before.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.flipud`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A view of `m` with the rows reversed.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.fliplr` : Flip array in the left/right direction.</span>
<span class="sd">    :obj:`dpnp.flip` : Flip array in one or more dimensions.</span>
<span class="sd">    :obj:`dpnp.rot90` : Rotate array counterclockwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.diag(np.array([1., 2., 3.]))</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[1.,  0.,  0.],</span>
<span class="sd">           [0.,  2.,  0.],</span>
<span class="sd">           [0.,  0.,  3.]])</span>
<span class="sd">    &gt;&gt;&gt; np.flipud(A)</span>
<span class="sd">    array([[0.,  0.,  3.],</span>
<span class="sd">           [0.,  2.,  0.],</span>
<span class="sd">           [1.,  0.,  0.]])</span>

<span class="sd">    &gt;&gt;&gt; A = np.random.randn(2, 3, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.all(np.flipud(A) == A[::-1, ...])</span>
<span class="sd">    array(True)</span>

<span class="sd">    &gt;&gt;&gt; np.flipud(np.array([1, 2]))</span>
<span class="sd">    array([2, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input must be &gt;= 1-d, but got </span><span class="si">{</span><span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span></div>



<div class="viewcode-block" id="hsplit">
<a class="viewcode-back" href="../../reference/generated/dpnp.hsplit.html#dpnp.hsplit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hsplit</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split an array into multiple sub-arrays horizontally (column-wise).</span>

<span class="sd">    Please refer to the :obj:`dpnp.split` documentation. ``hsplit``</span>
<span class="sd">    is equivalent to ``dpnp.split`` with ``axis=1``, the array is always</span>
<span class="sd">    split along the second axis except for 1-D arrays, where it is split at</span>
<span class="sd">    ``axis=0``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.hsplit`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be divided into sub-arrays.</span>
<span class="sd">    indices_or_sections : {int, sequence of ints}</span>
<span class="sd">        If `indices_or_sections` is an integer, N, the array will be divided</span>
<span class="sd">        into N equal arrays along the second axis except for 1-D arrays, where</span>
<span class="sd">        it is split at the first axis. If such a split is not possible,</span>
<span class="sd">        an error is raised.</span>
<span class="sd">        If `indices_or_sections` is a sequence of sorted integers, the entries</span>
<span class="sd">        indicate where along the second axis the array is split. For 1-D arrays,</span>
<span class="sd">        the entries indicate where along the first axis the array is split.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sub-arrays : list of dpnp.ndarray</span>
<span class="sd">        A list of sub arrays. Each array is a view of the corresponding input</span>
<span class="sd">        array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.split` : Split array into multiple sub-arrays of equal size.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.],</span>
<span class="sd">           [ 4.,  5.,  6.,  7.],</span>
<span class="sd">           [ 8.,  9., 10., 11.],</span>
<span class="sd">           [12., 13., 14., 15.]])</span>
<span class="sd">    &gt;&gt;&gt; np.hsplit(x, 2)</span>
<span class="sd">    [array([[ 0.,  1.],</span>
<span class="sd">            [ 4.,  5.],</span>
<span class="sd">            [ 8.,  9.],</span>
<span class="sd">            [12., 13.]]),</span>
<span class="sd">     array([[ 2.,  3.],</span>
<span class="sd">            [ 6.,  7.],</span>
<span class="sd">            [10., 11.],</span>
<span class="sd">            [14., 15.]])]</span>
<span class="sd">    &gt;&gt;&gt; np.hsplit(x, np.array([3, 6]))</span>
<span class="sd">    [array([[ 0.,  1.,  2.],</span>
<span class="sd">            [ 4.,  5.,  6.],</span>
<span class="sd">            [ 8.,  9., 10.],</span>
<span class="sd">            [12., 13., 14.]]),</span>
<span class="sd">     array([[ 3.],</span>
<span class="sd">            [ 7.],</span>
<span class="sd">            [11.],</span>
<span class="sd">            [15.]]),</span>
<span class="sd">     array([])]</span>

<span class="sd">    With a higher dimensional array the split is still along the second axis.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[0., 1.],</span>
<span class="sd">            [2., 3.]],</span>
<span class="sd">           [[4., 5.],</span>
<span class="sd">            [6., 7.]]])</span>
<span class="sd">    &gt;&gt;&gt; np.hsplit(x, 2)</span>
<span class="sd">    [array([[[0., 1.]],</span>
<span class="sd">            [[4., 5.]]]),</span>
<span class="sd">     array([[[2., 3.]],</span>
<span class="sd">            [[6., 7.]]])]</span>

<span class="sd">    With a 1-D array, the split is along axis 0.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.hsplit(x, 2)</span>
<span class="sd">    [array([0, 1, 2]), array([3, 4, 5])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;hsplit only works on arrays of 1 or more dimensions&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="hstack">
<a class="viewcode-back" href="../../reference/generated/dpnp.hstack.html#dpnp.hstack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hstack</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack arrays in sequence horizontally (column wise).</span>

<span class="sd">    For full documentation refer to :obj:`numpy.hstack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tup : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The arrays must have the same shape along all but the second axis,</span>
<span class="sd">        except 1-D arrays which can be any length.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        If provided, the destination array will have this dtype.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span>

<span class="sd">        Default: ``&quot;same_kind&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The stacked array which has one more dimension than the input arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise</span>
<span class="sd">                         (along third dimension).</span>
<span class="sd">    :obj:`dpnp.column_stack` : Stack 1-D arrays as columns into a 2-D array.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble an ndarray from nested lists of blocks.</span>
<span class="sd">    :obj:`dpnp.split` : Split array into a list of multiple sub-arrays of equal</span>
<span class="sd">                        size.</span>
<span class="sd">    :obj:`dpnp.unstack` : Split an array into a tuple of sub-arrays along</span>
<span class="sd">                          an axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; b = np.array((4, 5, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.hstack((a, b))</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1], [2], [3]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[4], [5], [6]])</span>
<span class="sd">    &gt;&gt;&gt; np.hstack((a, b))</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [2, 5],</span>
<span class="sd">           [3, 6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_check_stack_arrays</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>

    <span class="n">arrs</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrs</span><span class="p">]</span>

    <span class="c1"># As a special case, dimension 0 of 1-dimensional arrays is &quot;horizontal&quot;</span>
    <span class="k">if</span> <span class="n">arrs</span> <span class="ow">and</span> <span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span></div>



<div class="viewcode-block" id="insert">
<a class="viewcode-back" href="../../reference/generated/dpnp.insert.html#dpnp.insert">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert values along the given axis before the given indices.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.insert`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    obj : {slice, int, array-like of ints or bools}</span>
<span class="sd">        Object that defines the index or indices before which `values` is</span>
<span class="sd">        inserted. It supports multiple insertions when `obj` is a single</span>
<span class="sd">        scalar or a sequence with one element (similar to calling insert</span>
<span class="sd">        multiple times).</span>
<span class="sd">        Boolean indices are treated as a mask of elements to insert.</span>
<span class="sd">    values : array_like</span>
<span class="sd">        Values to insert into `arr`. If the type of `values` is different</span>
<span class="sd">        from that of `arr`, `values` is converted to the type of `arr`.</span>
<span class="sd">        `values` should be shaped so that ``arr[..., obj, ...] = values``</span>
<span class="sd">        is legal.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        Axis along which to insert `values`. If `axis` is ``None`` then `arr`</span>
<span class="sd">        is flattened first.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A copy of `arr` with `values` inserted. Note that :obj:`dpnp.insert`</span>
<span class="sd">        does not occur in-place: a new array is returned. If</span>
<span class="sd">        `axis` is ``None``, `out` is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.append` : Append elements at the end of an array.</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.delete` : Delete elements from an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Note that for higher dimensional inserts ``obj=0`` behaves very different</span>
<span class="sd">    from ``obj=[0]`` just like ``arr[:, 0, :] = values`` is different from</span>
<span class="sd">    ``arr[:, [0], :] = values``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 1],</span>
<span class="sd">           [2, 2],</span>
<span class="sd">           [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5)</span>
<span class="sd">    array([1, 5, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(a, 1, 5, axis=1)</span>
<span class="sd">    array([[1, 5, 1],</span>
<span class="sd">           [2, 5, 2],</span>
<span class="sd">           [3, 5, 3]])</span>

<span class="sd">    Difference between sequence and scalars:</span>

<span class="sd">    &gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)</span>
<span class="sd">    array([[1, 1, 1],</span>
<span class="sd">           [2, 2, 2],</span>
<span class="sd">           [3, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),</span>
<span class="sd">    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))</span>
<span class="sd">    array(True)</span>

<span class="sd">    &gt;&gt;&gt; b = a.flatten()</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])</span>
<span class="sd">    array([1, 1, 5, 6, 2, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])</span>
<span class="sd">    array([1, 1, 5, 2, 6, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # dtype casting</span>
<span class="sd">    array([1, 1, 7, 0, 2, 2, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8).reshape(2, 4)</span>
<span class="sd">    &gt;&gt;&gt; idx = (1, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.insert(x, idx, 999, axis=1)</span>
<span class="sd">    array([[  0, 999,   1,   2, 999,   3],</span>
<span class="sd">           [  4, 999,   5,   6, 999,   7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">_calc_parameters</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
        <span class="c1"># turn it into a range object</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">n</span><span class="p">),</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">exec_q</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># need to copy obj, because indices will be changed in-place</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">obj</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">exec_q</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">params</span><span class="o">.</span><span class="n">usm_type</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;boolean array argument obj to insert &quot;</span>
                    <span class="s2">&quot;must be one dimensional&quot;</span>
                <span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;index array argument `obj` to insert must be one-dimensional &quot;</span>
                <span class="s2">&quot;or scalar&quot;</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_insert_singleton_index</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_insert_array_indices</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_transpose">
<a class="viewcode-back" href="../../reference/generated/dpnp.matrix_transpose.html#dpnp.matrix_transpose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) `x`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.matrix_transpose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array with ``x.ndim &gt;= 2`` and whose two innermost</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array containing the transpose for each matrix and having shape</span>
<span class="sd">        (..., N, M).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.transpose` : Returns an array with axes transposed.</span>
<span class="sd">    :obj:`dpnp.linalg.matrix_transpose` : Equivalent function.</span>
<span class="sd">    :obj:`dpnp.ndarray.mT` : Equivalent method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.matrix_transpose(a)</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [2, 4]])</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])</span>
<span class="sd">    &gt;&gt;&gt; np.matrix_transpose(b)</span>
<span class="sd">    array([[[1, 3],</span>
<span class="sd">            [2, 4]],</span>
<span class="sd">           [[5, 7],</span>
<span class="sd">            [6, 8]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_x</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">usm_x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Input array must be at least 2-dimensional, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but it is </span><span class="si">{</span><span class="n">usm_x</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="n">usm_x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="moveaxis">
<a class="viewcode-back" href="../../reference/generated/dpnp.moveaxis.html#dpnp.moveaxis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move axes of an array to new positions. Other axes remain in their original</span>
<span class="sd">    order.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.moveaxis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array whose axes should be reordered.</span>
<span class="sd">    source : int or sequence of int</span>
<span class="sd">        Original positions of the axes to move. These must be unique.</span>
<span class="sd">    destination : int or sequence of int</span>
<span class="sd">        Destination positions for each of the original axes. These must also be</span>
<span class="sd">        unique.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Array with moved axes. This array is a view of the input array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.transpose` : Permute the dimensions of an array.</span>
<span class="sd">    :obj:`dpnp.swapaxes` : Interchange two axes of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.zeros((3, 4, 5))</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, 0, -1).shape</span>
<span class="sd">    (4, 5, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.moveaxis(x, -1, 0).shape</span>
<span class="sd">    (5, 3, 4)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_array</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span>
        <span class="n">dpt</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">usm_array</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="ndim">
<a class="viewcode-back" href="../../reference/generated/dpnp.ndim.html#dpnp.ndim">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of dimensions of array-like input.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.ndim`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    number_of_dimensions : int</span>
<span class="sd">        The number of dimensions in `a`. Scalars are zero-dimensional.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.ndim` : Equivalent method for `dpnp.ndarray`</span>
<span class="sd">                        or `usm_ndarray` input.</span>
<span class="sd">    :obj:`dpnp.shape` : Return the shape of an array.</span>
<span class="sd">    :obj:`dpnp.ndarray.shape` : Return the shape of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(a)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; a = np.asarray(a)</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(a)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.ndim(1)</span>
<span class="sd">    0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="pad">
<a class="viewcode-back" href="../../reference/generated/dpnp.pad.html#dpnp.pad">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.pad`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array of rank ``N`` to pad.</span>
<span class="sd">    pad_width : {sequence, array_like, int, dict}</span>
<span class="sd">        Number of values padded to the edges of each axis.</span>
<span class="sd">        ``((before_1, after_1), ... (before_N, after_N))`` unique pad widths</span>
<span class="sd">        for each axis.</span>
<span class="sd">        ``(before, after)`` or ``((before, after),)`` yields same before</span>
<span class="sd">        and after pad for each axis.</span>
<span class="sd">        ``(pad,)`` or ``int`` is a shortcut for ``before = after = pad`` width</span>
<span class="sd">        for all axes.</span>
<span class="sd">        If a dictionary, each key is an axis and its corresponding value is an</span>
<span class="sd">        integer or a pair of integers describing the padding ``(before, after)``</span>
<span class="sd">        or ``pad`` width for that axis.</span>
<span class="sd">    mode : {str, function}, optional</span>
<span class="sd">        One of the following string values or a user supplied function.</span>

<span class="sd">        &quot;constant&quot;</span>
<span class="sd">            Pads with a constant value.</span>
<span class="sd">        &quot;edge&quot;</span>
<span class="sd">            Pads with the edge values of array.</span>
<span class="sd">        &quot;linear_ramp&quot;</span>
<span class="sd">            Pads with the linear ramp between `end_value` and the</span>
<span class="sd">            array edge value.</span>
<span class="sd">        &quot;maximum&quot;</span>
<span class="sd">            Pads with the maximum value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &quot;mean&quot;</span>
<span class="sd">            Pads with the mean value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &quot;median&quot;</span>
<span class="sd">            Pads with the median value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &quot;minimum&quot;</span>
<span class="sd">            Pads with the minimum value of all or part of the</span>
<span class="sd">            vector along each axis.</span>
<span class="sd">        &quot;reflect&quot;</span>
<span class="sd">            Pads with the reflection of the vector mirrored on</span>
<span class="sd">            the first and last values of the vector along each</span>
<span class="sd">            axis.</span>
<span class="sd">        &quot;symmetric&quot;</span>
<span class="sd">            Pads with the reflection of the vector mirrored</span>
<span class="sd">            along the edge of the array.</span>
<span class="sd">        &quot;wrap&quot;</span>
<span class="sd">            Pads with the wrap of the vector along the axis.</span>
<span class="sd">            The first values are used to pad the end and the</span>
<span class="sd">            end values are used to pad the beginning.</span>
<span class="sd">        &quot;empty&quot;</span>
<span class="sd">            Pads with undefined values.</span>
<span class="sd">        &lt;function&gt;</span>
<span class="sd">            Padding function, see Notes.</span>

<span class="sd">        Default: ``&quot;constant&quot;``.</span>
<span class="sd">    stat_length : {None, int, sequence of ints}, optional</span>
<span class="sd">        Used in ``&quot;maximum&quot;``, ``&quot;mean&quot;``, ``&quot;median&quot;``, and ``&quot;minimum&quot;``.</span>
<span class="sd">        Number of values at edge of each axis used to calculate the statistic</span>
<span class="sd">        value. ``((before_1, after_1), ... (before_N, after_N))`` unique</span>
<span class="sd">        statistic lengths for each axis.</span>
<span class="sd">        ``(before, after)`` or ``((before, after),)`` yields same before</span>
<span class="sd">        and after statistic lengths for each axis.</span>
<span class="sd">        ``(stat_length,)`` or ``int`` is a shortcut for</span>
<span class="sd">        ``before = after = statistic`` length for all axes.</span>

<span class="sd">        Default: ``None``, to use the entire axis.</span>
<span class="sd">    constant_values : {sequence, scalar}, optional</span>
<span class="sd">        Used in ``&quot;constant&quot;``. The values to set the padded values for each</span>
<span class="sd">        axis.</span>
<span class="sd">        ``((before_1, after_1), ... (before_N, after_N))`` unique pad constants</span>
<span class="sd">        for each axis.</span>
<span class="sd">        ``(before, after)`` or ``((before, after),)`` yields same before</span>
<span class="sd">        and after constants for each axis.</span>
<span class="sd">        ``(constant,)`` or ``constant`` is a shortcut for</span>
<span class="sd">        ``before = after = constant`` for all axes.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    end_values : {sequence, scalar}, optional</span>
<span class="sd">        Used in ``&quot;linear_ramp&quot;``. The values used for the ending value of the</span>
<span class="sd">        linear_ramp and that will form the edge of the padded array.</span>
<span class="sd">        ``((before_1, after_1), ... (before_N, after_N))`` unique end values</span>
<span class="sd">        for each axis.</span>
<span class="sd">        ``(before, after)`` or ``((before, after),)`` yields same before</span>
<span class="sd">        and after end values for each axis.</span>
<span class="sd">        ``(constant,)`` or ``constant`` is a shortcut for</span>
<span class="sd">        ``before = after = constant`` for all axes.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    reflect_type : {&quot;even&quot;, &quot;odd&quot;}, optional</span>
<span class="sd">        Used in ``&quot;reflect&quot;``, and ``&quot;symmetric&quot;``. The ``&quot;even&quot;`` style is the</span>
<span class="sd">        default with an unaltered reflection around the edge value. For</span>
<span class="sd">        the ``&quot;odd&quot;`` style, the extended part of the array is created by</span>
<span class="sd">        subtracting the reflected values from two times the edge value.</span>

<span class="sd">        Default: ``&quot;even&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padded array : dpnp.ndarray</span>
<span class="sd">        Padded array of rank equal to `array` with shape increased</span>
<span class="sd">        according to `pad_width`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For an array with rank greater than 1, some of the padding of later</span>
<span class="sd">    axes is calculated from padding of previous axes. This is easiest to</span>
<span class="sd">    think about with a rank 2 array where the corners of the padded array</span>
<span class="sd">    are calculated by using padded values from the first axis.</span>

<span class="sd">    The padding function, if used, should modify a rank 1 array in-place. It</span>
<span class="sd">    has the following signature::</span>

<span class="sd">        padding_func(vector, iaxis_pad_width, iaxis, kwargs)</span>

<span class="sd">    where</span>

<span class="sd">    vector : dpnp.ndarray</span>
<span class="sd">        A rank 1 array already padded with zeros. Padded values are</span>
<span class="sd">        vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</span>
<span class="sd">    iaxis_pad_width : tuple</span>
<span class="sd">        A 2-tuple of ints, iaxis_pad_width[0] represents the number of</span>
<span class="sd">        values padded at the beginning of vector where</span>
<span class="sd">        iaxis_pad_width[1] represents the number of values padded at</span>
<span class="sd">        the end of vector.</span>
<span class="sd">    iaxis : int</span>
<span class="sd">        The axis currently being calculated.</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Any keyword arguments the function requires.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;constant&#39;, constant_values=(4, 6))</span>
<span class="sd">    array([4, 4, 1, 2, 3, 4, 5, 6, 6, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;edge&#39;)</span>
<span class="sd">    array([1, 1, 1, 2, 3, 4, 5, 5, 5, 5])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;linear_ramp&#39;, end_values=(5, -4))</span>
<span class="sd">    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2,), &#39;maximum&#39;)</span>
<span class="sd">    array([5, 5, 1, 2, 3, 4, 5, 5, 5])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2,), &#39;mean&#39;)</span>
<span class="sd">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2,), &#39;median&#39;)</span>
<span class="sd">    array([3, 3, 1, 2, 3, 4, 5, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), &#39;minimum&#39;)</span>
<span class="sd">    array([[1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [3, 3, 3, 4, 3, 3, 3],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1],</span>
<span class="sd">           [1, 1, 1, 2, 1, 1, 1]])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;reflect&#39;)</span>
<span class="sd">    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;reflect&#39;, reflect_type=&#39;odd&#39;)</span>
<span class="sd">    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;symmetric&#39;)</span>
<span class="sd">    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;symmetric&#39;, reflect_type=&#39;odd&#39;)</span>
<span class="sd">    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</span>

<span class="sd">    &gt;&gt;&gt; np.pad(a, (2, 3), &#39;wrap&#39;)</span>
<span class="sd">    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</span>

<span class="sd">    &gt;&gt;&gt; def pad_width(vector, pad_width, iaxis, kwargs):</span>
<span class="sd">    ...     pad_value = kwargs.get(&#39;padder&#39;, 10)</span>
<span class="sd">    ...     vector[:pad_width[0]] = pad_value</span>
<span class="sd">    ...     vector[-pad_width[1]:] = pad_value</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; a = a.reshape((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, 2, pad_width)</span>
<span class="sd">    array([[10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10,  0,  1,  2, 10, 10],</span>
<span class="sd">           [10, 10,  3,  4,  5, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10],</span>
<span class="sd">           [10, 10, 10, 10, 10, 10, 10]])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, 2, pad_width, padder=100)</span>
<span class="sd">    array([[100, 100, 100, 100, 100, 100, 100],</span>
<span class="sd">           [100, 100, 100, 100, 100, 100, 100],</span>
<span class="sd">           [100, 100,   0,   1,   2, 100, 100],</span>
<span class="sd">           [100, 100,   3,   4,   5, 100, 100],</span>
<span class="sd">           [100, 100, 100, 100, 100, 100, 100],</span>
<span class="sd">           [100, 100, 100, 100, 100, 100, 100]])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(1, 7).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, {1: (1, 2)})</span>
<span class="sd">    array([[0, 1, 2, 3, 0, 0],</span>
<span class="sd">           [0, 4, 5, 6, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, {-1: 2})</span>
<span class="sd">    array([[0, 0, 1, 2, 3, 0, 0],</span>
<span class="sd">           [0, 0, 4, 5, 6, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, {0: (3, 0)})</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.pad(a, {0: (3, 0), 1: 2})</span>
<span class="sd">    array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 0, 0, 0, 0, 0],</span>
<span class="sd">           [0, 0, 1, 2, 3, 0, 0],</span>
<span class="sd">           [0, 0, 4, 5, 6, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>



<div class="viewcode-block" id="ravel">
<a class="viewcode-back" href="../../reference/generated/dpnp.ravel.html#dpnp.ravel">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a contiguous flattened array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.ravel`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. The elements in `a` are read in the order specified by</span>
<span class="sd">        order, and packed as a 1-D array.</span>
<span class="sd">    order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;}, optional</span>
<span class="sd">        The elements of `a` are read using this index order. ``&quot;C&quot;`` means to</span>
<span class="sd">        index the elements in row-major, C-style order, with the last axis</span>
<span class="sd">        index changing fastest, back to the first axis index changing slowest.</span>
<span class="sd">        ``&quot;F&quot;`` means to index the elements in column-major, Fortran-style</span>
<span class="sd">        order, with the first index changing fastest, and the last index</span>
<span class="sd">        changing slowest. Note that the &quot;C&quot; and &quot;F&quot; options take no account of</span>
<span class="sd">        the memory layout of the underlying array, and only refer to</span>
<span class="sd">        the order of axis indexing. &quot;A&quot; means to read the elements in</span>
<span class="sd">        Fortran-like index order if `a` is Fortran *contiguous* in</span>
<span class="sd">        memory, C-like order otherwise. ``order=None`` is an alias for</span>
<span class="sd">        ``order=&quot;C&quot;``.</span>

<span class="sd">        Default: ``&quot;C&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A contiguous 1-D array of the same subtype as `a`, with shape (a.size,).</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    `order=&quot;K&quot;` is not supported and the function raises `NotImplementedError`</span>
<span class="sd">    exception.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.flat` : 1-D iterator over an array.</span>
<span class="sd">    :obj:`dpnp.ndarray.flatten` : 1-D array copy of the elements of an array</span>
<span class="sd">                    in row-major order.</span>
<span class="sd">    :obj:`dpnp.ndarray.reshape` : Change the shape of an array without</span>
<span class="sd">                    changing its data.</span>
<span class="sd">    :obj:`dpnp.reshape` : The same as :obj:`dpnp.ndarray.reshape`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In row-major, C-style order, in two dimensions, the row index</span>
<span class="sd">    varies the slowest, and the column index the quickest. This can</span>
<span class="sd">    be generalized to multiple dimensions, where row-major order</span>
<span class="sd">    implies that the index along the first axis varies slowest, and</span>
<span class="sd">    the index along the last quickest. The opposite holds for</span>
<span class="sd">    column-major, Fortran-style index ordering.</span>

<span class="sd">    When a view is desired in as many cases as possible, ``arr.reshape(-1)``</span>
<span class="sd">    may be preferable.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel(x)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>

<span class="sd">    &gt;&gt;&gt; x.reshape(-1)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.ravel(x, order=&#39;F&#39;)</span>
<span class="sd">    array([1, 4, 2, 5, 3, 6])</span>

<span class="sd">    When `order` is ``&quot;A&quot;``, it will preserve the array&#39;s</span>
<span class="sd">    ``&quot;C&quot;`` or ``&quot;F&quot;`` ordering:</span>

<span class="sd">    &gt;&gt;&gt; np.ravel(x.T)</span>
<span class="sd">    array([1, 4, 2, 5, 3, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel(x.T, order=&#39;A&#39;)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="s2">&quot;kK&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Keyword argument `order` is supported only with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;values None, &#39;C&#39;, &#39;F&#39;, and &#39;A&#39;, but got &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>



<div class="viewcode-block" id="repeat">
<a class="viewcode-back" href="../../reference/generated/dpnp.repeat.html#dpnp.repeat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repeat elements of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.repeat`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    repeats : {int, tuple, list, range, dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The number of repetitions for each element. `repeats` is broadcasted to</span>
<span class="sd">        fit the shape of the given axis.</span>
<span class="sd">        If `repeats` is an array, it must have an integer data type.</span>
<span class="sd">        Otherwise, `repeats` must be a Python integer or sequence of Python</span>
<span class="sd">        integers (i.e., a tuple, list, or range).</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        The axis along which to repeat values. By default, use the flattened</span>
<span class="sd">        input array, and return a flat output array.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Output array which has the same shape as `a`, except along the given</span>
<span class="sd">        axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.tile` : Tile an array.</span>
<span class="sd">    :obj:`dpnp.unique` : Find the unique elements of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([3])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 4)</span>
<span class="sd">    array([3, 3, 3, 3])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 2)</span>
<span class="sd">    array([1, 1, 2, 2, 3, 3, 4, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, 3, axis=1)</span>
<span class="sd">    array([[1, 1, 1, 2, 2, 2],</span>
<span class="sd">           [3, 3, 3, 4, 4, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">range</span><span class="p">)):</span>
        <span class="n">repeats</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">usm_arr</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">usm_arr</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="require">
<a class="viewcode-back" href="../../reference/generated/dpnp.require.html#dpnp.require">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">require</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">requirements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">like</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a :class:`dpnp.ndarray` of the provided type that satisfies</span>
<span class="sd">    requirements.</span>

<span class="sd">    This function is useful to be sure that an array with the correct flags</span>
<span class="sd">    is returned for passing to compiled code (perhaps through ctypes).</span>

<span class="sd">    For full documentation refer to :obj:`numpy.require`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">       The input array to be converted to a type-and-requirement-satisfying</span>
<span class="sd">       array.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">       The required data-type. If ``None`` preserve the current dtype.</span>

<span class="sd">       Default: ``None``.</span>
<span class="sd">    requirements : {None, str, sequence of str}, optional</span>
<span class="sd">       The requirements list can be any of the following:</span>

<span class="sd">       * &#39;F_CONTIGUOUS&#39; (&#39;F&#39;) - ensure a Fortran-contiguous array</span>
<span class="sd">       * &#39;C_CONTIGUOUS&#39; (&#39;C&#39;) - ensure a C-contiguous array</span>
<span class="sd">       * &#39;WRITABLE&#39; (&#39;W&#39;) - ensure a writable array</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Array with specified requirements and type if given.</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    Parameter `like` is supported only with default value ``None``.</span>
<span class="sd">    Otherwise, the function raises `NotImplementedError` exception.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.asarray` : Convert input to an ndarray.</span>
<span class="sd">    :obj:`dpnp.asanyarray` : Convert to an ndarray, but pass through</span>
<span class="sd">                        ndarray subclasses.</span>
<span class="sd">    :obj:`dpnp.ascontiguousarray` : Convert input to a contiguous array.</span>
<span class="sd">    :obj:`dpnp.asfortranarray` : Convert input to an ndarray with</span>
<span class="sd">                        column-major memory order.</span>
<span class="sd">    :obj:`dpnp.ndarray.flags` : Information about the memory layout</span>
<span class="sd">                        of the array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The returned array will be guaranteed to have the listed requirements</span>
<span class="sd">    by making a copy if needed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; x.flags</span>
<span class="sd">      C_CONTIGUOUS : True</span>
<span class="sd">      F_CONTIGUOUS : False</span>
<span class="sd">      WRITEABLE : True</span>

<span class="sd">    &gt;&gt;&gt; y = np.require(x, dtype=np.float32, requirements=[&#39;W&#39;, &#39;F&#39;])</span>
<span class="sd">    &gt;&gt;&gt; y.flags</span>
<span class="sd">      C_CONTIGUOUS : False</span>
<span class="sd">      F_CONTIGUOUS : True</span>
<span class="sd">      WRITEABLE : True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_limitations</span><span class="p">(</span><span class="n">like</span><span class="o">=</span><span class="n">like</span><span class="p">)</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">possible_flags</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
        <span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
        <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span>
        <span class="s2">&quot;F_CONTIGUOUS&quot;</span><span class="p">:</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span>
        <span class="s2">&quot;W&quot;</span><span class="p">:</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span>
        <span class="s2">&quot;WRITEABLE&quot;</span><span class="p">:</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">requirements</span> <span class="o">=</span> <span class="p">{</span><span class="n">possible_flags</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">}</span>
    <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
        <span class="n">incorrect_flag</span> <span class="o">=</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">requirements</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">possible_flags</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Incorrect flag </span><span class="si">{</span><span class="n">incorrect_flag</span><span class="si">}</span><span class="s2"> in requirements&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">exc</span>

    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span>
    <span class="k">if</span> <span class="n">requirements</span><span class="o">.</span><span class="n">issuperset</span><span class="p">({</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">}):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot specify both &#39;C&#39; and &#39;F&#39; order&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;F&quot;</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
        <span class="n">requirements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;C&quot;</span> <span class="ow">in</span> <span class="n">requirements</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
        <span class="n">requirements</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

    <span class="n">arr</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;W&quot;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">arr</span></div>



<div class="viewcode-block" id="reshape">
<a class="viewcode-back" href="../../reference/generated/dpnp.reshape.html#dpnp.reshape">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gives a new shape to an array without changing its data.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.reshape`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be reshaped.</span>
<span class="sd">    shape : {int, tuple of ints}, optional</span>
<span class="sd">        The new shape should be compatible with the original shape. If</span>
<span class="sd">        an integer, then the result will be a 1-D array of that length.</span>
<span class="sd">        One shape dimension can be -1. In this case, the value is</span>
<span class="sd">        inferred from the length of the array and remaining dimensions.</span>
<span class="sd">    order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;}, optional</span>
<span class="sd">        Read the elements of `a` using this index order, and place the</span>
<span class="sd">        elements into the reshaped array using this index order. ``&quot;C&quot;``</span>
<span class="sd">        means to read / write the elements using C-like index order,</span>
<span class="sd">        with the last axis index changing fastest, back to the first</span>
<span class="sd">        axis index changing slowest. ``&quot;F&quot;`` means to read / write the</span>
<span class="sd">        elements using Fortran-like index order, with the first index</span>
<span class="sd">        changing fastest, and the last index changing slowest. Note that</span>
<span class="sd">        the ``&quot;C&quot;`` and ``&quot;F&quot;`` options take no account of the memory layout of</span>
<span class="sd">        the underlying array, and only refer to the order of indexing.</span>
<span class="sd">        ``order=None`` is an alias for ``order=&quot;C&quot;``. ``&quot;A&quot;`` means to</span>
<span class="sd">        read / write the elements in Fortran-like index order if ``a`` is</span>
<span class="sd">        Fortran *contiguous* in memory, C-like order otherwise.</span>

<span class="sd">        Default: ``&quot;C&quot;``.</span>
<span class="sd">    copy : {None, bool}, optional</span>
<span class="sd">        If ``True``, then the array data is copied. If ``None``, a copy will</span>
<span class="sd">        only be made if it&#39;s required by ``order``. For ``False`` it raises</span>
<span class="sd">        a ``ValueError`` if a copy cannot be avoided.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        This will be a new view object if possible; otherwise, it will</span>
<span class="sd">        be a copy. Note there is no guarantee of the *memory layout* (C- or</span>
<span class="sd">        Fortran- contiguous) of the returned array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.reshape` : Equivalent method.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It is not always possible to change the shape of an array without copying</span>
<span class="sd">    the data.</span>

<span class="sd">    The `order` keyword gives the index ordering both for *fetching*</span>
<span class="sd">    the values from ``a``, and then *placing* the values into the output</span>
<span class="sd">    array. For example, let&#39;s say you have an array:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape((3, 2))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    You can think of reshaping as first raveling the array (using the given</span>
<span class="sd">    index order), then inserting the elements from the raveled array into the</span>
<span class="sd">    new array using the same kind of index ordering as was used for the</span>
<span class="sd">    raveling.</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, (2, 3), order=&#39;F&#39;) # Fortran-like index ordering</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(np.ravel(a, order=&#39;F&#39;), (2, 3), order=&#39;F&#39;)</span>
<span class="sd">    array([[0, 4, 3],</span>
<span class="sd">           [2, 1, 5]])</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6)</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.reshape(a, 6, order=&#39;F&#39;)</span>
<span class="sd">    array([1, 4, 2, 5, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.reshape(a, (3, -1))       # the unspecified value is inferred to be 2</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="ow">in</span> <span class="s2">&quot;aA&quot;</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span> <span class="k">else</span> <span class="s2">&quot;C&quot;</span>
    <span class="k">elif</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;cfCF&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;order must be None, &#39;C&#39;, &#39;F&#39;, or &#39;A&#39; (got &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
        <span class="p">)</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="resize">
<a class="viewcode-back" href="../../reference/generated/dpnp.resize.html#dpnp.resize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">resize</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new array with the specified shape.</span>

<span class="sd">    If the new array is larger than the original array, then the new array is</span>
<span class="sd">    filled with repeated copies of `a`. Note that this behavior is different</span>
<span class="sd">    from ``a.resize(new_shape)`` which fills with zeros instead of repeated</span>
<span class="sd">    copies of `a`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.resize`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be resized.</span>
<span class="sd">    new_shape : {int, tuple or list of ints}</span>
<span class="sd">        Shape of resized array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The new array is formed from the data in the old array, repeated if</span>
<span class="sd">        necessary to fill out the required number of elements. The data are</span>
<span class="sd">        repeated iterating over the array in C-order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.resize` : Resize an array in-place.</span>
<span class="sd">    :obj:`dpnp.reshape` : Reshape an array without changing the total size.</span>
<span class="sd">    :obj:`dpnp.pad` : Enlarge and pad an array.</span>
<span class="sd">    :obj:`dpnp.repeat` : Repeat elements of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When the total size of the array does not change :obj:`dpnp.reshape` should</span>
<span class="sd">    be used. In most other cases either indexing (to reduce the size) or</span>
<span class="sd">    padding (to increase the size) may be a more appropriate solution.</span>

<span class="sd">    Warning</span>
<span class="sd">    -------</span>
<span class="sd">    This functionality does **not** consider axes separately, i.e. it does not</span>
<span class="sd">    apply interpolation/extrapolation.</span>
<span class="sd">    It fills the return array with the required number of elements, iterating</span>
<span class="sd">    over `a` in C-order, disregarding axes (and cycling back from the start if</span>
<span class="sd">    the new shape is larger). This functionality is therefore not suitable to</span>
<span class="sd">    resize images, or data where each axis represents a separate and distinct</span>
<span class="sd">    entity.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[0, 1], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a, (2, 3))</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a, (1, 4))</span>
<span class="sd">    array([[0, 1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a, (2, 4))</span>
<span class="sd">    array([[0, 1, 2, 3],</span>
<span class="sd">           [0, 1, 2, 3]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_shape</span><span class="p">,)</span>

    <span class="n">new_size</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">dim_length</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dim_length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all elements of `new_shape` must be non-negative&quot;</span><span class="p">)</span>
        <span class="n">new_size</span> <span class="o">*=</span> <span class="n">dim_length</span>

    <span class="n">a_size</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">a_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># First case must zero fill. The second would have repeats == 0.</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>

    <span class="c1"># ceiling division without negating new_size</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">+</span> <span class="n">a_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">a_size</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),)</span> <span class="o">*</span> <span class="n">repeats</span><span class="p">)[:</span><span class="n">new_size</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="result_type">
<a class="viewcode-back" href="../../reference/generated/dpnp.result_type.html#dpnp.result_type">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">arrays_and_dtypes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    result_type(*arrays_and_dtypes)</span>

<span class="sd">    Returns the type that results from applying the NumPy</span>
<span class="sd">    type promotion rules to the arguments.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.result_type`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays_and_dtypes : list of {dpnp.ndarray, usm_ndarray, dtype}</span>
<span class="sd">        An arbitrary length sequence of arrays or dtypes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dtype</span>
<span class="sd">        The result type.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(3, dtype=np.int64)</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(7, dtype=np.int32)</span>
<span class="sd">    &gt;&gt;&gt; np.result_type(a, b)</span>
<span class="sd">    dtype(&#39;int64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; np.result_type(np.int64, np.complex128)</span>
<span class="sd">    dtype(&#39;complex128&#39;)</span>

<span class="sd">    &gt;&gt;&gt; np.result_type(np.ones(10, dtype=np.float32), np.float64)</span>
<span class="sd">    dtype(&#39;float64&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_arrays_and_dtypes</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">dpnp_array</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">))</span>
            <span class="k">else</span> <span class="n">X</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">X</span> <span class="ow">in</span> <span class="n">arrays_and_dtypes</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">usm_arrays_and_dtypes</span><span class="p">)</span></div>



<div class="viewcode-block" id="roll">
<a class="viewcode-back" href="../../reference/generated/dpnp.roll.html#dpnp.roll">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll the elements of an array by a number of positions along a given axis.</span>

<span class="sd">    Array elements that roll beyond the last position are re-introduced</span>
<span class="sd">    at the first position. Array elements that roll beyond the first position</span>
<span class="sd">    are re-introduced at the last position.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.roll`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    shift : {int, tuple of ints}</span>
<span class="sd">        The number of places by which elements are shifted. If a tuple, then</span>
<span class="sd">        `axis` must be a tuple of the same size, and each of the given axes</span>
<span class="sd">        is shifted by the corresponding number. If an integer while `axis` is</span>
<span class="sd">        a tuple of integers, then the same value is used for all given axes.</span>
<span class="sd">    axis : {None, int, tuple of ints}, optional</span>
<span class="sd">        Axis or axes along which elements are shifted. By default, the</span>
<span class="sd">        array is flattened before shifting, after which the original</span>
<span class="sd">        shape is restored.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array with the same data type as `x`</span>
<span class="sd">        and whose elements, relative to `x`, are shifted.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.moveaxis` : Move array axes to new positions.</span>
<span class="sd">    :obj:`dpnp.rollaxis` : Roll the specified axis backwards</span>
<span class="sd">                       until it lies in a given position.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x1, 2)</span>
<span class="sd">    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])</span>

<span class="sd">    &gt;&gt;&gt; np.roll(x1, -2)</span>
<span class="sd">    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])</span>

<span class="sd">    &gt;&gt;&gt; x2 = np.reshape(x1, (2, 5))</span>
<span class="sd">    &gt;&gt;&gt; np.roll(x2, 1, axis=0)</span>
<span class="sd">    array([[5, 6, 7, 8, 9],</span>
<span class="sd">           [0, 1, 2, 3, 4]])</span>

<span class="sd">    &gt;&gt;&gt; np.roll(x2, (2, 1), axis=(1, 0))</span>
<span class="sd">    array([[8, 9, 5, 6, 7],</span>
<span class="sd">           [3, 4, 0, 1, 2]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_x</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">shift</span><span class="p">):</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">shift</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">usm_x</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="rollaxis">
<a class="viewcode-back" href="../../reference/generated/dpnp.rollaxis.html#dpnp.rollaxis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rollaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Roll the specified axis backwards, until it lies in a given position.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.rollaxis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis to be rolled. The positions of the other axes do not</span>
<span class="sd">        change relative to one another.</span>
<span class="sd">    start : int, optional</span>
<span class="sd">        When ``start &lt;= axis``, the axis is rolled back until it lies in</span>
<span class="sd">        this position. When ``start &gt; axis``, the axis is rolled until it</span>
<span class="sd">        lies before this position. The default, ``0``, results in a &quot;complete&quot;</span>
<span class="sd">        roll.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array with the same data type as `x` where the specified axis</span>
<span class="sd">        has been moved to the requested position.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.moveaxis` : Move array axes to new positions.</span>
<span class="sd">    :obj:`dpnp.roll` : Roll the elements of an array</span>
<span class="sd">                       by a number of positions along a given axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.ones((3, 4, 5, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 3, 1).shape</span>
<span class="sd">    (3, 6, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 2).shape</span>
<span class="sd">    (5, 3, 4, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.rollaxis(a, 1, 4).shape</span>
<span class="sd">    (3, 5, 6, 4)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; arg requires </span><span class="si">%d</span><span class="s2"> &lt;= </span><span class="si">%s</span><span class="s2"> &lt; </span><span class="si">%d</span><span class="s2">, but </span><span class="si">%d</span><span class="s2"> was passed in&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">usm_array</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">usm_array</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">start</span><span class="p">)</span></div>



<div class="viewcode-block" id="rot90">
<a class="viewcode-back" href="../../reference/generated/dpnp.rot90.html#dpnp.rot90">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotate an array by 90 degrees in the plane specified by axes.</span>

<span class="sd">    Rotation direction is from the first towards the second axis.</span>
<span class="sd">    This means for a 2D array with the default `k` and `axes`, the</span>
<span class="sd">    rotation will be counterclockwise.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.rot90`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array of two or more dimensions.</span>
<span class="sd">    k : integer, optional</span>
<span class="sd">        Number of times the array is rotated by 90 degrees.</span>

<span class="sd">        Default: ``1``.</span>
<span class="sd">    axes : (2,) array_like of ints, optional</span>
<span class="sd">        The array is rotated in the plane defined by the axes.</span>
<span class="sd">        Axes must be different.</span>

<span class="sd">        Default: ``(0, 1)``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A rotated view of `m`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.flip` : Reverse the order of elements in an array along</span>
<span class="sd">                    the given axis.</span>
<span class="sd">    :obj:`dpnp.fliplr` : Flip an array horizontally.</span>
<span class="sd">    :obj:`dpnp.flipud` : Flip an array vertically.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    ``rot90(m, k=1, axes=(1, 0))`` is the reverse of</span>
<span class="sd">    ``rot90(m, k=1, axes=(0, 1))``.</span>

<span class="sd">    ``rot90(m, k=1, axes=(1, 0))`` is equivalent to</span>
<span class="sd">    ``rot90(m, k=-1, axes=(0, 1))``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m)</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 2)</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.arange(8).reshape((2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; np.rot90(m, 1, (1, 2))</span>
<span class="sd">    array([[[1, 3],</span>
<span class="sd">            [0, 2]],</span>
<span class="sd">           [[5, 7],</span>
<span class="sd">            [4, 6]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="n">m_ndim</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">m_ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input must be at least 2-d.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(axes) must be 2.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">m_ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="n">m_ndim</span> <span class="o">&lt;=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">m_ndim</span> <span class="ow">and</span> <span class="o">-</span><span class="n">m_ndim</span> <span class="o">&lt;=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">m_ndim</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Axes=</span><span class="si">{</span><span class="n">axes</span><span class="si">}</span><span class="s2"> out of range for array of ndim=</span><span class="si">{</span><span class="n">m_ndim</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">k</span> <span class="o">%=</span> <span class="mi">4</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="p">[:]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">axes_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m_ndim</span><span class="p">))</span>
    <span class="p">(</span><span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
        <span class="n">axes_list</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">axes_list</span><span class="p">)</span>

    <span class="c1"># k == 3</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axes_list</span><span class="p">),</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="shape">
<a class="viewcode-back" href="../../reference/generated/dpnp.shape.html#dpnp.shape">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the shape of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.shape`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    shape : {int, tuple of ints}</span>
<span class="sd">        The elements of the shape tuple give the lengths of the</span>
<span class="sd">        corresponding array dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    len : ``len(a)`` is equivalent to ``np.shape(a)[0]`` for N-D arrays with</span>
<span class="sd">          ``N&gt;=1``.</span>
<span class="sd">    :obj:`dpnp.ndarray.shape` : Equivalent array method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.shape(np.eye(3))</span>
<span class="sd">    (3, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([[1, 3]])</span>
<span class="sd">    (1, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.shape([0])</span>
<span class="sd">    (1,)</span>
<span class="sd">    &gt;&gt;&gt; np.shape(0)</span>
<span class="sd">    ()</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="size">
<a class="viewcode-back" href="../../reference/generated/dpnp.size.html#dpnp.size">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of elements along a given axis.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.size`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : {None, int, tuple of ints}, optional</span>
<span class="sd">        Axis or axes along which the elements are counted.</span>
<span class="sd">        By default, give the total number of elements.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    element_count : int</span>
<span class="sd">        Number of elements along the specified axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.size` : number of elements in array.</span>
<span class="sd">    :obj:`dpnp.shape` : Return the shape of an array.</span>
<span class="sd">    :obj:`dpnp.ndarray.shape` : Return the shape of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = [[1, 2, 3], [4, 5, 6]]</span>
<span class="sd">    &gt;&gt;&gt; np.size(a)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; np.size(a, axis=1)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; np.size(a, axis=0)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.size(a, axis=(0, 1))</span>
<span class="sd">    6</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
        <span class="n">_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">_axis</span> <span class="o">=</span> <span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">_shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">_axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="split">
<a class="viewcode-back" href="../../reference/generated/dpnp.split.html#dpnp.split">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split an array into multiple sub-arrays as views into `ary`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.split`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be divided into sub-arrays.</span>
<span class="sd">    indices_or_sections : {int, sequence of ints}</span>
<span class="sd">        If `indices_or_sections` is an integer, N, the array will be divided</span>
<span class="sd">        into N equal arrays along `axis`. If such a split is not possible,</span>
<span class="sd">        an error is raised.</span>

<span class="sd">        If `indices_or_sections` is a sequence of sorted integers, the entries</span>
<span class="sd">        indicate where along `axis` the array is split. For example,</span>
<span class="sd">        ``[2, 3]`` would, for ``axis=0``, result in</span>

<span class="sd">        - ary[:2]</span>
<span class="sd">        - ary[2:3]</span>
<span class="sd">        - ary[3:]</span>

<span class="sd">        If an index exceeds the dimension of the array along `axis`,</span>
<span class="sd">        an empty sub-array is returned correspondingly.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to split.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sub-arrays : list of dpnp.ndarray</span>
<span class="sd">        A list of sub arrays. Each array is a view of the corresponding input</span>
<span class="sd">        array.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `indices_or_sections` is given as an integer, but</span>
<span class="sd">        a split does not result in equal division.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.array_split` : Split an array into multiple sub-arrays of equal</span>
<span class="sd">                        or near-equal size. Does not raise an exception if an</span>
<span class="sd">                        equal division cannot be made.</span>
<span class="sd">    :obj:`dpnp.hsplit` : Split array into multiple sub-arrays horizontally</span>
<span class="sd">                    (column-wise).</span>
<span class="sd">    :obj:`dpnp.vsplit` : Split array into multiple sub-arrays vertically</span>
<span class="sd">                    (row wise).</span>
<span class="sd">    :obj:`dpnp.dsplit` : Split array into multiple sub-arrays along the 3rd</span>
<span class="sd">                    axis (depth).</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise</span>
<span class="sd">                    (along third dimension).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(9.0)</span>
<span class="sd">    &gt;&gt;&gt; np.split(x, 3)</span>
<span class="sd">    [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7., 8.])]</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8.0)</span>
<span class="sd">    &gt;&gt;&gt; np.split(x, [3, 5, 6, 10])</span>
<span class="sd">    [array([0., 1., 2.]), array([3., 4.]), array([5.]), array([6., 7.]), \</span>
<span class="sd">    array([])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;=</span> <span class="n">axis</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Axis exceeds ndim&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">%</span> <span class="n">indices_or_sections</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;indices_or_sections must divide the size along the axes.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;If you want to split the array into non-equally-sized &quot;</span>
                <span class="s2">&quot;arrays, use array_split instead.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="k">return</span> <span class="n">array_split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="squeeze">
<a class="viewcode-back" href="../../reference/generated/dpnp.squeeze.html#dpnp.squeeze">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes singleton dimensions (axes) from array `a`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.squeeze`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : {None, int, tuple of ints}, optional</span>
<span class="sd">        Selects a subset of the entries of length one in the shape.</span>
<span class="sd">        If an axis is selected with shape entry greater than one,</span>
<span class="sd">        an error is raised.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Output array is a view, if possible, and a copy otherwise, but with all</span>
<span class="sd">        or a subset of the dimensions of length 1 removed. Output has the same</span>
<span class="sd">        data type as the input, is allocated on the same device as the input</span>
<span class="sd">        and has the same USM allocation type as the input array `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[[0], [1], [2]]])</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (1, 3, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x).shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=0).shape</span>
<span class="sd">    (3, 1)</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=1).shape</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Cannot select an axis to squeeze out which has size not equal</span>
<span class="sd">    to one.</span>
<span class="sd">    &gt;&gt;&gt; np.squeeze(x, axis=2).shape</span>
<span class="sd">    (1, 3)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="stack">
<a class="viewcode-back" href="../../reference/generated/dpnp.stack.html#dpnp.stack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Join a sequence of arrays along a new axis.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.stack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Each array must have the same shape.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis in the result array along which the input arrays are stacked.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    out : dpnp.ndarray, optional</span>
<span class="sd">        If provided, the destination to place the result. The shape must be</span>
<span class="sd">        correct, matching that of what stack would have returned if no out</span>
<span class="sd">        argument were specified.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        If provided, the destination array will have this dtype. Cannot be</span>
<span class="sd">        provided together with `out`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span>

<span class="sd">        Default: ``&quot;same_kind&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The stacked array which has one more dimension than the input arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.vstack` : Stack arrays in sequence vertically (row wise).</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise</span>
<span class="sd">                         (along third dimension).</span>
<span class="sd">    :obj:`dpnp.column_stack` : Stack 1-D arrays as columns into a 2-D array.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble an ndarray from nested lists of blocks.</span>
<span class="sd">    :obj:`dpnp.split` : Split array into a list of multiple sub-arrays of equal</span>
<span class="sd">                        size.</span>
<span class="sd">    :obj:`dpnp.unstack` : Split an array into a tuple of sub-arrays along</span>
<span class="sd">                          an axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]</span>
<span class="sd">    &gt;&gt;&gt; np.stack(arrays, axis=0).shape</span>
<span class="sd">    (10, 3, 4)</span>

<span class="sd">    &gt;&gt;&gt; np.stack(arrays, axis=1).shape</span>
<span class="sd">    (3, 10, 4)</span>

<span class="sd">    &gt;&gt;&gt; np.stack(arrays, axis=2).shape</span>
<span class="sd">    (3, 4, 10)</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.stack((a, b))</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>

<span class="sd">    &gt;&gt;&gt; np.stack((a, b), axis=-1)</span>
<span class="sd">    array([[1, 4],</span>
<span class="sd">           [2, 5],</span>
<span class="sd">           [3, 6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_check_stack_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;stack() only takes `out` or `dtype` as an argument, &quot;</span>
            <span class="s2">&quot;but both were provided.&quot;</span>
        <span class="p">)</span>

    <span class="n">usm_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">usm_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="swapaxes">
<a class="viewcode-back" href="../../reference/generated/dpnp.swapaxes.html#dpnp.swapaxes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interchange two axes of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.swapaxes`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis1 : int</span>
<span class="sd">        First axis.</span>
<span class="sd">    axis2 : int</span>
<span class="sd">        Second axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array with with swapped axes.</span>
<span class="sd">        A view is returned whenever possible.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `a` has rank (i.e., number of dimensions) `N`,</span>
<span class="sd">    a valid `axis` must be in the half-open interval `[-N, N)`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.swapaxes(x, 0, 1)</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [2],</span>
<span class="sd">           [3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[[0, 1],[2, 3]],[[4, 5],[6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; np.swapaxes(x, 0, 2)</span>
<span class="sd">    array([[[0, 4],</span>
<span class="sd">            [2, 6]],</span>
<span class="sd">           [[1, 5],</span>
<span class="sd">            [3, 7]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<span class="c1"># pylint: disable=invalid-name</span>
<div class="viewcode-block" id="tile">
<a class="viewcode-back" href="../../reference/generated/dpnp.tile.html#dpnp.tile">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tile</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">reps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array by repeating `A` the number of times given by reps.</span>

<span class="sd">    If `reps` has length ``d``, the result will have dimension of</span>
<span class="sd">    ``max(d, A.ndim)``.</span>

<span class="sd">    If ``A.ndim &lt; d``, `A` is promoted to be d-dimensional by prepending new</span>
<span class="sd">    axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,</span>
<span class="sd">    or shape (1, 1, 3) for 3-D replication. If this is not the desired</span>
<span class="sd">    behavior, promote `A` to d-dimensions manually before calling this</span>
<span class="sd">    function.</span>

<span class="sd">    If ``A.ndim &gt; d``, `reps` is promoted to `A`.ndim by prepending 1&#39;s to it.</span>
<span class="sd">    Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as</span>
<span class="sd">    (1, 1, 2, 2).</span>

<span class="sd">    Note : Although tile may be used for broadcasting, it is strongly</span>
<span class="sd">    recommended to use dpnp&#39;s broadcasting operations and functions.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.tile`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The input array.</span>
<span class="sd">    reps : int or tuple of ints</span>
<span class="sd">        The number of repetitions of `A` along each axis.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The tiled output array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.repeat` : Repeat elements of an array.</span>
<span class="sd">    :obj:`dpnp.broadcast_to` : Broadcast an array to a new shape</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([0, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.tile(a, 2)</span>
<span class="sd">    array([0, 1, 2, 0, 1, 2])</span>

<span class="sd">    &gt;&gt;&gt; np.tile(a, (2, 2))</span>
<span class="sd">    array([[0, 1, 2, 0, 1, 2],</span>
<span class="sd">           [0, 1, 2, 0, 1, 2]])</span>

<span class="sd">    &gt;&gt;&gt; np.tile(a, (2, 1, 2))</span>
<span class="sd">    array([[[0, 1, 2, 0, 1, 2]],</span>
<span class="sd">           [[0, 1, 2, 0, 1, 2]]])</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.tile(b, 2)</span>
<span class="sd">    array([[1, 2, 1, 2],</span>
<span class="sd">           [3, 4, 3, 4]])</span>

<span class="sd">    &gt;&gt;&gt; np.tile(b, (2, 1))</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.tile(c, (4, 1))</span>
<span class="sd">    array([[1, 2, 3, 4],</span>
<span class="sd">           [1, 2, 3, 4],</span>
<span class="sd">           [1, 2, 3, 4],</span>
<span class="sd">           [1, 2, 3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="transpose">
<a class="viewcode-back" href="../../reference/generated/dpnp.transpose.html#dpnp.transpose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an array with axes transposed.</span>

<span class="sd">    Note that :obj:`dpnp.permute_dims` is an alias of :obj:`dpnp.transpose`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.transpose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axes : {None, tuple or list of ints}, optional</span>
<span class="sd">        If specified, it must be a tuple or list which contains a permutation</span>
<span class="sd">        of [0, 1, ..., N-1] where N is the number of axes of `a`.</span>
<span class="sd">        The `i`&#39;th axis of the returned array will correspond to the axis</span>
<span class="sd">        numbered ``axes[i]`` of the input. If not specified or ``None``,</span>
<span class="sd">        defaults to ``range(a.ndim)[::-1]``, which reverses the order of</span>
<span class="sd">        the axes.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        `a` with its axes permuted. A view is returned whenever possible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.transpose` : Equivalent method.</span>
<span class="sd">    :obj:`dpnp.moveaxis` : Move array axes to new positions.</span>
<span class="sd">    :obj:`dpnp.argsort` : Returns the indices that would sort an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(a)</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [2, 4]])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(a)</span>
<span class="sd">    array([1, 2, 3, 4])</span>

<span class="sd">    &gt;&gt;&gt; a = np.ones((1, 2, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(a, (1, 0, 2)).shape</span>
<span class="sd">    (2, 1, 3)</span>

<span class="sd">    &gt;&gt;&gt; a = np.ones((2, 3, 4, 5))</span>
<span class="sd">    &gt;&gt;&gt; np.transpose(a).shape</span>
<span class="sd">    (5, 4, 3, 2)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">*</span><span class="n">axes</span><span class="p">)</span></div>



<span class="n">permute_dims</span> <span class="o">=</span> <span class="n">transpose</span>  <span class="c1"># permute_dims is an alias for transpose</span>


<div class="viewcode-block" id="trim_zeros">
<a class="viewcode-back" href="../../reference/generated/dpnp.trim_zeros.html#dpnp.trim_zeros">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s2">&quot;fb&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove values along a dimension which are zero along all other.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.trim_zeros`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filt : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    trim : {&quot;fb&quot;, &quot;f&quot;, &quot;b&quot;}, optional</span>
<span class="sd">        A string with `&quot;f&quot;` representing trim from front and `&quot;b&quot;` to trim from</span>
<span class="sd">        back. By default, zeros are trimmed on both sides. Front and back refer</span>
<span class="sd">        to the edges of a dimension, with &quot;front&quot; referring to the side with</span>
<span class="sd">        the lowest index 0, and &quot;back&quot; referring to the highest index</span>
<span class="sd">        (or index -1).</span>

<span class="sd">        Default: ``&quot;fb&quot;``.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        If ``None``, `filt` is cropped such that the smallest bounding box is</span>
<span class="sd">        returned that still contains all values which are not zero.</span>
<span class="sd">        If an `axis` is specified, `filt` will be sliced in that dimension only</span>
<span class="sd">        on the sides specified by `trim`. The remaining area will be the</span>
<span class="sd">        smallest that still contains all values which are not zero.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The result of trimming the input. The number of dimensions and the</span>
<span class="sd">        input data type are preserved.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For all-zero arrays, the first axis is trimmed first.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))</span>
<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a)</span>
<span class="sd">    array([1, 2, 3, 0, 2, 1])</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros(a, trim=&#39;b&#39;)</span>
<span class="sd">    array([0, 0, 0, 1, 2, 3, 0, 2, 1])</span>

<span class="sd">    Multiple dimensions are supported:</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[0, 0, 2, 3, 0, 0],</span>
<span class="sd">    ...               [0, 1, 0, 3, 0, 0],</span>
<span class="sd">    ...               [0, 0, 0, 0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.trim_zeros(b)</span>
<span class="sd">    array([[0, 2, 3],</span>
<span class="sd">           [1, 0, 3]])</span>

<span class="sd">    &gt;&gt;&gt; np.trim_zeros(b, axis=-1)</span>
<span class="sd">    array([[0, 2, 3],</span>
<span class="sd">           [1, 0, 3],</span>
<span class="sd">           [0, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only string trim is supported&quot;</span><span class="p">)</span>

    <span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fb&quot;</span><span class="p">,</span> <span class="s2">&quot;bf&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unexpected character(s) in `trim`: </span><span class="si">{</span><span class="n">trim</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">nd</span> <span class="o">=</span> <span class="n">filt</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filt</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filt</span>  <span class="c1"># no trailing zeros in empty array</span>

    <span class="n">non_zero</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">non_zero</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># `filt` has all zeros, so assign `start` and `stop` to the same value,</span>
        <span class="c1"># then the resulting slice will be empty</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">nd</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;f&quot;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">non_zero</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">nd</span>

        <span class="k">if</span> <span class="s2">&quot;b&quot;</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">non_zero</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stop</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Adjust for slicing</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="n">nd</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># trim all axes</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># only trim single axis</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">stop</span><span class="p">[</span><span class="n">axis</span><span class="p">]),)</span> <span class="o">+</span> <span class="p">(</span><span class="o">...</span><span class="p">,)</span>

    <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span></div>



<div class="viewcode-block" id="unique">
<a class="viewcode-back" href="../../reference/generated/dpnp.unique.html#dpnp.unique">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unique</span><span class="p">(</span>
    <span class="n">ar</span><span class="p">,</span>
    <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the unique elements of an array.</span>

<span class="sd">    Returns the sorted unique elements of an array. There are three optional</span>
<span class="sd">    outputs in addition to the unique elements:</span>

<span class="sd">    * the indices of the input array that give the unique values</span>
<span class="sd">    * the indices of the unique array that reconstruct the input array</span>
<span class="sd">    * the number of times each unique value comes up in the input array</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unique`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ar : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. Unless `axis` is specified, this will be flattened if it</span>
<span class="sd">        is not already 1-D.</span>
<span class="sd">    return_index : bool, optional</span>
<span class="sd">        If ``True``, also return the indices of `ar` (along the specified axis,</span>
<span class="sd">        if provided, or in the flattened array) that result in the unique array.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    return_inverse : bool, optional</span>
<span class="sd">        If ``True``, also return the indices of the unique array (for the</span>
<span class="sd">        specified axis, if provided) that can be used to reconstruct `ar`.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    return_counts : bool, optional</span>
<span class="sd">        If ``True``, also return the number of times each unique item appears</span>
<span class="sd">        in `ar`.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    axis : {int, None}, optional</span>
<span class="sd">        The axis to operate on. If ``None``, `ar` will be flattened. If an</span>
<span class="sd">        integer, the subarrays indexed by the given axis will be flattened and</span>
<span class="sd">        treated as the elements of a 1-D array with the dimension of the given</span>
<span class="sd">        axis, see the notes for more details.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    equal_nan : bool, optional</span>
<span class="sd">        If ``True``, collapses multiple NaN values in the return array into one.</span>

<span class="sd">        Default: ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unique : dpnp.ndarray</span>
<span class="sd">        The sorted unique values.</span>
<span class="sd">    unique_indices : dpnp.ndarray, optional</span>
<span class="sd">        The indices of the first occurrences of the unique values in the</span>
<span class="sd">        original array. Only provided if `return_index` is ``True``.</span>
<span class="sd">    unique_inverse : dpnp.ndarray, optional</span>
<span class="sd">        The indices to reconstruct the original array from the unique array.</span>
<span class="sd">        Only provided if `return_inverse` is ``True``.</span>
<span class="sd">    unique_counts : dpnp.ndarray, optional</span>
<span class="sd">        The number of times each of the unique values comes up in the original</span>
<span class="sd">        array. Only provided if `return_counts` is ``True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.repeat` : Repeat elements of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When an axis is specified the subarrays indexed by the axis are sorted.</span>
<span class="sd">    This is done by making the specified axis the first dimension of the array</span>
<span class="sd">    (move the axis to the first dimension to keep the order of the other axes)</span>
<span class="sd">    and then flattening the subarrays in C order.</span>
<span class="sd">    For complex arrays all NaN values are considered equivalent (no matter</span>
<span class="sd">    whether the NaN is in the real or imaginary part). As the representative for</span>
<span class="sd">    the returned array the smallest one in the lexicographical order is chosen.</span>
<span class="sd">    For multi-dimensional inputs, `unique_inverse` is reshaped such that the</span>
<span class="sd">    input can be reconstructed using</span>
<span class="sd">    ``dpnp.take(unique, unique_inverse, axis=axis)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 1, 2, 2, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.unique(a)</span>
<span class="sd">    array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.unique(a)</span>
<span class="sd">    array([1, 2, 3])</span>

<span class="sd">    Return the unique rows of a 2D array</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.unique(a, axis=0)</span>
<span class="sd">    array([[1, 0, 0],</span>
<span class="sd">           [2, 3, 4]])</span>

<span class="sd">    Reconstruct the input array from the unique values and inverse:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)</span>
<span class="sd">    &gt;&gt;&gt; u</span>
<span class="sd">    array([1, 2, 3, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; indices</span>
<span class="sd">    array([0, 1, 4, 3, 1, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; u[indices]</span>
<span class="sd">    array([1, 2, 6, 4, 2, 3, 2])</span>

<span class="sd">    Reconstruct the input values from the unique values and counts:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; values, counts = np.unique(a, return_counts=True)</span>
<span class="sd">    &gt;&gt;&gt; values</span>
<span class="sd">    array([1, 2, 3, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; counts</span>
<span class="sd">    array([1, 3, 1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.repeat(values, counts)</span>
<span class="sd">    array([1, 2, 2, 2, 3, 4, 6])    # original order not preserved</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_unique_1d</span><span class="p">(</span>
            <span class="n">ar</span><span class="p">,</span> <span class="n">return_index</span><span class="p">,</span> <span class="n">return_inverse</span><span class="p">,</span> <span class="n">return_counts</span><span class="p">,</span> <span class="n">equal_nan</span>
        <span class="p">)</span>

    <span class="c1"># axis was specified and not None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">AxisError</span><span class="p">:</span>
        <span class="c1"># this removes the &quot;axis1&quot; or &quot;axis2&quot; prefix from the error message</span>
        <span class="k">raise</span> <span class="n">AxisError</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>

    <span class="c1"># reshape input array into a contiguous 2D array</span>
    <span class="n">orig_sh</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">orig_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">orig_sh</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>

    <span class="c1"># build the indices for result array with unique values</span>
    <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">_unique_build_sort_indices</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">orig_sh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ar</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">ar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># if the array is empty, then the mask should grab the first empty</span>
        <span class="c1"># array as the unique one</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ar</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># index the input array with the unique elements and reshape it into the</span>
    <span class="c1"># original size and dimension order</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="o">*</span><span class="n">orig_sh</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">ar</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">ar</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">ar</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">return_index</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sorted_indices</span><span class="p">[</span><span class="n">mask</span><span class="p">],)</span>
    <span class="k">if</span> <span class="n">return_inverse</span><span class="p">:</span>
        <span class="n">imask</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">inv_idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">inv_idx</span><span class="p">[</span><span class="n">sorted_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">imask</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">inv_idx</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">return_counts</span><span class="p">:</span>
        <span class="n">nonzero</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span>
            <span class="n">nonzero</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">nonzero</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">nonzero</span><span class="o">.</span><span class="n">dtype</span>
        <span class="p">)</span>
        <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nonzero</span>
        <span class="n">idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],)</span>

    <span class="k">return</span> <span class="n">_unpack_tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div>



<div class="viewcode-block" id="unique_all">
<a class="viewcode-back" href="../../reference/generated/dpnp.unique_all.html#dpnp.unique_all">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unique_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the unique elements of an array, and counts, inverse, and indices.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unique_all`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. It will be flattened if it is not already 1-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    values : dpnp.ndarray</span>
<span class="sd">        The unique elements of an input array.</span>
<span class="sd">    indices : dpnp.ndarray</span>
<span class="sd">        The first occurring indices for each unique element.</span>
<span class="sd">    inverse_indices : dpnp.ndarray</span>
<span class="sd">        The indices from the set of unique elements that reconstruct `x`.</span>
<span class="sd">    counts : dpnp.ndarray</span>
<span class="sd">        The corresponding counts for each unique element.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.unique` : Find the unique elements of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq = np.unique_all(x)</span>
<span class="sd">    &gt;&gt;&gt; uniq.values</span>
<span class="sd">    array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq.indices</span>
<span class="sd">    array([0, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq.inverse_indices</span>
<span class="sd">    array([0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; uniq.counts</span>
<span class="sd">    array([2, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">UniqueAllResult</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span></div>



<div class="viewcode-block" id="unique_counts">
<a class="viewcode-back" href="../../reference/generated/dpnp.unique_counts.html#dpnp.unique_counts">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unique_counts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the unique elements and counts of an input array `x`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unique_counts`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. It will be flattened if it is not already 1-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    values : dpnp.ndarray</span>
<span class="sd">        The unique elements of an input array.</span>
<span class="sd">    counts : dpnp.ndarray</span>
<span class="sd">        The corresponding counts for each unique element.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.unique` : Find the unique elements of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq = np.unique_counts(x)</span>
<span class="sd">    &gt;&gt;&gt; uniq.values</span>
<span class="sd">    array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq.counts</span>
<span class="sd">    array([2, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">UniqueCountsResult</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span></div>



<div class="viewcode-block" id="unique_inverse">
<a class="viewcode-back" href="../../reference/generated/dpnp.unique_inverse.html#dpnp.unique_inverse">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unique_inverse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the unique elements of `x` and indices to reconstruct `x`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unique_inverse`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. It will be flattened if it is not already 1-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    values : dpnp.ndarray</span>
<span class="sd">        The unique elements of an input array.</span>
<span class="sd">    inverse_indices : dpnp.ndarray</span>
<span class="sd">        The indices from the set of unique elements that reconstruct `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.unique` : Find the unique elements of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq = np.unique_inverse(x)</span>
<span class="sd">    &gt;&gt;&gt; uniq.values</span>
<span class="sd">    array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; uniq.inverse_indices</span>
<span class="sd">    array([0, 0, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">UniqueInverseResult</span><span class="p">(</span><span class="o">*</span><span class="n">result</span><span class="p">)</span></div>



<div class="viewcode-block" id="unique_values">
<a class="viewcode-back" href="../../reference/generated/dpnp.unique_values.html#dpnp.unique_values">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unique_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the unique elements of an input array `x`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unique_values`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. It will be flattened if it is not already 1-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The unique elements of an input array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.unique` : Find the unique elements of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.unique_values(np.array([1, 1, 2]))</span>
<span class="sd">    array([1, 2])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
        <span class="n">x</span><span class="p">,</span>
        <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_counts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">equal_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="unstack">
<a class="viewcode-back" href="../../reference/generated/dpnp.unstack.html#dpnp.unstack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unstack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split an array into a sequence of arrays along the given axis.</span>

<span class="sd">    The `axis` parameter specifies the dimension along which the array will</span>
<span class="sd">    be split. For example, if ``axis=0`` (the default) it will be the first</span>
<span class="sd">    dimension and if ``axis=-1`` it will be the last dimension.</span>

<span class="sd">    The result is a tuple of arrays split along `axis`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unstack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array to be unstacked.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the array will be split.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unstacked : tuple of dpnp.ndarray</span>
<span class="sd">        The unstacked arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble an ndarray from nested lists of blocks.</span>
<span class="sd">    :obj:`dpnp.split` : Split array into a list of multiple sub-arrays of equal</span>
<span class="sd">                        size.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    :obj:`dpnp.unstack` serves as the reverse operation of :obj:`dpnp.stack`,</span>
<span class="sd">    i.e., ``dpnp.stack(dpnp.unstack(x, axis=axis), axis=axis) == x``.</span>

<span class="sd">    This function is equivalent to ``tuple(dpnp.moveaxis(x, axis, 0))``, since</span>
<span class="sd">    iterating on an array iterates along the first axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.arange(24).reshape((2, 3, 4))</span>
<span class="sd">    &gt;&gt;&gt; np.unstack(arr)</span>
<span class="sd">    (array([[ 0,  1,  2,  3],</span>
<span class="sd">            [ 4,  5,  6,  7],</span>
<span class="sd">            [ 8,  9, 10, 11]]),</span>
<span class="sd">     array([[12, 13, 14, 15],</span>
<span class="sd">            [16, 17, 18, 19],</span>
<span class="sd">            [20, 21, 22, 23]]))</span>

<span class="sd">    &gt;&gt;&gt; np.unstack(arr, axis=1)</span>
<span class="sd">    (array([[ 0,  1,  2,  3],</span>
<span class="sd">            [12, 13, 14, 15]]),</span>
<span class="sd">     array([[ 4,  5,  6,  7],</span>
<span class="sd">            [16, 17, 18, 19]]),</span>
<span class="sd">     array([[ 8,  9, 10, 11],</span>
<span class="sd">            [20, 21, 22, 23]]))</span>

<span class="sd">    &gt;&gt;&gt; arr2 = np.stack(np.unstack(arr, axis=1), axis=1)</span>
<span class="sd">    &gt;&gt;&gt; arr2.shape</span>
<span class="sd">    (2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; np.all(arr == arr2)</span>
<span class="sd">    array(True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_x</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">usm_x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input array must be at least 1-d.&quot;</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">usm_x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">res</span><span class="p">)</span></div>



<div class="viewcode-block" id="vsplit">
<a class="viewcode-back" href="../../reference/generated/dpnp.vsplit.html#dpnp.vsplit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vsplit</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split an array into multiple sub-arrays vertically (row-wise).</span>

<span class="sd">    Please refer to the :obj:`dpnp.split` documentation. ``vsplit``</span>
<span class="sd">    is equivalent to ``split`` with ``axis=0`` (default), the array</span>
<span class="sd">    is always split along the first axis regardless of the array dimension.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.vsplit`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ary : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to be divided into sub-arrays.</span>
<span class="sd">    indices_or_sections : {int, sequence of ints}</span>
<span class="sd">        If `indices_or_sections` is an integer, N, the array will be divided</span>
<span class="sd">        into N equal arrays along the first axis. If such a split is not</span>
<span class="sd">        possible, an error is raised.</span>
<span class="sd">        If `indices_or_sections` is a sequence of sorted integers, the entries</span>
<span class="sd">        indicate where along the first axis the array is split.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sub-arrays : list of dpnp.ndarray</span>
<span class="sd">        A list of sub arrays. Each array is a view of the corresponding input</span>
<span class="sd">        array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.split` : Split array into multiple sub-arrays of equal size.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.],</span>
<span class="sd">           [ 4.,  5.,  6.,  7.],</span>
<span class="sd">           [ 8.,  9., 10., 11.],</span>
<span class="sd">           [12., 13., 14., 15.]])</span>
<span class="sd">    &gt;&gt;&gt; np.vsplit(x, 2)</span>
<span class="sd">    [array([[0., 1., 2., 3.],</span>
<span class="sd">            [4., 5., 6., 7.]]),</span>
<span class="sd">     array([[ 8.,  9., 10., 11.],</span>
<span class="sd">            [12., 13., 14., 15.]])]</span>
<span class="sd">    &gt;&gt;&gt; np.vsplit(x, np.array([3, 6]))</span>
<span class="sd">    [array([[ 0.,  1.,  2.,  3.],</span>
<span class="sd">            [ 4.,  5.,  6.,  7.],</span>
<span class="sd">            [ 8.,  9., 10., 11.]]),</span>
<span class="sd">     array([[12., 13., 14., 15.]]),</span>
<span class="sd">     array([], shape=(0, 4), dtype=float64)]</span>

<span class="sd">    With a higher dimensional array the split is still along the first axis.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[0., 1.],</span>
<span class="sd">            [2., 3.]],</span>
<span class="sd">           [[4., 5.],</span>
<span class="sd">            [6., 7.]]])</span>
<span class="sd">    &gt;&gt;&gt; np.vsplit(x, 2)</span>
<span class="sd">    [array([[[0., 1.],</span>
<span class="sd">             [2., 3.]]]),</span>
<span class="sd">     array([[[4., 5.],</span>
<span class="sd">             [6., 7.]]])]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;vsplit only works on arrays of 2 or more dimensions&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>



<div class="viewcode-block" id="vstack">
<a class="viewcode-back" href="../../reference/generated/dpnp.vstack.html#dpnp.vstack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vstack</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack arrays in sequence vertically (row wise).</span>

<span class="sd">    :obj:`dpnp.row_stack` is an alias for :obj:`dpnp.vstack`.</span>
<span class="sd">    They are the same function.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.vstack`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tup : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The arrays must have the same shape along all but the first axis.</span>
<span class="sd">        1-D arrays must have the same length.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        If provided, the destination array will have this dtype.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span>
<span class="sd">        Controls what kind of data casting may occur. Defaults to &#39;same_kind&#39;.</span>

<span class="sd">        Default: ``&quot;same_kind&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The array formed by stacking the given arrays, will be at least 2-D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.concatenate` : Join a sequence of arrays along an existing axis.</span>
<span class="sd">    :obj:`dpnp.stack` : Join a sequence of arrays along a new axis.</span>
<span class="sd">    :obj:`dpnp.hstack` : Stack arrays in sequence horizontally (column wise).</span>
<span class="sd">    :obj:`dpnp.dstack` : Stack arrays in sequence depth wise (along third axis).</span>
<span class="sd">    :obj:`dpnp.column_stack` : Stack 1-D arrays as columns into a 2-D array.</span>
<span class="sd">    :obj:`dpnp.block` : Assemble an ndarray from nested lists of blocks.</span>
<span class="sd">    :obj:`dpnp.split` : Split array into a list of multiple sub-arrays of equal</span>
<span class="sd">                        size.</span>
<span class="sd">    :obj:`dpnp.unstack` : Split an array into a tuple of sub-arrays along</span>
<span class="sd">                          an axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.vstack((a, b))</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1], [2], [3]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[4], [5], [6]])</span>
<span class="sd">    &gt;&gt;&gt; np.vstack((a, b))</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [2],</span>
<span class="sd">           [3],</span>
<span class="sd">           [4],</span>
<span class="sd">           [5],</span>
<span class="sd">           [6]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_check_stack_arrays</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>

    <span class="n">arrs</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrs</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span></div>



<span class="n">row_stack</span> <span class="o">=</span> <span class="n">vstack</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2026, Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>