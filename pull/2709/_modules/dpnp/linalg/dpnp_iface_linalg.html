

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-554F8VNE28"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-554F8VNE28');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dpnp.linalg.dpnp_iface_linalg &mdash; Data Parallel Extension for NumPy 0.20.0dev1+22.ge6e5ee469d1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=d57efe18"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Data Parallel Extension for NumPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quick_start_guide.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Data Parallel Extension for NumPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dpnp.linalg.dpnp_iface_linalg</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dpnp.linalg.dpnp_iface_linalg</h1><div class="highlight"><pre>
<span></span><span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2016, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1"># - Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#   may be used to endorse or promote products derived from this software</span>
<span class="c1">#   without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interface of the Linear Algebra part of the DPNP</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">This module is a face or public interface file for the library</span>
<span class="sd">it contains:</span>
<span class="sd"> - Interface functions</span>
<span class="sd"> - documentation for the functions</span>
<span class="sd"> - The functions parameters check</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=no-member</span>
<span class="c1"># pylint: disable=no-name-in-module</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamedTuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._numpy_helper</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize_axis_tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpnp.backend.extensions.lapack._lapack_impl</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinAlgError</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_utils_linalg</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">assert_2d</span><span class="p">,</span>
    <span class="n">assert_stacked_2d</span><span class="p">,</span>
    <span class="n">assert_stacked_square</span><span class="p">,</span>
    <span class="n">dpnp_cholesky</span><span class="p">,</span>
    <span class="n">dpnp_cond</span><span class="p">,</span>
    <span class="n">dpnp_det</span><span class="p">,</span>
    <span class="n">dpnp_eigh</span><span class="p">,</span>
    <span class="n">dpnp_inv</span><span class="p">,</span>
    <span class="n">dpnp_lstsq</span><span class="p">,</span>
    <span class="n">dpnp_matrix_power</span><span class="p">,</span>
    <span class="n">dpnp_matrix_rank</span><span class="p">,</span>
    <span class="n">dpnp_multi_dot</span><span class="p">,</span>
    <span class="n">dpnp_norm</span><span class="p">,</span>
    <span class="n">dpnp_pinv</span><span class="p">,</span>
    <span class="n">dpnp_qr</span><span class="p">,</span>
    <span class="n">dpnp_slogdet</span><span class="p">,</span>
    <span class="n">dpnp_solve</span><span class="p">,</span>
    <span class="n">dpnp_svd</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Need to set the module explicitly, because it&#39;s initially exposed by LAPACK</span>
<span class="c1"># pybind11 extension and to add the docstrings</span>
<span class="n">LinAlgError</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="s2">&quot;dpnp.linalg&quot;</span>
<span class="n">LinAlgError</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Generic Python-exception-derived object raised by LinAlg functions.</span>

<span class="s2">For full documentation refer to :obj:`numpy.linalg.LinAlgError`.</span>

<span class="s2">General purpose exception class, derived from Python&#39;s ``ValueError`` class,</span>
<span class="s2">programmatically raised in LinAlg functions when a Linear Algebra-related</span>
<span class="s2">condition would prevent further correct execution of the function.</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; import dpnp as np</span>
<span class="s2">&gt;&gt;&gt; np.linalg.inv(np.zeros((2, 2)))</span>
<span class="s2">Traceback (most recent call last):</span>
<span class="s2">...</span>
<span class="s2">dpnp.linalg.LinAlgError: The input coefficient matrix is singular.</span>

<span class="s2">&quot;&quot;&quot;</span>


<span class="c1"># pylint:disable=missing-class-docstring</span>
<span class="k">class</span><span class="w"> </span><span class="nc">EigResult</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">eigenvalues</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="n">eigenvectors</span><span class="p">:</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span>


<div class="viewcode-block" id="cholesky">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.cholesky.html#dpnp.linalg.cholesky">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cholesky</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cholesky decomposition.</span>

<span class="sd">    Return the lower or upper Cholesky decomposition, ``L * L.H`` or</span>
<span class="sd">    ``U.H * U``, of the square matrix ``a``, where ``L`` is lower-triangular,</span>
<span class="sd">    ``U`` is upper-triangular, and ``.H`` is the conjugate transpose operator</span>
<span class="sd">    (which is the ordinary transpose if ``a`` is real-valued). ``a`` must be</span>
<span class="sd">    Hermitian (symmetric if real-valued) and positive-definite. No checking is</span>
<span class="sd">    performed to verify whether ``a`` is Hermitian or not. In addition, only</span>
<span class="sd">    the lower or upper-triangular and diagonal elements of ``a`` are used.</span>
<span class="sd">    Only ``L`` or ``U`` is actually returned.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.cholesky`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Hermitian (symmetric if all elements are real), positive-definite</span>
<span class="sd">        input matrix.</span>
<span class="sd">    upper : {bool}, optional</span>
<span class="sd">        If ``True``, the result must be the upper-triangular Cholesky factor.</span>
<span class="sd">        If ``False``, the result must be the lower-triangular Cholesky factor.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : (..., M, M) dpnp.ndarray</span>
<span class="sd">        Lower or upper-triangular Cholesky factor of `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[1.0, 2.0],[2.0, 5.0]])</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[1., 2.],</span>
<span class="sd">           [2., 5.]])</span>
<span class="sd">    &gt;&gt;&gt; L = np.linalg.cholesky(A)</span>
<span class="sd">    &gt;&gt;&gt; L</span>
<span class="sd">    array([[1., 0.],</span>
<span class="sd">           [2., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A</span>
<span class="sd">    array([[1., 2.],</span>
<span class="sd">           [2., 5.]])</span>

<span class="sd">    The upper-triangular Cholesky factor can also be obtained:</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.cholesky(A, upper=True)</span>
<span class="sd">    array([[ 1.+0.j, -0.-2.j],</span>
<span class="sd">           [ 0.+0.j,  1.+0.j]]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_cholesky</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">upper</span><span class="o">=</span><span class="n">upper</span><span class="p">)</span></div>



<div class="viewcode-block" id="cond">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.cond.html#dpnp.linalg.cond">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the condition number of a matrix.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.cond`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The matrix whose condition number is sought.</span>
<span class="sd">    p : {None, 1, -1, 2, -2, inf, -inf, &quot;fro&quot;}, optional</span>
<span class="sd">        Order of the norm used in the condition number computation:</span>

<span class="sd">        =====  ============================</span>
<span class="sd">        p      norm for matrices</span>
<span class="sd">        =====  ============================</span>
<span class="sd">        None   2-norm</span>
<span class="sd">        &#39;fro&#39;  Frobenius norm</span>
<span class="sd">        inf    max(sum(abs(x), axis=1))</span>
<span class="sd">        -inf   min(sum(abs(x), axis=1))</span>
<span class="sd">        1      max(sum(abs(x), axis=0))</span>
<span class="sd">        -1     min(sum(abs(x), axis=0))</span>
<span class="sd">        2      2-norm (largest singular value)</span>
<span class="sd">        -2     smallest singular value</span>
<span class="sd">        =====  ============================</span>

<span class="sd">        ``inf`` means the :obj:`dpnp.inf` object, and the Frobenius norm is</span>
<span class="sd">        the root-of-sum-of-squares norm.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The condition number of the matrix. May be infinite.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.norm` : Matrix or vector norm.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function will raise :class:`dpnp.linalg.LinAlgError` on singular input</span>
<span class="sd">    when using any of the norm: ``1``, ``-1``, ``inf``, ``-inf``, or ``&#39;fro&#39;``.</span>
<span class="sd">    In contrast, :obj:`numpy.linalg.cond` will fill the result array with</span>
<span class="sd">    ``inf`` values for each 2D batch in the input array that is singular</span>
<span class="sd">    when using these norms.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1,  0, -1],</span>
<span class="sd">           [ 0,  1,  0],</span>
<span class="sd">           [ 1,  0,  1]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a)</span>
<span class="sd">    array(1.41421356)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, &#39;fro&#39;)</span>
<span class="sd">    array(3.16227766)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, np.inf)</span>
<span class="sd">    array(2.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, -np.inf)</span>
<span class="sd">    array(1.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, 1)</span>
<span class="sd">    array(2.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, -1)</span>
<span class="sd">    array(1.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, 2)</span>
<span class="sd">    array(1.41421356)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cond(a, -2)</span>
<span class="sd">    array(0.70710678) # may vary</span>
<span class="sd">    &gt;&gt;&gt; x = min(np.linalg.svd(a, compute_uv=False))</span>
<span class="sd">    &gt;&gt;&gt; y = min(np.linalg.svd(np.linalg.inv(a), compute_uv=False))</span>
<span class="sd">    &gt;&gt;&gt; x * y</span>
<span class="sd">    array(0.70710678) # may vary</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_cond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>



<div class="viewcode-block" id="cross">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.cross.html#dpnp.linalg.cross">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cross</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the cross product of 3-element vectors.</span>

<span class="sd">    If `x1` and/or `x2` are multi-dimensional arrays, then</span>
<span class="sd">    the cross-product of each pair of corresponding 3-element vectors</span>
<span class="sd">    is independently computed.</span>

<span class="sd">    This function is Array API compatible, contrary to :obj:`dpnp.cross`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.cross`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        First input array.</span>
<span class="sd">    b : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Second input array. Must be compatible with `x1` for all</span>
<span class="sd">        non-compute axes. The size of the axis over which to compute</span>
<span class="sd">        the cross-product must be the same size as the respective axis</span>
<span class="sd">        in `x1`.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis (dimension) of `x1` and `x2` containing the vectors for</span>
<span class="sd">        which to compute the cross-product.</span>

<span class="sd">        Default: ``-1``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">         An array containing the cross products.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.cross` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Vector cross-product.</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cross(x, y)</span>
<span class="sd">    array([-3,  6, -3])</span>

<span class="sd">    Multiple vector cross-products. Note that the direction of the cross</span>
<span class="sd">    product vector is defined by the *right-hand rule*.</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[4, 5, 6], [1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cross(x, y)</span>
<span class="sd">    array([[-3,  6, -3],</span>
<span class="sd">           [ 3, -6,  3]])</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([[4, 5], [6, 1], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cross(x, y, axis=0)</span>
<span class="sd">    array([[-24,  6],</span>
<span class="sd">           [ 18, 24],</span>
<span class="sd">           [-6,  -18]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">x2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Both input arrays must be (arrays of) 3-dimensional vectors, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;but they are </span><span class="si">{</span><span class="n">x1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">x2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;dimensional instead.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="det">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.det.html#dpnp.linalg.det">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">det</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the determinant of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.det`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array to compute determinants for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    det : (...) dpnp.ndarray</span>
<span class="sd">        Determinant of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.slogdet` : Returns sign and logarithm of the determinant</span>
<span class="sd">                                 of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as dp</span>
<span class="sd">    &gt;&gt;&gt; a = dp.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; dp.linalg.det(a)</span>
<span class="sd">    array(-2.)</span>

<span class="sd">    Computing determinants for a stack of matrices:</span>

<span class="sd">    &gt;&gt;&gt; a = dp.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; dp.linalg.det(a)</span>
<span class="sd">    array([-2., -3., -8.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_det</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="diagonal">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.diagonal.html#dpnp.linalg.diagonal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns specified diagonals of a matrix (or a stack of matrices) `x`.</span>

<span class="sd">    This function is Array API compatible, contrary to :obj:`dpnp.diagonal`</span>
<span class="sd">    the matrix is assumed to be defined by the last two dimensions.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.diagonal`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array having shape (..., M, N) and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset specifying the off-diagonal relative to the main diagonal,</span>
<span class="sd">        where:</span>

<span class="sd">            * offset = 0: the main diagonal.</span>
<span class="sd">            * offset &gt; 0: off-diagonal above the main diagonal.</span>
<span class="sd">            * offset &lt; 0: off-diagonal below the main diagonal.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (...,min(N, M)) dpnp.ndarray</span>
<span class="sd">        An array containing the diagonals and whose shape is determined by</span>
<span class="sd">        removing the last two dimensions and appending a dimension equal to</span>
<span class="sd">        the size of the resulting diagonals. The returned array must have</span>
<span class="sd">        the same data type as `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.diagonal` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape(2, 2); a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a)</span>
<span class="sd">    array([0, 3])</span>

<span class="sd">    A 3-D example:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape(2, 2, 2); a</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a)</span>
<span class="sd">    array([[0, 3],</span>
<span class="sd">           [4, 7]])</span>

<span class="sd">    Diagonals adjacent to the main diagonal can be obtained by using the</span>
<span class="sd">    `offset` argument:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a, offset=1)  # First superdiagonal</span>
<span class="sd">    array([1, 5])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a, offset=2)  # Second superdiagonal</span>
<span class="sd">    array([2])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a, offset=-1)  # First subdiagonal</span>
<span class="sd">    array([3, 7])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(a, offset=-2)  # Second subdiagonal</span>
<span class="sd">    array([6])</span>

<span class="sd">    The anti-diagonal can be obtained by reversing the order of elements</span>
<span class="sd">    using either :obj:`dpnp.flipud` or :obj:`dpnp.fliplr`.</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(np.fliplr(a))  # Horizontal flip</span>
<span class="sd">    array([2, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.diagonal(np.flipud(a))  # Vertical flip</span>
<span class="sd">    array([6, 4, 2])</span>

<span class="sd">    Note that the order in which the diagonal is retrieved varies depending</span>
<span class="sd">    on the flip function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="eig">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.eig.html#dpnp.linalg.eig">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eig</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues and right eigenvectors of a square array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.eig`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Matrices for which the eigenvalues and right eigenvectors will</span>
<span class="sd">        be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    eigenvalues : (..., M) dpnp.ndarray</span>
<span class="sd">        The eigenvalues, each repeated according to its multiplicity.</span>
<span class="sd">        The eigenvalues are not necessarily ordered. The resulting array will</span>
<span class="sd">        be of complex type, unless the imaginary part is zero in which case it</span>
<span class="sd">        will be cast to a real type. When `a` is real the resulting eigenvalues</span>
<span class="sd">        will be real (zero imaginary part) or occur in conjugate pairs.</span>
<span class="sd">    eigenvectors : (..., M, M) dpnp.ndarray</span>
<span class="sd">        The normalized (unit &quot;length&quot;) eigenvectors, such that the column</span>
<span class="sd">        ``eigenvectors[:,i]`` is the eigenvector corresponding to the</span>
<span class="sd">        eigenvalue ``eigenvalues[i]``.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Since there is no proper OneMKL LAPACK function, DPNP will calculate</span>
<span class="sd">    through a fallback on NumPy call.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.eigvals` : Compute the eigenvalues of a general matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eigh` : Return the eigenvalues and eigenvectors of</span>
<span class="sd">                              a complex Hermitian (conjugate symmetric) or</span>
<span class="sd">                              a real symmetric matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eigvalsh` : Compute the eigenvalues of a complex</span>
<span class="sd">                                  Hermitian or real symmetric matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; from dpnp import linalg as LA</span>

<span class="sd">    (Almost) trivial example with real eigenvalues and eigenvectors.</span>

<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))</span>
<span class="sd">    &gt;&gt;&gt; w, v</span>
<span class="sd">    (array([1., 2., 3.]),</span>
<span class="sd">     array([[1., 0., 0.],</span>
<span class="sd">            [0., 1., 0.],</span>
<span class="sd">            [0., 0., 1.]]))</span>

<span class="sd">    Real matrix possessing complex eigenvalues and eigenvectors;</span>
<span class="sd">    note that the eigenvalues are complex conjugates of each other.</span>

<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))</span>
<span class="sd">    &gt;&gt;&gt; w, v</span>
<span class="sd">    (array([1.+1.j, 1.-1.j]),</span>
<span class="sd">     array([[0.70710678+0.j        , 0.70710678-0.j        ],</span>
<span class="sd">            [0.        -0.70710678j, 0.        +0.70710678j]]))</span>

<span class="sd">    Complex-valued matrix with real eigenvalues (but complex-valued</span>
<span class="sd">    eigenvectors); note that ``a.conj().T == a``, i.e., `a` is Hermitian.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(a)</span>
<span class="sd">    &gt;&gt;&gt; w, v</span>
<span class="sd">    (array([2.+0.j, 0.+0.j]),</span>
<span class="sd">     array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary</span>
<span class="sd">            [ 0.70710678+0.j        , -0.        +0.70710678j]])</span>

<span class="sd">    Be careful about round-off error!</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])</span>
<span class="sd">    &gt;&gt;&gt; # Theor. eigenvalues are 1 +/- 1e-9</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(a)</span>
<span class="sd">    &gt;&gt;&gt; w, v</span>
<span class="sd">    (array([1., 1.]),</span>
<span class="sd">     array([[1., 0.],</span>
<span class="sd">            [0., 1.]]))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">a_sycl_queue</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sycl_queue</span>
    <span class="n">a_usm_type</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">usm_type</span>

    <span class="c1"># Since geev function from OneMKL LAPACK is not implemented yet,</span>
    <span class="c1"># use NumPy for this calculation.</span>
    <span class="n">w_np</span><span class="p">,</span> <span class="n">v_np</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">EigResult</span><span class="p">(</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w_np</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a_sycl_queue</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">a_usm_type</span><span class="p">),</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v_np</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a_sycl_queue</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">a_usm_type</span><span class="p">),</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="eigh">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.eigh.html#dpnp.linalg.eigh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the eigenvalues and eigenvectors of a complex Hermitian</span>
<span class="sd">    (conjugate symmetric) or a real symmetric matrix.</span>

<span class="sd">    Returns two objects, a 1-D array containing the eigenvalues of `a`, and</span>
<span class="sd">    a 2-D square array or matrix (depending on the input type) of the</span>
<span class="sd">    corresponding eigenvectors (in columns).</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.eigh`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A complex- or real-valued array whose eigenvalues and eigenvectors are</span>
<span class="sd">        to be computed.</span>
<span class="sd">    UPLO : {&quot;L&quot;, &quot;U&quot;}, optional</span>
<span class="sd">        Specifies the calculation uses either the lower (&quot;L&quot;) or upper (&quot;U&quot;)</span>
<span class="sd">        triangular part of the matrix.</span>
<span class="sd">        Regardless of this choice, only the real parts of the diagonal are</span>
<span class="sd">        considered to preserve the Hermite matrix property.</span>
<span class="sd">        It therefore follows that the imaginary part of the diagonal</span>
<span class="sd">        will always be treated as zero.</span>

<span class="sd">        Default: ``&quot;L&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    eigenvalues : (..., M) dpnp.ndarray</span>
<span class="sd">        The eigenvalues in ascending order, each repeated according to its</span>
<span class="sd">        multiplicity.</span>
<span class="sd">    eigenvectors : (..., M, M) dpnp.ndarray</span>
<span class="sd">        The column ``eigenvectors[:, i]`` is the normalized eigenvector</span>
<span class="sd">        corresponding to the eigenvalue ``eigenvalues[i]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.eigvalsh` : Compute the eigenvalues of a complex</span>
<span class="sd">                                  Hermitian or real symmetric matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eig` : Compute the eigenvalues and right eigenvectors of</span>
<span class="sd">                             a square array.</span>
<span class="sd">    :obj:`dpnp.linalg.eigvals` : Compute the eigenvalues of a general matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as dp</span>
<span class="sd">    &gt;&gt;&gt; a = dp.array([[1, -2j], [2j, 5]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1.+0.j, -0.-2.j],</span>
<span class="sd">           [ 0.+2.j,  5.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; w, v = dp.linalg.eigh(a)</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([0.17157288, 5.82842712]),</span>
<span class="sd">    array([[-0.92387953-0.j        , -0.38268343+0.j        ], # may vary</span>
<span class="sd">           [ 0.        +0.38268343j,  0.        -0.92387953j]]))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">UPLO</span> <span class="o">=</span> <span class="n">UPLO</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">)</span></div>



<div class="viewcode-block" id="eigvals">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.eigvals.html#dpnp.linalg.eigvals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues of a general matrix.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.eigvals`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A complex- or real-valued matrix whose eigenvalues will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M) dpnp.ndarray</span>
<span class="sd">        The eigenvalues, each repeated according to its multiplicity.</span>
<span class="sd">        They are not necessarily ordered, nor are they necessarily</span>
<span class="sd">        real for real matrices.</span>

<span class="sd">    Note</span>
<span class="sd">    ----</span>
<span class="sd">    Since there is no proper OneMKL LAPACK function, DPNP will calculate</span>
<span class="sd">    through a fallback on NumPy call.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.eig` : Compute the eigenvalues and right eigenvectors of</span>
<span class="sd">                             a square array.</span>
<span class="sd">    :obj:`dpnp.linalg.eigvalsh` : Compute the eigenvalues of a complex</span>
<span class="sd">                                  Hermitian or real symmetric matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eigh` : Return the eigenvalues and eigenvectors of</span>
<span class="sd">                              a complex Hermitian (conjugate symmetric) or</span>
<span class="sd">                              a real symmetric matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Illustration, using the fact that the eigenvalues of a diagonal matrix</span>
<span class="sd">    are its diagonal elements, that multiplying a matrix on the left</span>
<span class="sd">    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose</span>
<span class="sd">    of `Q`), preserves the eigenvalues of the &quot;middle&quot; matrix. In other words,</span>
<span class="sd">    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as</span>
<span class="sd">    ``A``:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; from dpnp import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.random()</span>
<span class="sd">    &gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])</span>
<span class="sd">    (array(1.), array(1.), array(0.))</span>

<span class="sd">    Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the</span>
<span class="sd">    other:</span>

<span class="sd">    &gt;&gt;&gt; D = np.diag((-1, 1))</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvals(D)</span>
<span class="sd">    array([-1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; A = np.dot(Q, D)</span>
<span class="sd">    &gt;&gt;&gt; A = np.dot(A, Q.T)</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvals(A)</span>
<span class="sd">    array([-1.,  1.]) # random</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># Since geev function from OneMKL LAPACK is not implemented yet,</span>
    <span class="c1"># use NumPy for this calculation.</span>
    <span class="n">w_np</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w_np</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">)</span></div>



<div class="viewcode-block" id="eigvalsh">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.eigvalsh.html#dpnp.linalg.eigvalsh">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">eigvalsh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s2">&quot;L&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</span>

<span class="sd">    Main difference from :obj:`dpnp.linalg.eigh`: the eigenvectors are not</span>
<span class="sd">    computed.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.eigvalsh`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A complex- or real-valued array whose eigenvalues are to be computed.</span>
<span class="sd">    UPLO : {&quot;L&quot;, &quot;U&quot;}, optional</span>
<span class="sd">        Specifies the calculation uses either the lower (&quot;L&quot;) or upper (&quot;U&quot;)</span>
<span class="sd">        triangular part of the matrix.</span>
<span class="sd">        Regardless of this choice, only the real parts of the diagonal are</span>
<span class="sd">        considered to preserve the Hermite matrix property.</span>
<span class="sd">        It therefore follows that the imaginary part of the diagonal</span>
<span class="sd">        will always be treated as zero.</span>

<span class="sd">        Default: ``&quot;L&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M) dpnp.ndarray</span>
<span class="sd">        The eigenvalues in ascending order, each repeated according to</span>
<span class="sd">        its multiplicity.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.eigh` : Return the eigenvalues and eigenvectors of</span>
<span class="sd">                              a complex Hermitian (conjugate symmetric)</span>
<span class="sd">                              or a real symmetric matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eigvals` : Compute the eigenvalues of a general matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.eig` : Compute the eigenvalues and right eigenvectors of</span>
<span class="sd">                             a general matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; from dpnp import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvalsh(a)</span>
<span class="sd">    array([0.17157288, 5.82842712])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">UPLO</span> <span class="o">=</span> <span class="n">UPLO</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="n">UPLO</span><span class="p">,</span> <span class="n">eigen_mode</span><span class="o">=</span><span class="s2">&quot;N&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="inv">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.inv.html#dpnp.linalg.inv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (multiplicative) inverse of a matrix.</span>

<span class="sd">    Given a square matrix `a`, return the matrix `ainv` satisfying</span>
<span class="sd">    ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.inv`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Matrix to be inverted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (..., M, M) dpnp.ndarray</span>
<span class="sd">        (Multiplicative) inverse of the matrix a.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.cond` : Compute the condition number of a matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.svd` : Compute the singular value decomposition.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; ainv = np.linalg.inv(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    Inverses of several matrices can be computed at once:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.inv(a)</span>
<span class="sd">    array([[[-2.  ,  1.  ],</span>
<span class="sd">            [ 1.5 , -0.5 ]],</span>
<span class="sd">           [[-1.25,  0.75],</span>
<span class="sd">            [ 0.75, -0.25]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="lstsq">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.lstsq.html#dpnp.linalg.lstsq">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">lstsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the least-squares solution to a linear matrix equation.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.lstsq`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        &quot;Coefficient&quot; matrix.</span>
<span class="sd">    b : {(M,), (M, K)} {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Ordinate or &quot;dependent variable&quot; values.</span>
<span class="sd">        If `b` is two-dimensional, the least-squares solution</span>
<span class="sd">        is calculated for each of the `K` columns of `b`.</span>
<span class="sd">    rcond : {None, int, float}, optional</span>
<span class="sd">        Cut-off ratio for small singular values of `a`.</span>
<span class="sd">        For the purposes of rank determination, singular values are treated as</span>
<span class="sd">        zero if they are smaller than `rcond` times the largest singular value</span>
<span class="sd">        of `a`.</span>
<span class="sd">        The default uses the machine precision times ``max(M, N)``. Passing</span>
<span class="sd">        ``-1`` will use machine precision.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : {(N,), (N, K)} dpnp.ndarray</span>
<span class="sd">        Least-squares solution. If `b` is two-dimensional,</span>
<span class="sd">        the solutions are in the `K` columns of `x`.</span>
<span class="sd">    residuals : {(1,), (K,), (0,)} dpnp.ndarray</span>
<span class="sd">        Sums of squared residuals: Squared Euclidean 2-norm for each column in</span>
<span class="sd">        ``b - a @ x``.</span>
<span class="sd">        If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.</span>
<span class="sd">        If `b` is 1-dimensional, this is a (1,) shape array.</span>
<span class="sd">        Otherwise the shape is (K,).</span>
<span class="sd">    rank : int</span>
<span class="sd">        Rank of matrix `a`.</span>
<span class="sd">    s : (min(M, N),) dpnp.ndarray</span>
<span class="sd">        Singular values of `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Fit a line, ``y = mx + c``, through some noisy data-points:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])</span>

<span class="sd">    By examining the coefficients, we see that the line should have a</span>
<span class="sd">    gradient of roughly 1 and cut the y-axis at, more or less, -1.</span>

<span class="sd">    We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``</span>
<span class="sd">    and ``p = [[m], [c]]``. Now use `lstsq` to solve for `p`:</span>

<span class="sd">    &gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[0., 1.],</span>
<span class="sd">           [1., 1.],</span>
<span class="sd">           [2., 1.],</span>
<span class="sd">           [3., 1.]])</span>

<span class="sd">    &gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]</span>
<span class="sd">    &gt;&gt;&gt; m, c</span>
<span class="sd">    (array(1.), array(-0.95)) # may vary</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">assert_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rcond</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;rcond must be integer, floating type, or None&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_lstsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">)</span></div>



<div class="viewcode-block" id="matmul">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.matmul.html#dpnp.linalg.matmul">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matmul</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the matrix product.</span>

<span class="sd">    This function is Array API compatible, contrary to :obj:`dpnp.matmul`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.matmul`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2 : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Second input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Returns the matrix product of the inputs.</span>
<span class="sd">        This is a 0-d array only when both `x1`, `x2` are 1-d vectors.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.matmul` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For 2-D arrays it is the matrix product:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0], [0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(a, b)</span>
<span class="sd">    array([[4, 1],</span>
<span class="sd">           [2, 2]])</span>

<span class="sd">    For 2-D mixed with 1-D, the result is the usual.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0], [0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(a, b)</span>
<span class="sd">    array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(b, a)</span>
<span class="sd">    array([1, 2])</span>

<span class="sd">    Broadcasting is conventional for stacks of arrays</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(2 * 2 * 4).reshape((2, 2, 4))</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(2 * 2 * 4).reshape((2, 4, 2))</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(a, b).shape</span>
<span class="sd">    (2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(a, b)[0, 1, 1]</span>
<span class="sd">    array(98)</span>
<span class="sd">    &gt;&gt;&gt; np.sum(a[0, 1, :] * b[0 , :, 1])</span>
<span class="sd">    array(98)</span>

<span class="sd">    Vector, vector returns the scalar inner product, but neither argument</span>
<span class="sd">    is complex-conjugated:</span>

<span class="sd">    &gt;&gt;&gt; x1 = np.array([2j, 3j])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.array([2j, 3j])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matmul(x1, x2)</span>
<span class="sd">    array(-13+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_norm">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.matrix_norm.html#dpnp.linalg.matrix_norm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="s2">&quot;fro&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the matrix norm of a matrix (or a stack of matrices) `x`.</span>

<span class="sd">    This function is Array API compatible.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.matrix_norm`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array having shape (..., M, N) and whose two innermost</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    keepdims : {None, bool}, optional</span>
<span class="sd">        If this is set to ``True``, the axes which are normed over are left in</span>
<span class="sd">        the result as dimensions with size one. With this option the result</span>
<span class="sd">        will broadcast correctly against the original `x`.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    ord : {None, 1, -1, 2, -2, dpnp.inf, -dpnp.inf, &#39;fro&#39;, &#39;nuc&#39;}, optional</span>
<span class="sd">        The order of the norm. For details see the table under ``Notes``</span>
<span class="sd">        section in :obj:`dpnp.linalg.norm`.</span>

<span class="sd">        Default: ``&quot;fro&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Norm of the matrix.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.norm` : Generic norm function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9) - 4</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-4, -3, -2, -1,  0,  1,  2,  3,  4])</span>
<span class="sd">    &gt;&gt;&gt; b = a.reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[-4, -3, -2],</span>
<span class="sd">           [-1,  0,  1],</span>
<span class="sd">           [ 2,  3,  4]])</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=&#39;fro&#39;)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=np.inf)</span>
<span class="sd">    array(9.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=-np.inf)</span>
<span class="sd">    array(2.)</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=1)</span>
<span class="sd">    array(7.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=-1)</span>
<span class="sd">    array(6.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=2)</span>
<span class="sd">    array(7.34846923)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_norm(b, ord=-2)</span>
<span class="sd">    array(4.35106603e-18) # may vary</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_power">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.matrix_power.html#dpnp.linalg.matrix_power">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raise a square matrix to the (integer) power `n`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.matrix_power`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Matrix to be &quot;powered&quot;.</span>
<span class="sd">    n : int</span>
<span class="sd">        The exponent can be any integer or long integer, positive, negative,</span>
<span class="sd">        or zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a**n : (..., M, M) dpnp.ndarray</span>
<span class="sd">        The return value is the same shape and type as `M`;</span>
<span class="sd">        if the exponent is positive or zero then the type of the</span>
<span class="sd">        elements is the same as those of `M`. If the exponent is</span>
<span class="sd">        negative the elements are floating-point.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_power(i, 3) # should = -i</span>
<span class="sd">    array([[ 0, -1],</span>
<span class="sd">           [ 1,  0]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_power(i, 0)</span>
<span class="sd">    array([[1, 0],</span>
<span class="sd">           [0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_power(i, -3) # should 1/(-i) = i, but w/ f.p. elements</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [-1.,  0.]])</span>

<span class="sd">    Somewhat more sophisticated example</span>

<span class="sd">    &gt;&gt;&gt; q = np.zeros((4, 4))</span>
<span class="sd">    &gt;&gt;&gt; q[0:2, 0:2] = -i</span>
<span class="sd">    &gt;&gt;&gt; q[2:4, 2:4] = i</span>
<span class="sd">    &gt;&gt;&gt; q # one of the three quaternion units not equal to 1</span>
<span class="sd">    array([[ 0., -1.,  0.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  1.],</span>
<span class="sd">           [ 0.,  0., -1.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_power(q, 2) # = -np.eye(4)</span>
<span class="sd">    array([[-1.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0., -1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0., -1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0., -1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;exponent must be an integer&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_matrix_power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_rank">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.matrix_rank.html#dpnp.linalg.matrix_rank">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_rank</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return matrix rank of array using SVD method.</span>

<span class="sd">    Rank of the array is the number of singular values of the array that are</span>
<span class="sd">    greater than `tol`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : {(M,), (..., M, N)} {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input vector or stack of matrices.</span>
<span class="sd">    tol : (...) {None, float, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        Threshold below which SVD values are considered zero. Only `tol` or</span>
<span class="sd">        `rtol` can be set at a time. If none of them are provided, defaults</span>
<span class="sd">        to ``S.max() * max(M, N) * eps`` where `S` is an array with singular</span>
<span class="sd">        values for `A`, and `eps` is the epsilon value for datatype of `S`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    hermitian : bool, optional</span>
<span class="sd">        If ``True``, `A` is assumed to be Hermitian (symmetric if real-valued),</span>
<span class="sd">        enabling a more efficient method for finding singular values.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    rtol : (...) {None, float, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        Parameter for the relative tolerance component. Only `tol` or `rtol`</span>
<span class="sd">        can be set at a time. If none of them are provided, defaults to</span>
<span class="sd">        ``max(M, N) * eps`` where `eps` is the epsilon value for datatype</span>
<span class="sd">        of `S` (an array with singular values for `A`).</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rank : (...) dpnp.ndarray</span>
<span class="sd">        Rank of `A`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.svd` : Singular Value Decomposition.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; from dpnp.linalg import matrix_rank</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix</span>
<span class="sd">    array(4)</span>
<span class="sd">    &gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(I)</span>
<span class="sd">    array(3)</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0</span>
<span class="sd">    array(1)</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.zeros((4,)))</span>
<span class="sd">    array(0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span>
            <span class="n">tol</span><span class="p">,</span> <span class="n">scalar_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_scalars</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">rtol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span>
            <span class="n">rtol</span><span class="p">,</span> <span class="n">scalar_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_scalars</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_matrix_rank</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span></div>



<div class="viewcode-block" id="matrix_transpose">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.matrix_transpose.html#dpnp.linalg.matrix_transpose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">matrix_transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transposes a matrix (or a stack of matrices) `x`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.matrix_transpose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array with ``x.ndim &gt;= 2`` and whose two innermost</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array containing the transpose for each matrix and having shape</span>
<span class="sd">        (..., N, M).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.transpose` : Returns an array with axes transposed.</span>
<span class="sd">    :obj:`dpnp.matrix_transpose` : Equivalent function.</span>
<span class="sd">    :obj:`dpnp.ndarray.mT` : Equivalent method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_transpose(a)</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [2, 4]])</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.matrix_transpose(b)</span>
<span class="sd">    array([[[1, 3],</span>
<span class="sd">            [2, 4]],</span>
<span class="sd">           [[5, 7],</span>
<span class="sd">            [6, 8]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">matrix_transpose</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>



<div class="viewcode-block" id="multi_dot">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.multi_dot.html#dpnp.linalg.multi_dot">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the dot product of two or more arrays in a single function call.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.multi_dot`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : sequence of dpnp.ndarray or usm_ndarray</span>
<span class="sd">        If the first argument is 1-D it is treated as row vector.</span>
<span class="sd">        If the last argument is 1-D it is treated as column vector.</span>
<span class="sd">        The other arguments must be 2-D.</span>
<span class="sd">    out : {None, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        Output argument. This must have the exact kind that would be returned</span>
<span class="sd">        if it was not used. In particular, it must have the right type, must be</span>
<span class="sd">        C-contiguous, and its dtype must be the dtype that would be returned</span>
<span class="sd">        for `dot(a, b)`. If these conditions are not met, an exception is</span>
<span class="sd">        raised, instead of attempting to be flexible.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Returns the dot product of the supplied arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.dot` : Returns the dot product of two arrays.</span>
<span class="sd">    :obj:`dpnp.inner` : Returns the inner product of two arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; from dpnp.linalg import multi_dot</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.random((10000, 100))</span>
<span class="sd">    &gt;&gt;&gt; B = np.random.random((100, 1000))</span>
<span class="sd">    &gt;&gt;&gt; C = np.random.random((1000, 5))</span>
<span class="sd">    &gt;&gt;&gt; D = np.random.random((5, 333))</span>

<span class="sd">    the actual dot multiplication</span>

<span class="sd">    &gt;&gt;&gt; multi_dot([A, B, C, D]).shape</span>
<span class="sd">    (10000, 333)</span>

<span class="sd">    instead of</span>

<span class="sd">    &gt;&gt;&gt; np.dot(np.dot(np.dot(A, B), C), D).shape</span>
<span class="sd">    (10000, 333)</span>

<span class="sd">    or</span>

<span class="sd">    &gt;&gt;&gt; A.dot(B).dot(C).dot(D).shape</span>
<span class="sd">    (10000, 333)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting at least two arrays.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_multi_dot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="norm">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.norm.html#dpnp.linalg.norm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix or vector norm.</span>

<span class="sd">    This function is able to return one of eight different matrix norms,</span>
<span class="sd">    or one of an infinite number of vector norms (described below), depending</span>
<span class="sd">    on the value of the ``ord`` parameter.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.norm`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array. If `axis` is ``None``, `x` must be 1-D or 2-D, unless</span>
<span class="sd">        `ord` is ``None``. If both `axis` and `ord` are ``None``, the 2-norm</span>
<span class="sd">        of ``x.ravel`` will be returned.</span>
<span class="sd">    ord : {int, float, inf, -inf, &quot;fro&quot;, &quot;nuc&quot;}, optional</span>
<span class="sd">        Norm type. inf means dpnp&#39;s `inf` object.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    axis : {None, int, 2-tuple of ints}, optional</span>
<span class="sd">        If `axis` is an integer, it specifies the axis of `x` along which to</span>
<span class="sd">        compute the vector norms. If `axis` is a 2-tuple, it specifies the</span>
<span class="sd">        axes that hold 2-D matrices, and the matrix norms of these matrices</span>
<span class="sd">        are computed. If `axis` is ``None`` then either a vector norm (when</span>
<span class="sd">        `x` is 1-D) or a matrix norm (when `x` is 2-D) is returned.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    keepdims : {None, bool}, optional</span>
<span class="sd">        If this is set to ``True``, the axes which are normed over are left in</span>
<span class="sd">        the result as dimensions with size one. With this option the result</span>
<span class="sd">        will broadcast correctly against the original `x`.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Norm of the matrix or vector(s).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.matrix_norm` : Computes the matrix norm of a matrix.</span>
<span class="sd">    :obj:`dpnp.linalg.vector_norm` : Computes the vector norm of a vector.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For values of ``ord &lt; 1``, the result is, strictly speaking, not a</span>
<span class="sd">    mathematical &#39;norm&#39;, but it may still be useful for various numerical</span>
<span class="sd">    purposes.</span>

<span class="sd">    The following norms can be calculated:</span>

<span class="sd">    =====  ============================  ==========================</span>
<span class="sd">    ord    norm for matrices             norm for vectors</span>
<span class="sd">    =====  ============================  ==========================</span>
<span class="sd">    None   Frobenius norm                2-norm</span>
<span class="sd">    &#39;fro&#39;  Frobenius norm                --</span>
<span class="sd">    &#39;nuc&#39;  nuclear norm                  --</span>
<span class="sd">    inf    max(sum(abs(x), axis=1))      max(abs(x))</span>
<span class="sd">    -inf   min(sum(abs(x), axis=1))      min(abs(x))</span>
<span class="sd">    0      --                            sum(x != 0)</span>
<span class="sd">    1      max(sum(abs(x), axis=0))      as below</span>
<span class="sd">    -1     min(sum(abs(x), axis=0))      as below</span>
<span class="sd">    2      2-norm (largest sing. value)  as below</span>
<span class="sd">    -2     smallest singular value       as below</span>
<span class="sd">    other  --                            sum(abs(x)**ord)**(1./ord)</span>
<span class="sd">    =====  ============================  ==========================</span>

<span class="sd">    The Frobenius norm is given by [1]_:</span>

<span class="sd">    :math:`||A||_F = [\sum_{i, j} abs(a_{i, j})^2]^{1/2}`</span>

<span class="sd">    The nuclear norm is the sum of the singular values.</span>

<span class="sd">    Both the Frobenius and nuclear norm orders are only defined for</span>
<span class="sd">    matrices and raise a ValueError when ``x.ndim != 2``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,</span>
<span class="sd">           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9) - 4</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-4, -3, -2, -1,  0,  1,  2,  3,  4])</span>
<span class="sd">    &gt;&gt;&gt; b = a.reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[-4, -3, -2],</span>
<span class="sd">           [-1,  0,  1],</span>
<span class="sd">           [ 2,  3,  4]])</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, &#39;fro&#39;)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, np.inf)</span>
<span class="sd">    array(4.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, np.inf)</span>
<span class="sd">    array(9.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, -np.inf)</span>
<span class="sd">    array(0.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, -np.inf)</span>
<span class="sd">    array(2.)</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, 1)</span>
<span class="sd">    array(20.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, 1)</span>
<span class="sd">    array(7.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, -1)</span>
<span class="sd">    array(0.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, -1)</span>
<span class="sd">    array(6.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, 2)</span>
<span class="sd">    array(7.74596669)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, 2)</span>
<span class="sd">    array(7.34846923)</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, -2)</span>
<span class="sd">    array(0.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(b, -2)</span>
<span class="sd">    array(4.35106603e-18) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, 3)</span>
<span class="sd">    array(5.84803548) # may vary</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(a, -3)</span>
<span class="sd">    array(0.)</span>

<span class="sd">    Using the `axis` argument to compute vector norms:</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([[ 1, 2, 3],</span>
<span class="sd">    ...               [-1, 1, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(c, axis=0)</span>
<span class="sd">    array([ 1.41421356,  2.23606798,  5.        ])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(c, axis=1)</span>
<span class="sd">    array([ 3.74165739,  4.24264069])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(c, ord=1, axis=1)</span>
<span class="sd">    array([ 6.,  6.])</span>

<span class="sd">    Using the `axis` argument to compute matrix norms:</span>

<span class="sd">    &gt;&gt;&gt; m = np.arange(8).reshape(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(m, axis=(1, 2))</span>
<span class="sd">    array([  3.74165739,  11.22497216])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.norm(m[0, :, :]), np.linalg.norm(m[1, :, :])</span>
<span class="sd">    (array(3.74165739), array(11.22497216))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">)</span></div>



<div class="viewcode-block" id="outer">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.outer.html#dpnp.linalg.outer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">outer</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the outer product of two vectors.</span>

<span class="sd">    This function is Array API compatible. Compared to :obj:`dpnp.outer`,</span>
<span class="sd">    it accepts 1-dimensional inputs only.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.outer`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M,) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One-dimensional input array of size ``M``.</span>
<span class="sd">        Must have a numeric data type.</span>
<span class="sd">    b : (N,) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        One-dimensional input array of size ``N``.</span>
<span class="sd">        Must have a numeric data type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (M, N) dpnp.ndarray</span>
<span class="sd">        ``out[i, j] = a[i] * b[j]``</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.outer` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.outer(a, b)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [1, 2, 3],</span>
<span class="sd">           [1, 2, 3]])</span>

<span class="sd">    Make a (*very* coarse) grid for computing a Mandelbrot set:</span>

<span class="sd">    &gt;&gt;&gt; rl = np.linalg.outer(np.ones((5,)), np.linspace(-2, 2, 5))</span>
<span class="sd">    &gt;&gt;&gt; rl</span>
<span class="sd">    array([[-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.],</span>
<span class="sd">           [-2., -1.,  0.,  1.,  2.]])</span>
<span class="sd">    &gt;&gt;&gt; im = np.linalg.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))</span>
<span class="sd">    &gt;&gt;&gt; im</span>
<span class="sd">    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],</span>
<span class="sd">           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],</span>
<span class="sd">           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],</span>
<span class="sd">           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],</span>
<span class="sd">           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])</span>
<span class="sd">    &gt;&gt;&gt; grid = rl + im</span>
<span class="sd">    &gt;&gt;&gt; grid</span>
<span class="sd">    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],</span>
<span class="sd">           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],</span>
<span class="sd">           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],</span>
<span class="sd">           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],</span>
<span class="sd">           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">x2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Input arrays must be one-dimensional, but they are &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">x1</span><span class="o">.</span><span class="n">ndim</span><span class="si">=}</span><span class="s2"> and </span><span class="si">{</span><span class="n">x2</span><span class="o">.</span><span class="n">ndim</span><span class="si">=}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>



<div class="viewcode-block" id="pinv">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.pinv.html#dpnp.linalg.pinv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span>

<span class="sd">    Calculate the generalized inverse of a matrix using its</span>
<span class="sd">    singular-value decomposition (SVD) and including all large singular values.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.inv`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Matrix or stack of matrices to be pseudo-inverted.</span>
<span class="sd">    rcond : (...) {None, float, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        Cutoff for small singular values.</span>
<span class="sd">        Singular values less than or equal to ``rcond * largest_singular_value``</span>
<span class="sd">        are set to zero. Broadcasts against the stack of matrices.</span>
<span class="sd">        Only `rcond` or `rtol` can be set at a time. If none of them are</span>
<span class="sd">        provided, defaults to ``max(M, N) * dpnp.finfo(a.dtype).eps``.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    hermitian : bool, optional</span>
<span class="sd">        If ``True``, a is assumed to be Hermitian (symmetric if real-valued),</span>
<span class="sd">        enabling a more efficient method for finding singular values.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    rtol : (...) {None, float, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        Same as `rcond`, but it&#39;s an Array API compatible parameter name.</span>
<span class="sd">        Only `rcond` or `rtol` can be set at a time. If none of them are</span>
<span class="sd">        provided, defaults to ``max(M, N) * dpnp.finfo(a.dtype).eps``.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (..., N, M) dpnp.ndarray</span>
<span class="sd">        The pseudo-inverse of `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following example checks that ``a * a+ * a == a`` and</span>
<span class="sd">    ``a+ * a * a+ == a+``:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span>
<span class="sd">    &gt;&gt;&gt; B = np.linalg.pinv(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))</span>
<span class="sd">    array(True)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))</span>
<span class="sd">    array(True)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span>
            <span class="n">rcond</span><span class="p">,</span> <span class="n">scalar_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_scalars</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">rtol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span>
            <span class="n">rtol</span><span class="p">,</span> <span class="n">scalar_type</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">all_scalars</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_pinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="n">rcond</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="n">hermitian</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">)</span></div>



<div class="viewcode-block" id="qr">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.qr.html#dpnp.linalg.qr">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reduced&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the qr factorization of a matrix.</span>

<span class="sd">    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is</span>
<span class="sd">    upper-triangular.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.qr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The input array with the dimensionality of at least 2.</span>
<span class="sd">    mode : {&quot;reduced&quot;, &quot;complete&quot;, &quot;r&quot;, &quot;raw&quot;}, optional</span>
<span class="sd">        If K = min(M, N), then</span>

<span class="sd">        - &quot;reduced&quot; : returns Q, R with dimensions (, M, K), (, K, N)</span>
<span class="sd">        - &quot;complete&quot; : returns Q, R with dimensions (, M, M), (, M, N)</span>
<span class="sd">        - &quot;r&quot; : returns R only with dimensions (, K, N)</span>
<span class="sd">        - &quot;raw&quot; : returns h, tau with dimensions (, N, M), (, K,)</span>

<span class="sd">        Default: ``&quot;reduced&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    When mode is &quot;reduced&quot; or &quot;complete&quot;, the result will be a namedtuple with</span>
<span class="sd">    the attributes `Q` and `R`:</span>

<span class="sd">    Q : dpnp.ndarray of float or complex, optional</span>
<span class="sd">        A matrix with orthonormal columns.</span>
<span class="sd">        When mode is ``&quot;complete&quot;`` the result is an orthogonal/unitary matrix</span>
<span class="sd">        depending on whether or not `a` is real/complex. The determinant may be</span>
<span class="sd">        either ``+/- 1`` in that case. In case the number of dimensions in the</span>
<span class="sd">        input array is greater than 2 then a stack of the matrices with above</span>
<span class="sd">        properties is returned.</span>
<span class="sd">    R : dpnp.ndarray of float or complex, optional</span>
<span class="sd">        The upper-triangular matrix or a stack of upper-triangular matrices if</span>
<span class="sd">        the number of dimensions in the input array is greater than 2.</span>
<span class="sd">    (h, tau) : tuple of dpnp.ndarray of float or complex, optional</span>
<span class="sd">        The array `h` contains the Householder reflectors that generate `Q`</span>
<span class="sd">        along with `R`. The `tau` array contains scaling factors for the</span>
<span class="sd">        reflectors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span>
<span class="sd">    &gt;&gt;&gt; Q, R = np.linalg.qr(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(Q, R))  # a does equal QR</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; R2 = np.linalg.qr(a, mode=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(R, R2)  # mode=&#39;r&#39; returns the same R as mode=&#39;full&#39;</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.normal(size=(3, 2, 2)) # Stack of 2 x 2 matrices as input</span>
<span class="sd">    &gt;&gt;&gt; Q, R = np.linalg.qr(a)</span>
<span class="sd">    &gt;&gt;&gt; Q.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; R.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.matmul(Q, R))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;reduced&quot;</span><span class="p">,</span> <span class="s2">&quot;complete&quot;</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<div class="viewcode-block" id="solve">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.solve.html#dpnp.linalg.solve">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve a linear matrix equation, or system of linear scalar equations.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.solve`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Coefficient matrix.</span>
<span class="sd">    b : {(M,), (..., M, K)} {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Ordinate or &quot;dependent variable&quot; values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : {(..., M,), (..., M, K)} dpnp.ndarray</span>
<span class="sd">        Solution to the system `ax = b`. Returned shape is identical to `b`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.dot` : Returns the dot product of two arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `b` array is only treated as a shape (M,) column vector if it is</span>
<span class="sd">    exactly 1-dimensional. In all other instances it is treated as a stack</span>
<span class="sd">    of (M, K) matrices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as dp</span>
<span class="sd">    &gt;&gt;&gt; a = dp.array([[1, 2], [3, 5]])</span>
<span class="sd">    &gt;&gt;&gt; b = dp.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; x = dp.linalg.solve(a, b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([-1.,  1.])</span>

<span class="sd">    Check that the solution is correct:</span>

<span class="sd">    &gt;&gt;&gt; dp.allclose(dp.dot(a, x), b)</span>
<span class="sd">    array([ True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">b_shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span>

    <span class="c1"># compatible with numpy&gt;=2.0</span>
    <span class="k">if</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;b must have at least one dimension&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;a must have (..., M, M) shape and b must have (M,) &quot;</span>
                <span class="s2">&quot;for one-dimensional b&quot;</span>
            <span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">dpnp_solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;a must have (..., M, M) shape and b must have (..., M, K) shape&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Use dpnp.broadcast_shapes() to align the resulting batch shapes</span>
    <span class="n">broadcasted_batch_shape</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">b_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">a_broadcasted_shape</span> <span class="o">=</span> <span class="n">broadcasted_batch_shape</span> <span class="o">+</span> <span class="n">a_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">b_broadcasted_shape</span> <span class="o">=</span> <span class="n">broadcasted_batch_shape</span> <span class="o">+</span> <span class="n">b_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">a_shape</span> <span class="o">!=</span> <span class="n">a_broadcasted_shape</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a_broadcasted_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b_shape</span> <span class="o">!=</span> <span class="n">b_broadcasted_shape</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b_broadcasted_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>



<div class="viewcode-block" id="svd">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.svd.html#dpnp.linalg.svd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Singular Value Decomposition.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.svd`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array with ``a.ndim &gt;= 2``.</span>
<span class="sd">    full_matrices : {bool}, optional</span>
<span class="sd">        If ``True``, it returns `u` and `Vh` with full-sized matrices.</span>
<span class="sd">        If ``False``, the matrices are reduced in size.</span>

<span class="sd">        Default: ``True``.</span>
<span class="sd">    compute_uv : {bool}, optional</span>
<span class="sd">        If ``False``, it only returns singular values.</span>

<span class="sd">        Default: ``True``.</span>
<span class="sd">    hermitian : {bool}, optional</span>
<span class="sd">        If True, a is assumed to be Hermitian (symmetric if real-valued),</span>
<span class="sd">        enabling a more efficient method for finding singular values.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    When `compute_uv` is ``True``, the result is a namedtuple with the</span>
<span class="sd">    following attribute names:</span>

<span class="sd">    U : { (, M, M), (, M, K) } dpnp.ndarray</span>
<span class="sd">        Unitary matrix, where M is the number of rows of the input array `a`.</span>
<span class="sd">        The shape of the matrix `U` depends on the value of `full_matrices`.</span>
<span class="sd">        If `full_matrices` is ``True``, `U` has the shape (, M, M). If</span>
<span class="sd">        `full_matrices` is ``False``, `U` has the shape (, M, K), where</span>
<span class="sd">        ``K = min(M, N)``, and N is the number of columns of the input array</span>
<span class="sd">        `a`. If `compute_uv` is ``False``, neither `U` or `Vh` are computed.</span>
<span class="sd">    S : (, K) dpnp.ndarray</span>
<span class="sd">        Vector containing the singular values of `a`, sorted in descending</span>
<span class="sd">        order. The length of `S` is min(M, N).</span>
<span class="sd">    Vh : { (, N, N), (, K, N) } dpnp.ndarray</span>
<span class="sd">        Unitary matrix, where N is the number of columns of the input array `a`.</span>
<span class="sd">        The shape of the matrix `Vh` depends on the value of `full_matrices`.</span>
<span class="sd">        If `full_matrices` is ``True``, `Vh` has the shape (, N, N).</span>
<span class="sd">        If `full_matrices` is ``False``, `Vh` has the shape (, K, N).</span>
<span class="sd">        If `compute_uv` is ``False``, neither `U` or `Vh` are computed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)</span>

<span class="sd">    Reconstruction based on full SVD, 2D case:</span>

<span class="sd">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=True)</span>
<span class="sd">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span>
<span class="sd">    ((9, 9), (6,), (6, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(u[:, :6] * s, vh))</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; smat = np.zeros((9, 6), dtype=complex)</span>
<span class="sd">    &gt;&gt;&gt; smat[:6, :6] = np.diag(s)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    Reconstruction based on reduced SVD, 2D case:</span>

<span class="sd">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=False)</span>
<span class="sd">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span>
<span class="sd">    ((9, 6), (6,), (6, 6))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(u * s, vh))</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; smat = np.diag(s)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    Reconstruction based on full SVD, 4D case:</span>

<span class="sd">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=True)</span>
<span class="sd">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span>
<span class="sd">    ((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    Reconstruction based on reduced SVD, 4D case:</span>

<span class="sd">    &gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=False)</span>
<span class="sd">    &gt;&gt;&gt; u.shape, s.shape, vh.shape</span>
<span class="sd">    ((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(b, np.matmul(u * s[..., None, :], vh))</span>
<span class="sd">    array([ True])</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(b, np.matmul(u, s[..., None] * vh))</span>
<span class="sd">    array([ True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">,</span> <span class="n">hermitian</span><span class="p">)</span></div>



<div class="viewcode-block" id="svdvals">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.svdvals.html#dpnp.linalg.svdvals">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">svdvals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the singular values of a matrix (or a stack of matrices) `x`.</span>

<span class="sd">    When `x` is a stack of matrices, the function will compute</span>
<span class="sd">    the singular values for each matrix in the stack.</span>

<span class="sd">    Calling ``dpnp.linalg.svdvals(x)`` to get singular values is the same as</span>
<span class="sd">    ``dpnp.linalg.svd(x, compute_uv=False, hermitian=False)``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.svdvals`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array with ``x.ndim &gt;= 2`` and whose last two dimensions</span>
<span class="sd">        form matrices on which to perform singular value decomposition.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : (..., K) dpnp.ndarray</span>
<span class="sd">        Vector(s) of singular values of length K, where K = min(M, N).</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.svd` : Compute the singular value decomposition.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[3, 0], [0, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.svdvals(a)</span>
<span class="sd">    array([4., 3.])</span>

<span class="sd">    This is equivalent to calling:</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.svd(a, compute_uv=False, hermitian=False)</span>
<span class="sd">    array([4., 3.])</span>

<span class="sd">    Stack of matrices:</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[[6, 0], [0, 8]], [[9, 0], [0, 12]]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.svdvals(b)</span>
<span class="sd">    array([[ 8.,  6.],</span>
<span class="sd">           [12.,  9.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_svd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="slogdet">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.slogdet.html#dpnp.linalg.slogdet">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">slogdet</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the sign and (natural) logarithm of the determinant of an array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.slogdet`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array, has to be a square 2-D array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A namedtuple with the following attributes:</span>

<span class="sd">    sign : (...) dpnp.ndarray</span>
<span class="sd">        A number representing the sign of the determinant. For a real matrix,</span>
<span class="sd">        this is 1, 0, or -1. For a complex matrix, this is a complex number</span>
<span class="sd">        with absolute value 1 (i.e., it is on the unit circle), or else 0.</span>
<span class="sd">    logabsdet : (...) dpnp.ndarray</span>
<span class="sd">        The natural log of the absolute value of the determinant.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.det` : Returns the determinant of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as dp</span>
<span class="sd">    &gt;&gt;&gt; a = dp.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; (sign, logabsdet) = dp.linalg.slogdet(a)</span>
<span class="sd">    &gt;&gt;&gt; (sign, logabsdet)</span>
<span class="sd">    (array(-1.), array(0.69314718))</span>
<span class="sd">    &gt;&gt;&gt; sign * dp.exp(logabsdet)</span>
<span class="sd">    array(-2.)</span>

<span class="sd">    Computing log-determinants for a stack of matrices:</span>

<span class="sd">    &gt;&gt;&gt; a = dp.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; sign, logabsdet = dp.linalg.slogdet(a)</span>
<span class="sd">    &gt;&gt;&gt; (sign, logabsdet)</span>
<span class="sd">    (array([-1., -1., -1.]), array([0.69314718, 1.09861229, 2.07944154]))</span>
<span class="sd">    &gt;&gt;&gt; sign * dp.exp(logabsdet)</span>
<span class="sd">    array([-2., -3., -8.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">assert_stacked_square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_slogdet</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>



<div class="viewcode-block" id="tensordot">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.tensordot.html#dpnp.linalg.tensordot">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute tensor dot product along specified axes.</span>

<span class="sd">    Given two tensors, `a` and `b`, and an array_like object containing</span>
<span class="sd">    two array_like objects, ``(a_axes, b_axes)``, sum the products of</span>
<span class="sd">    `a`&#39;s and `b`&#39;s elements (components) over the axes specified by</span>
<span class="sd">    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative</span>
<span class="sd">    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions</span>
<span class="sd">    of `a` and the first ``N`` dimensions of `b` are summed over.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.tensordot`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray, scalar}</span>
<span class="sd">        First input array. Both inputs `a` and `b` can not be scalars</span>
<span class="sd">        at the same time.</span>
<span class="sd">    b : {dpnp.ndarray, usm_ndarray, scalar}</span>
<span class="sd">        Second input array. Both inputs `a` and `b` can not be scalars</span>
<span class="sd">        at the same time.</span>
<span class="sd">    axes : int or (2,) array_like</span>
<span class="sd">        * integer_like: If an int `N`, sum over the last `N` axes of `a` and</span>
<span class="sd">          the first `N` axes of `b` in order. The sizes of the corresponding</span>
<span class="sd">          axes must match.</span>
<span class="sd">        * (2,) array_like: A list of axes to be summed over, first sequence</span>
<span class="sd">          applying to `a`, second to `b`. Both elements array_like must be of</span>
<span class="sd">          the same length.</span>

<span class="sd">          Default: ``2``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Returns the tensor dot product of `a` and `b`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.tensordot` : Equivalent function.</span>
<span class="sd">    :obj:`dpnp.dot` : Returns the dot product.</span>
<span class="sd">    :obj:`dpnp.einsum` : Evaluates the Einstein summation convention</span>
<span class="sd">                         on the operands.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Three common use cases are:</span>
<span class="sd">        * ``axes = 0`` : tensor product :math:`a \otimes b`</span>
<span class="sd">        * ``axes = 1`` : tensor dot product :math:`a \cdot b`</span>
<span class="sd">        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`</span>

<span class="sd">    When `axes` is integer, the sequence for evaluation will be: first</span>
<span class="sd">    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and</span>
<span class="sd">    Nth axis in `b` last.</span>

<span class="sd">    When there is more than one axis to sum over - and they are not the last</span>
<span class="sd">    (first) axes of `a` (`b`) - the argument `axes` should consist of</span>
<span class="sd">    two sequences of the same length, with the first axis to sum over given</span>
<span class="sd">    first in both sequences, the second axis second, and so forth.</span>

<span class="sd">    The shape of the result consists of the non-contracted axes of the</span>
<span class="sd">    first tensor, followed by the non-contracted axes of the second.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.tensordot(a, b, axes=1)</span>
<span class="sd">    array([14, 32, 50])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(60.).reshape(3, 4, 5)</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(24.).reshape(4, 3, 2)</span>
<span class="sd">    &gt;&gt;&gt; c = np.linalg.tensordot(a, b, axes=([1, 0], [0, 1]))</span>
<span class="sd">    &gt;&gt;&gt; c.shape</span>
<span class="sd">    (5, 2)</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    array([[4400., 4730.],</span>
<span class="sd">           [4532., 4874.],</span>
<span class="sd">           [4664., 5018.],</span>
<span class="sd">           [4796., 5162.],</span>
<span class="sd">           [4928., 5306.]])</span>

<span class="sd">    A slower but equivalent way of computing the same...</span>

<span class="sd">    &gt;&gt;&gt; d = np.zeros((5, 2))</span>
<span class="sd">    &gt;&gt;&gt; for i in range(5):</span>
<span class="sd">    ...   for j in range(2):</span>
<span class="sd">    ...     for k in range(3):</span>
<span class="sd">    ...       for n in range(4):</span>
<span class="sd">    ...         d[i, j] += a[k, n, i] * b[n, k, j]</span>
<span class="sd">    &gt;&gt;&gt; c == d</span>
<span class="sd">    array([[ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True],</span>
<span class="sd">           [ True,  True]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span></div>



<div class="viewcode-block" id="tensorinv">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.tensorinv.html#dpnp.linalg.tensorinv">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tensorinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the &#39;inverse&#39; of an N-dimensional array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.tensorinv`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Tensor to `invert`. Its shape must be &#39;square&#39;, i. e.,</span>
<span class="sd">        ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.</span>
<span class="sd">    ind : int, optional</span>
<span class="sd">        Number of first indices that are involved in the inverse sum.</span>
<span class="sd">        Must be a positive integer.</span>

<span class="sd">        Default: ``2``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The inverse of a tensor whose shape is equivalent to</span>
<span class="sd">        ``a.shape[ind:] + a.shape[:ind]``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.tensordot` : Compute tensor dot product along specified</span>
<span class="sd">                                   axes.</span>
<span class="sd">    :obj:`dpnp.linalg.tensorsolve` : Solve the tensor equation</span>
<span class="sd">                                     ``a x = b`` for x.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(4*6)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (4, 6, 8, 3)</span>
<span class="sd">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)</span>
<span class="sd">    &gt;&gt;&gt; ainv.shape</span>
<span class="sd">    (8, 3, 4, 6)</span>

<span class="sd">    &gt;&gt;&gt; a = np.eye(4*6)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (24, 8, 3)</span>
<span class="sd">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)</span>
<span class="sd">    &gt;&gt;&gt; ainv.shape</span>
<span class="sd">    (8, 3, 24)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ind</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid ind argument&quot;</span><span class="p">)</span>

    <span class="n">old_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">inv_shape</span> <span class="o">=</span> <span class="n">old_shape</span><span class="p">[</span><span class="n">ind</span><span class="p">:]</span> <span class="o">+</span> <span class="n">old_shape</span><span class="p">[:</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">old_shape</span><span class="p">[</span><span class="n">ind</span><span class="p">:])</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">a_inv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a_inv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">inv_shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="tensorsolve">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.tensorsolve.html#dpnp.linalg.tensorsolve">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tensorsolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the tensor equation ``a x = b`` for x.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.tensorsolve`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals</span>
<span class="sd">        the shape of that sub-tensor of `a` consisting of the appropriate</span>
<span class="sd">        number of its rightmost indices, and must be such that</span>
<span class="sd">        ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be</span>
<span class="sd">        &#39;square&#39;).</span>
<span class="sd">    b : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Right-hand tensor, which can be of any shape.</span>
<span class="sd">    axes : {None, tuple of ints}, optional</span>
<span class="sd">        Axes in `a` to reorder to the right, before inversion.</span>
<span class="sd">        If ``None`` , no reordering is done.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The tensor with shape ``Q`` such that ``b.shape + Q == a.shape``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.tensordot` : Compute tensor dot product along specified</span>
<span class="sd">                                   axes.</span>
<span class="sd">    :obj:`dpnp.linalg.tensorinv` : Compute the &#39;inverse&#39; of an N-dimensional</span>
<span class="sd">                                   array.</span>
<span class="sd">    :obj:`dpnp.einsum` : Evaluates the Einstein summation convention on the</span>
<span class="sd">                         operands.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(2*3*4)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(2*3, 4)</span>
<span class="sd">    &gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)</span>
<span class="sd">    array([ True])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">all_axes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">all_axes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">all_axes</span><span class="p">))</span>

    <span class="n">old_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="p">:]</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">prod</span><span class="o">**</span><span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span>
            <span class="s2">&quot;Input arrays must satisfy the requirement &quot;</span>
            <span class="s2">&quot;prod(a.shape[b.ndim:]) == prod(a.shape[:b.ndim])&quot;</span>
        <span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prod</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">old_shape</span><span class="p">)</span></div>



<div class="viewcode-block" id="trace">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.trace.html#dpnp.linalg.trace">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the sum along the specified diagonals of a matrix</span>
<span class="sd">    (or a stack of matrices) `x`.</span>

<span class="sd">    This function is Array API compatible, contrary to :obj:`dpnp.trace`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.trace`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array having shape (..., M, N) and whose innermost two</span>
<span class="sd">        dimensions form ``MxN`` matrices.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset specifying the off-diagonal relative to the main diagonal,</span>
<span class="sd">        where:</span>

<span class="sd">            * offset = 0: the main diagonal.</span>
<span class="sd">            * offset &gt; 0: off-diagonal above the main diagonal.</span>
<span class="sd">            * offset &lt; 0: off-diagonal below the main diagonal.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        Determines the data-type of the returned array and of the accumulator</span>
<span class="sd">        where the elements are summed. If `dtype` has the value ``None`` and</span>
<span class="sd">        `a` is of integer type of precision less than the default integer</span>
<span class="sd">        precision, then the default integer precision is used. Otherwise, the</span>
<span class="sd">        precision is the same as that of `a`.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        An array containing the traces and whose shape is determined by</span>
<span class="sd">        removing the last two dimensions and storing the traces in the last</span>
<span class="sd">        array dimension. For example, if x has rank k and shape:</span>
<span class="sd">        (I, J, K, ..., L, M, N), then an output array has rank k-2 and shape:</span>
<span class="sd">        (I, J, K, ..., L) where:</span>
<span class="sd">        ``out[i, j, k, ..., l] = dpnp.linalg.trace(a[i, j, k, ..., l, :, :])``</span>

<span class="sd">        The returned array must have a data type as described by the dtype</span>
<span class="sd">        parameter above.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.trace` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(np.eye(3))</span>
<span class="sd">    array(3.)</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape((2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a)</span>
<span class="sd">    array([3, 11])</span>

<span class="sd">    Trace is computed with the last two axes as the 2-d sub-arrays.</span>
<span class="sd">    This behavior differs from :obj:`dpnp.trace` which uses the first two</span>
<span class="sd">    axes by default.</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(24).reshape((3, 2, 2, 2))</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a).shape</span>
<span class="sd">    (3, 2)</span>

<span class="sd">    Traces adjacent to the main diagonal can be obtained by using the</span>
<span class="sd">    `offset` argument:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape((3, 3)); a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a, offset=1)  # First superdiagonal</span>
<span class="sd">    array(6)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a, offset=2)  # Second superdiagonal</span>
<span class="sd">    array(2)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a, offset=-1)  # First subdiagonal</span>
<span class="sd">    array(10)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.trace(a, offset=-2)  # Second subdiagonal</span>
<span class="sd">    array(6)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>



<div class="viewcode-block" id="vecdot">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.vecdot.html#dpnp.linalg.vecdot">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vecdot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the vector dot product.</span>

<span class="sd">    This function is restricted to arguments compatible with the Array API,</span>
<span class="sd">    contrary to :obj:`dpnp.vecdot`.</span>

<span class="sd">    Let :math:`\mathbf{a}` be a vector in `x1` and :math:`\mathbf{b}` be</span>
<span class="sd">    a corresponding vector in `x2`. The dot product is defined as:</span>

<span class="sd">    .. math::</span>
<span class="sd">       \mathbf{a} \cdot \mathbf{b} = \sum_{i=0}^{n-1} \overline{a_i}b_i</span>

<span class="sd">    over the dimension specified by `axis` and where :math:`\overline{a_i}`</span>
<span class="sd">    denotes the complex conjugate if :math:`a_i` is complex and the identity</span>
<span class="sd">    otherwise.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.vecdot`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1 : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        First input array.</span>
<span class="sd">    x2 : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Second input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis over which to compute the dot product.</span>

<span class="sd">        Default: ``-1``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The vector dot product of the inputs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.vecdot` : Similar function with support for more</span>
<span class="sd">                    keyword arguments.</span>
<span class="sd">    :obj:`dpnp.vdot` : Complex-conjugating dot product.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Get the projected size along a given normal for an array of vectors.</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; v = np.array([[0., 5., 0.], [0., 0., 10.], [0., 6., 8.]])</span>
<span class="sd">    &gt;&gt;&gt; n = np.array([0., 0.6, 0.8])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vecdot(v, n)</span>
<span class="sd">    array([ 3.,  8., 10.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">vecdot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>



<div class="viewcode-block" id="vector_norm">
<a class="viewcode-back" href="../../../reference/generated/dpnp.linalg.vector_norm.html#dpnp.linalg.vector_norm">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vector_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the vector norm of a vector (or batch of vectors) `x`.</span>

<span class="sd">    This function is Array API compatible.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.linalg.vector_norm`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axis : {None, int, n-tuple of ints}, optional</span>
<span class="sd">        If an integer, `axis` specifies the axis (dimension) along which</span>
<span class="sd">        to compute vector norms. If an n-tuple, `axis` specifies the axes</span>
<span class="sd">        (dimensions) along which to compute batched vector norms. If ``None``,</span>
<span class="sd">        the vector norm must be computed over all array values (i.e.,</span>
<span class="sd">        equivalent to computing the vector norm of a flattened array).</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    keepdims : {None, bool}, optional</span>
<span class="sd">        If this is set to ``True``, the axes which are normed over are left in</span>
<span class="sd">        the result as dimensions with size one. With this option the result</span>
<span class="sd">        will broadcast correctly against the original `x`.</span>

<span class="sd">        Default: ``False``.</span>
<span class="sd">    ord : {int, float, inf, -inf, &#39;fro&#39;, &#39;nuc&#39;}, optional</span>
<span class="sd">        The order of the norm. For details see the table under ``Notes``</span>
<span class="sd">        section in :obj:`dpnp.linalg.norm`.</span>

<span class="sd">        Default: ``2``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Norm of the vector.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.norm` : Generic norm function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9) + 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; b = a.reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6],</span>
<span class="sd">           [7, 8, 9]])</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b)</span>
<span class="sd">    array(16.88194302)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=np.inf)</span>
<span class="sd">    array(9.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=-np.inf)</span>
<span class="sd">    array(1.)</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=1)</span>
<span class="sd">    array(45.)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=-1)</span>
<span class="sd">    array(0.35348576)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=2)</span>
<span class="sd">    array(16.881943016134134)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.vector_norm(b, ord=-2)</span>
<span class="sd">    array(0.8058837395885292)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">x_ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Note: dpnp.linalg.norm() doesn&#39;t handle 0-D arrays</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">_axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="c1"># Note: The axis argument supports any number of axes, whereas</span>
        <span class="c1"># dpnp.linalg.norm() only supports a single axis or two axes</span>
        <span class="c1"># for vector norm.</span>
        <span class="n">normalized_axis</span> <span class="o">=</span> <span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x_ndim</span><span class="p">)</span>
        <span class="n">rest</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">normalized_axis</span><span class="p">)</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="n">rest</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">newshape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="n">x_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                <span class="o">*</span><span class="p">[</span><span class="n">x_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rest</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">_axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_axis</span> <span class="o">=</span> <span class="n">axis</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">_axis</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="nb">ord</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="c1"># We can&#39;t reuse dpnp.linalg.norm(keepdims) because of the reshape hacks</span>
        <span class="c1"># above to avoid matrix norm logic.</span>
        <span class="n">_axis</span> <span class="o">=</span> <span class="n">normalize_axis_tuple</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">))</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">_axis</span><span class="p">:</span>
            <span class="n">x_shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">x_shape</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2025, Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>