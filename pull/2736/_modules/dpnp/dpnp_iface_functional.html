

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-554F8VNE28"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-554F8VNE28');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dpnp.dpnp_iface_functional &mdash; Data Parallel Extension for NumPy 0.20.0dev1+59.gcfb6064bb75 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=ae7f4d22"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Data Parallel Extension for NumPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start_guide.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Data Parallel Extension for NumPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dpnp.dpnp_iface_functional</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dpnp.dpnp_iface_functional</h1><div class="highlight"><pre>
<span></span><span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2024, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1"># - Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#   may be used to endorse or promote products derived from this software</span>
<span class="c1">#   without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interface of the functional programming routines part of the DPNP</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">This module is a face or public interface file for the library</span>
<span class="sd">it contains:</span>
<span class="sd"> - Interface functions</span>
<span class="sd"> - documentation for the functions</span>
<span class="sd"> - The functions parameters check</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=protected-access</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._numpy_helper</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">normalize_axis_index</span><span class="p">,</span>
    <span class="n">normalize_axis_tuple</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp</span>

<span class="c1"># pylint: disable=no-name-in-module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpnp.dpnp_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_usm_allocations</span>


<div class="viewcode-block" id="apply_along_axis">
<a class="viewcode-back" href="../../reference/generated/dpnp.apply_along_axis.html#dpnp.apply_along_axis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a function to 1-D slices along the given axis.</span>

<span class="sd">    Execute ``func1d(a, *args, **kwargs)`` where `func1d` operates on</span>
<span class="sd">    1-D arrays and `a` is a 1-D slice of `arr` along `axis`.</span>

<span class="sd">    This is equivalent to (but faster than) the following use of</span>
<span class="sd">    :obj:`dpnp.ndindex` and :obj:`dpnp.s_`, which sets each of</span>
<span class="sd">    ``ii``, ``jj``, and ``kk`` to a tuple of indices::</span>

<span class="sd">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span>
<span class="sd">        for ii in ndindex(Ni):</span>
<span class="sd">            for kk in ndindex(Nk):</span>
<span class="sd">                f = func1d(arr[ii + s_[:,] + kk])</span>
<span class="sd">                Nj = f.shape</span>
<span class="sd">                for jj in ndindex(Nj):</span>
<span class="sd">                    out[ii + jj + kk] = f[jj]</span>

<span class="sd">    Equivalently, eliminating the inner loop, this can be expressed as::</span>

<span class="sd">        Ni, Nk = a.shape[:axis], a.shape[axis+1:]</span>
<span class="sd">        for ii in ndindex(Ni):</span>
<span class="sd">            for kk in ndindex(Nk):</span>
<span class="sd">                out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])</span>

<span class="sd">    For full documentation refer to :obj:`numpy.apply_along_axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func1d : function (M,) -&gt; (Nj...)</span>
<span class="sd">        This function should accept 1-D arrays. It is applied to 1-D</span>
<span class="sd">        slices of `arr` along the specified axis.</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which `arr` is sliced.</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray} (Ni..., M, Nk...)</span>
<span class="sd">        Input array.</span>
<span class="sd">    args : any</span>
<span class="sd">        Additional arguments to `func1d`.</span>
<span class="sd">    kwargs : any</span>
<span class="sd">        Additional named arguments to `func1d`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray  (Ni..., Nj..., Nk...)</span>
<span class="sd">        The output array. The shape of `out` is identical to the shape of</span>
<span class="sd">        `arr`, except along the `axis` dimension. This axis is removed, and</span>
<span class="sd">        replaced with new dimensions equal to the shape of the return value</span>
<span class="sd">        of `func1d`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.apply_over_axes` : Apply a function repeatedly over</span>
<span class="sd">                                multiple axes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; def my_func(a): # Average first and last element of a 1-D array</span>
<span class="sd">    ...     return (a[0] + a[-1]) * 0.5</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.apply_along_axis(my_func, 0, b)</span>
<span class="sd">    array([4., 5., 6.])</span>
<span class="sd">    &gt;&gt;&gt; np.apply_along_axis(my_func, 1, b)</span>
<span class="sd">    array([2., 5., 8.])</span>

<span class="sd">    For a function that returns a 1D array, the number of dimensions in</span>
<span class="sd">    `out` is the same as `arr`.</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[8, 1, 7], [4, 3, 9], [5, 2, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.apply_along_axis(sorted, 1, b)</span>
<span class="sd">    array([[1, 7, 8],</span>
<span class="sd">           [3, 4, 9],</span>
<span class="sd">           [2, 5, 6]])</span>

<span class="sd">    For a function that returns a higher dimensional array, those dimensions</span>
<span class="sd">    are inserted in place of the `axis` dimension.</span>

<span class="sd">    &gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; np.apply_along_axis(np.diag, -1, b)</span>
<span class="sd">    array([[[1, 0, 0],</span>
<span class="sd">            [0, 2, 0],</span>
<span class="sd">            [0, 0, 3]],</span>
<span class="sd">           [[4, 0, 0],</span>
<span class="sd">            [0, 5, 0],</span>
<span class="sd">            [0, 0, 6]],</span>
<span class="sd">           [[7, 0, 0],</span>
<span class="sd">            [0, 8, 0],</span>
<span class="sd">            [0, 0, 9]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">exec_q</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sycl_queue</span>
    <span class="n">usm_type</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">usm_type</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

    <span class="c1"># arr, with the iteration axis at the end</span>
    <span class="n">inarr_view</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># compute indices for the iteration axes, and append a trailing ellipsis to</span>
    <span class="c1"># prevent 0d arrays decaying to scalars</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">inarr_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span> <span class="o">+</span> <span class="p">(</span><span class="bp">Ellipsis</span><span class="p">,)</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">)</span>

    <span class="c1"># invoke the function on the first item</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ind0</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot apply_along_axis when any iteration dimensions are 0&quot;</span>
        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="kc">None</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span>
        <span class="n">func1d</span><span class="p">(</span><span class="n">inarr_view</span><span class="p">[</span><span class="n">ind0</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># build a buffer for storing evaluations of func1d.</span>
    <span class="c1"># remove the requested axis, and add the new ones on the end.</span>
    <span class="c1"># laid out so that each write is contiguous.</span>
    <span class="c1"># for a tuple index inds, buff[inds] = func1d(inarr_view[inds])</span>
    <span class="n">buff</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">inarr_view</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># save the first result, then compute and save all remaining results</span>
    <span class="n">buff</span><span class="p">[</span><span class="n">ind0</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
        <span class="n">buff</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span>
            <span class="n">func1d</span><span class="p">(</span><span class="n">inarr_view</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># restore the inserted axes back to where they belong</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">buff</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">buff</span></div>



<div class="viewcode-block" id="apply_over_axes">
<a class="viewcode-back" href="../../reference/generated/dpnp.apply_over_axes.html#dpnp.apply_over_axes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_over_axes</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply a function repeatedly over multiple axes.</span>

<span class="sd">    `func` is called as ``res = func(a, axis)``, where `axis` is the first</span>
<span class="sd">    element of `axes`. The result `res` of the function call must have</span>
<span class="sd">    either the same dimensions as `a` or one less dimension. If `res`</span>
<span class="sd">    has one less dimension than `a`, a dimension is inserted before</span>
<span class="sd">    `axis`. The call to `func` is then repeated for each axis in `axes`,</span>
<span class="sd">    with `res` as the first argument.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.apply_over_axes`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : function</span>
<span class="sd">         This function must take two arguments, ``func(a, axis)``.</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>
<span class="sd">    axes : {int, sequence of ints}</span>
<span class="sd">        Axes over which `func` is applied.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The output array. The number of dimensions is the same as `a`,</span>
<span class="sd">        but the shape can be different. This depends on whether `func`</span>
<span class="sd">        changes the shape of its output with respect to its input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.apply_along_axis` : Apply a function to 1-D slices of an array</span>
<span class="sd">                                   along the given axis.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(24).reshape(2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[[ 0,  1,  2,  3],</span>
<span class="sd">            [ 4,  5,  6,  7],</span>
<span class="sd">            [ 8,  9, 10, 11]],</span>
<span class="sd">           [[12, 13, 14, 15],</span>
<span class="sd">            [16, 17, 18, 19],</span>
<span class="sd">            [20, 21, 22, 23]]])</span>

<span class="sd">    Sum over axes 0 and 2. The result has same number of dimensions</span>
<span class="sd">    as the original array:</span>

<span class="sd">    &gt;&gt;&gt; np.apply_over_axes(np.sum, a, [0, 2])</span>
<span class="sd">    array([[[ 60],</span>
<span class="sd">            [ 92],</span>
<span class="sd">            [124]]])</span>

<span class="sd">    Tuple axis arguments to ufuncs are equivalent:</span>

<span class="sd">    &gt;&gt;&gt; np.sum(a, axis=(0, 2), keepdims=True)</span>
<span class="sd">    array([[[ 60],</span>
<span class="sd">            [ 92],</span>
<span class="sd">            [124]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="n">normalize_axis_tuple</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;function is not returning an array of the correct shape&quot;</span>
                <span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">res</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="piecewise">
<a class="viewcode-back" href="../../reference/generated/dpnp.piecewise.html#dpnp.piecewise">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a piecewise-defined function.</span>

<span class="sd">    Given a set of conditions and corresponding functions, evaluate each</span>
<span class="sd">    function on the input data wherever its condition is true.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.piecewise`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The input domain.</span>
<span class="sd">    condlist : {sequence of array-like boolean, bool scalars}</span>
<span class="sd">        Each boolean array/scalar corresponds to a function in `funclist`.</span>
<span class="sd">        Wherever `condlist[i]` is ``True``, `funclist[i](x)` is used as the</span>
<span class="sd">        output value.</span>

<span class="sd">        Each boolean array in `condlist` selects a piece of `x`, and should</span>
<span class="sd">        therefore be of the same shape as `x`.</span>

<span class="sd">        The length of `condlist` must correspond to that of `funclist`.</span>
<span class="sd">        If one extra function is given, i.e. if</span>
<span class="sd">        ``len(funclist) == len(condlist) + 1``, then that extra function</span>
<span class="sd">        is the default value, used wherever all conditions are ``False``.</span>
<span class="sd">    funclist : {array-like of scalars}</span>
<span class="sd">        A constant value is returned wherever corresponding condition of `x`</span>
<span class="sd">        is ``True``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The output is the same shape and type as `x` and is found by</span>
<span class="sd">        calling the functions in `funclist` on the appropriate portions of `x`,</span>
<span class="sd">        as defined by the boolean arrays in `condlist`. Portions not covered</span>
<span class="sd">        by any condition have a default value of ``0``.</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    Parameters `args` and `kw` are not supported and `funclist` cannot include a</span>
<span class="sd">    callable functions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.choose` : Construct an array from an index array and a set of</span>
<span class="sd">                         arrays to choose from.</span>
<span class="sd">    :obj:`dpnp.select` : Return an array drawn from elements in `choicelist`,</span>
<span class="sd">                         depending on conditions.</span>
<span class="sd">    :obj:`dpnp.where` : Return elements from one of two arrays depending</span>
<span class="sd">                        on condition.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>

<span class="sd">    Define the signum function, which is -1 for ``x &lt; 0`` and +1 for ``x &gt;= 0``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])</span>
<span class="sd">    array([-1., -1., -1.,  1.,  1.,  1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x_dtype</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="ow">and</span> <span class="n">condlist</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">condlist</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="c1"># convert scalar to a list of one array</span>
        <span class="c1"># convert list of scalars to a list of one array</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">condlist</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">sycl_queue</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># convert list of lists to list of arrays</span>
        <span class="c1"># convert list of scalars to a list of 0d arrays (for 0d input)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">dpnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">condlist</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">funclist</span><span class="p">):</span>
        <span class="n">usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">condlist</span><span class="p">])</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">)</span>

    <span class="n">condlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">funclist</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;funclist must be a non-string sequence&quot;</span><span class="p">)</span>
        <span class="n">funclen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;funclist must be a sequence of scalars&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

    <span class="k">if</span> <span class="n">condlen</span> <span class="o">==</span> <span class="n">funclen</span><span class="p">:</span>
        <span class="c1"># default value is zero</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">x_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">condlen</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">funclen</span><span class="p">:</span>
        <span class="c1"># default value is the last element of funclist</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">default_value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Callable functions are not supported currently&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default_value</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">default_value</span> <span class="o">=</span> <span class="n">default_value</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">default_value</span> <span class="o">=</span> <span class="n">x_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">default_value</span><span class="p">)</span>
        <span class="n">funclist</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">condlen</span><span class="si">}</span><span class="s2"> condition(s), either </span><span class="si">{</span><span class="n">condlen</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">condlen</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> &quot;</span>
            <span class="s2">&quot;functions are expected&quot;</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">condition</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">funclist</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Callable functions are not supported currently&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">x_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">x_dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>
        <span class="n">default_value</span> <span class="o">=</span> <span class="n">result</span>

    <span class="k">return</span> <span class="n">result</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2026, Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>