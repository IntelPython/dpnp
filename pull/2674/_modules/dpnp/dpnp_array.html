

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-554F8VNE28"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-554F8VNE28');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dpnp.dpnp_array &mdash; Data Parallel Extension for NumPy 0.20.0dev1+35.g55cd5cc367c documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=d3cef051"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Data Parallel Extension for NumPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start_guide.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Data Parallel Extension for NumPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dpnp.dpnp_array</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dpnp.dpnp_array</h1><div class="highlight"><pre>
<span></span><span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2016, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1"># - Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#   may be used to endorse or promote products derived from this software</span>
<span class="c1">#   without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interface of an ndarray representing a multidimensional tensor of numeric</span>
<span class="sd">elements stored in a USM allocation on a SYCL device.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=protected-access</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.tensor</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.tensor._type_utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dtu</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._numpy_helper</span><span class="w"> </span><span class="kn">import</span> <span class="n">AxisError</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">memory</span> <span class="k">as</span> <span class="n">dpm</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_unwrapped_index_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get an unwrapped index key.</span>

<span class="sd">    Return a key where each nested instance of DPNP array is unwrapped into</span>
<span class="sd">    USM ndarray for further processing in DPCTL advanced indexing functions.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dpnp_array</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">key</span><span class="p">):</span>
            <span class="c1"># create a new tuple from the input key with unwrapped DPNP arrays</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dpnp_array</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">key</span>
            <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">dpnp_array</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">key</span>


<span class="c1"># pylint: disable=too-many-public-methods</span>
<div class="viewcode-block" id="dpnp_array">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.html#dpnp.dpnp_array.dpnp_array">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">dpnp_array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An array object represents a multidimensional tensor of numeric elements</span>
<span class="sd">    stored in a USM allocation on a SYCL device.</span>

<span class="sd">    This is a wrapper around :class:`dpctl.tensor.usm_ndarray` that provides</span>
<span class="sd">    methods to be compliant with original NumPy.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># pylint: disable=too-many-positional-arguments</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>

        <span class="k">if</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># expecting to have buffer as dpnp.ndarray and usm_ndarray,</span>
            <span class="c1"># or as USM memory allocation</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">dpnp_array</span><span class="p">):</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">):</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="n">usm_type</span>

        <span class="n">sycl_queue_normalized</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_normalized_queue_device</span><span class="p">(</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">(</span>
            <span class="n">shape</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">strides</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">buffer_ctor_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;queue&quot;</span><span class="p">:</span> <span class="n">sycl_queue_normalized</span><span class="p">},</span>
            <span class="n">array_namespace</span><span class="o">=</span><span class="n">dpnp</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`|\text{self}|`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self + value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &amp; value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NumPy&#39;s array protocol method to disallow implicit conversion.</span>

<span class="sd">        Without this definition, ``numpy.asarray(dpnp_arr)`` converts</span>
<span class="sd">        :class:`dpnp.ndarray` instance into NumPy array with data type `object`</span>
<span class="sd">        and every element being zero-dimensional :class:`dpnp.ndarray`.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D403</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Implicit conversion to a NumPy array is not allowed. &quot;</span>
            <span class="s2">&quot;Please use `.asnumpy()` to construct a NumPy array explicitly.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># &#39;__array_finalize__&#39;,</span>
    <span class="c1"># &#39;__array_function__&#39;,</span>
    <span class="c1"># &#39;__array_interface__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_namespace__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">api_version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array namespace, member functions of which implement data API.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        api_version : {None, str}, optional</span>
<span class="sd">            Request namespace compliant with given version of array API. If</span>
<span class="sd">            ``None``, namespace for the most recent supported version is</span>
<span class="sd">            returned.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : any</span>
<span class="sd">            An object representing the array API namespace. It should have</span>
<span class="sd">            every top-level function defined in the specification as</span>
<span class="sd">            an attribute. It may contain other public names as well, but it is</span>
<span class="sd">            recommended to only include those names that are part of the</span>
<span class="sd">            specification.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">__array_namespace__</span><span class="p">(</span><span class="n">api_version</span><span class="o">=</span><span class="n">api_version</span><span class="p">)</span>

    <span class="c1"># &#39;__array_priority__&#39;,</span>
    <span class="c1"># &#39;__array_struct__&#39;,</span>

    <span class="n">__array_ufunc__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># &#39;__array_wrap__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;``True`` if `self` else ``False``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__bool__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{bytes(self)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">())</span>

    <span class="c1"># &#39;__class__&#39;,</span>
    <span class="c1"># `__class_getitem__`,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a zero-dimensional array to a Python complex object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__complex__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value in self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used if :func:`copy.copy` is called on an array. Return a copy of the</span>
<span class="sd">        array.</span>

<span class="sd">        Equivalent to ``a.copy(order=&quot;K&quot;)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;K&quot;</span><span class="p">)</span>

    <span class="c1"># &#39;__deepcopy__&#39;,</span>
    <span class="c1"># &#39;__dir__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{divmod(self, value)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__dlpack__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dl_device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Produce DLPack capsule.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stream : {:class:`dpctl.SyclQueue`, None}, optional</span>
<span class="sd">            Execution queue to synchronize with. If ``None``, synchronization</span>
<span class="sd">            is not performed.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        max_version : {tuple of ints, None}, optional</span>
<span class="sd">            The maximum DLPack version the consumer (caller of ``__dlpack__``)</span>
<span class="sd">            supports. As ``__dlpack__`` may not always return a DLPack capsule</span>
<span class="sd">            with version `max_version`, the consumer must verify the version</span>
<span class="sd">            even if this argument is passed.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        dl_device : {tuple, None}, optional:</span>
<span class="sd">            The device the returned DLPack capsule will be placed on. The</span>
<span class="sd">            device must be a 2-tuple matching the format of</span>
<span class="sd">            :meth:`dpnp.ndarray.__dlpack_device__`, an integer enumerator</span>
<span class="sd">            representing the device type followed by an integer representing</span>
<span class="sd">            the index of the device.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        copy : {bool, None}, optional:</span>
<span class="sd">            Boolean indicating whether or not to copy the input.</span>

<span class="sd">            * If `copy` is ``True``, the input will always be copied.</span>
<span class="sd">            * If ``False``, a ``BufferError`` will be raised if a copy is</span>
<span class="sd">              deemed necessary.</span>
<span class="sd">            * If ``None``, a copy will be made only if deemed necessary,</span>
<span class="sd">              otherwise, the existing memory buffer will be reused.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        MemoryError</span>
<span class="sd">            when host memory can not be allocated.</span>
<span class="sd">        DLPackCreationError</span>
<span class="sd">            when array is allocated on a partitioned SYCL device, or with</span>
<span class="sd">            a non-default context.</span>
<span class="sd">        BufferError</span>
<span class="sd">            when a copy is deemed necessary but `copy` is ``False`` or when</span>
<span class="sd">            the provided `dl_device` cannot be handled.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">__dlpack__</span><span class="p">(</span>
            <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">,</span>
            <span class="n">max_version</span><span class="o">=</span><span class="n">max_version</span><span class="p">,</span>
            <span class="n">dl_device</span><span class="o">=</span><span class="n">dl_device</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__dlpack_device__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a tuple (``device_type``, ``device_id``) corresponding to</span>
<span class="sd">        ``DLDevice`` entry in ``DLTensor`` in DLPack protocol.</span>

<span class="sd">        The tuple describes the non-partitioned device where the array has been</span>
<span class="sd">        allocated, or the non-partitioned parent device of the allocation</span>
<span class="sd">        device.</span>

<span class="sd">        See :class:`dpnp.DLDeviceType` for a list of devices supported by the</span>
<span class="sd">        DLPack protocol.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        DLPackCreationError</span>
<span class="sd">            when the ``device_id`` could not be determined.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">__dlpack_device__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self == value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a zero-dimensional array to a Python float object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__float__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self // value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">format_spec</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{format(self, format_spec)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(),</span> <span class="n">format_spec</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &gt;= value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self[key]}`.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">_get_unwrapped_index_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># &#39;__getstate__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &gt; value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># &#39;__hash__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self += value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &amp;= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self //= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &lt;&lt;= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__imatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self @= value}`.&quot;&quot;&quot;</span>

        <span class="c1"># Unlike `matmul(a, b, out=a)` we ensure that the result isn&#39;t broadcast</span>
        <span class="c1"># if the result without `out` would have less dimensions than `a`.</span>
        <span class="c1"># Since the signature of matmul is &#39;(n?,k),(k,m?)-&gt;(n?,m?)&#39; this is the</span>
        <span class="c1"># case exactly when the second operand has both core dimensions.</span>
        <span class="c1"># We have to enforce this check by passing the correct `axes=`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">AxisError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># AxisError should indicate that the axes argument didn&#39;t work out</span>
            <span class="c1"># which should mean the second operand not being 2 dimensional.</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;inplace matrix multiplication requires the first operand to &quot;</span>
                <span class="s2">&quot;have at least one and the second at least two dimensions.&quot;</span>
            <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__imod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self %= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self *= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a zero-dimensional array to a Python int object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>

    <span class="c1"># &#39;__init_subclass__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a zero-dimensional array to a Python int object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__int__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__invert__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{~self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self |= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self **= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__irshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &gt;&gt;= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self -= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{iter(self)}`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;iteration over a 0-d array&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self /= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self ^= value}`.&quot;&quot;&quot;</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &lt;= value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{len(self)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &lt;&lt; value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &lt; value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self @ value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self % value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self * value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self != value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{-self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">negative</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># &#39;__new__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self | value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pos__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{+self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">positive</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self ** value}`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value + self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value &amp; self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{divmod(value, self)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="c1"># &#39;__reduce__&#39;,</span>
    <span class="c1"># &#39;__reduce_ex__&#39;,</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{repr(self)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;array&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value // self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rlshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value &lt;&lt; self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value @ self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value % self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value * self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value | self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">mod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value ** self}`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rrshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value &gt;&gt; self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self &gt;&gt; value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value - self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value / self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{value ^ self}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set :math:`\text{self[key]}` to a value.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">_get_unwrapped_index_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dpnp_array</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># &#39;__setstate__&#39;,</span>
    <span class="c1"># &#39;__sizeof__&#39;,</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_array_obj&quot;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{str(self)}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self - value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__sycl_usm_array_interface__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give ``__sycl_usm_array_interface__`` dictionary describing the array.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D200</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">__sycl_usm_array_interface__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self / value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__usm_ndarray__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property to support ``__usm_ndarray__`` protocol.</span>

<span class="sd">        It assumes to return :class:`dpctl.tensor.usm_ndarray` instance</span>
<span class="sd">        corresponding to the content of the object.</span>

<span class="sd">        This property is intended to speed-up conversion from</span>
<span class="sd">        :class:`dpnp.ndarray` to :class:`dpctl.tensor.usm_ndarray` passed into</span>
<span class="sd">        :func:`dpctl.tensor.asarray` function. The input object that implements</span>
<span class="sd">        ``__usm_ndarray__`` protocol is recognized as owner of USM allocation</span>
<span class="sd">        that is managed by a smart pointer, and asynchronous deallocation</span>
<span class="sd">        will not involve GIL.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return :math:`\text{self ^ value}`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_ary</span><span class="p">:</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`dpnp.ndarray` instance from USM allocation providing</span>
<span class="sd">        by an instance of :class:`dpctl.tensor.usm_ndarray`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">usm_ary</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">usm_ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected dpctl.tensor.usm_ndarray, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">usm_ary</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">dpnp_array</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_array_obj</span> <span class="o">=</span> <span class="n">usm_ary</span>
        <span class="n">res</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">_set_namespace</span><span class="p">(</span><span class="n">dpnp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="dpnp_array.all">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.all.html#dpnp.dpnp_array.dpnp_array.all">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``True`` if all elements evaluate to ``True``.</span>

<span class="sd">        Refer to :obj:`dpnp.all` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.all` : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.any">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.any.html#dpnp.dpnp_array.dpnp_array.any">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return ``True`` if any of the elements of `a` evaluate to ``True``.</span>

<span class="sd">        Refer to :obj:`dpnp.any` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.any` : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.argmax">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.argmax.html#dpnp.dpnp_array.dpnp_array.argmax">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array of indices of the maximum values along the given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.argmax` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.argmin">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.argmin.html#dpnp.dpnp_array.dpnp_array.argmin">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array of indices to the minimum values along the given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.argmin` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


    <span class="c1"># &#39;argpartition&#39;,</span>

<div class="viewcode-block" id="dpnp_array.argsort">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.argsort.html#dpnp.dpnp_array.dpnp_array.argsort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">argsort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an ndarray of indices that sort the array along the specified</span>
<span class="sd">        axis.</span>

<span class="sd">        Refer to :obj:`dpnp.argsort` for full documentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to sort. If ``None``, the array is flattened</span>
<span class="sd">            before sorting. The default is ``-1``, which sorts along the last</span>
<span class="sd">            axis.</span>

<span class="sd">            Default: ``-1``.</span>
<span class="sd">        kind : {None, &quot;stable&quot;, &quot;mergesort&quot;, &quot;radixsort&quot;}, optional</span>
<span class="sd">            Sorting algorithm. The default is ``None``, which uses parallel</span>
<span class="sd">            merge-sort or parallel radix-sort algorithms depending on the array</span>
<span class="sd">            data type.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        descending : bool, optional</span>
<span class="sd">            Sort order. If ``True``, the array must be sorted in descending</span>
<span class="sd">            order (by value). If ``False``, the array must be sorted in</span>
<span class="sd">            ascending order (by value).</span>

<span class="sd">            Default: ``False``.</span>
<span class="sd">        stable : {None, bool}, optional</span>
<span class="sd">            Sort stability. If ``True``, the returned array will maintain the</span>
<span class="sd">            relative order of `a` values which compare as equal. The same</span>
<span class="sd">            behavior applies when set to ``False`` or ``None``.</span>
<span class="sd">            Internally, this option selects ``kind=&quot;stable&quot;``.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.sort` : Return a sorted copy of an array.</span>
<span class="sd">        :obj:`dpnp.argsort` : Return the indices that would sort an array.</span>
<span class="sd">        :obj:`dpnp.lexsort` : Indirect stable sort on multiple keys.</span>
<span class="sd">        :obj:`dpnp.searchsorted` : Find elements in a sorted array.</span>
<span class="sd">        :obj:`dpnp.partition` : Partial sort.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([3, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; a.argsort()</span>
<span class="sd">        array([1, 2, 0])</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([[0, 3], [2, 2]])</span>
<span class="sd">        &gt;&gt;&gt; a.argsort(axis=0)</span>
<span class="sd">        array([[0, 1],</span>
<span class="sd">               [1, 0]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="n">stable</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.asnumpy">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.asnumpy.html#dpnp.dpnp_array.dpnp_array.asnumpy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy content of the array into :class:`numpy.ndarray` instance of</span>
<span class="sd">        the same shape and data type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : numpy.ndarray</span>
<span class="sd">            An instance of :class:`numpy.ndarray` populated with the array</span>
<span class="sd">            content.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpt</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.astype">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.astype.html#dpnp.dpnp_array.dpnp_array.astype">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">astype</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">,</span>
        <span class="n">order</span><span class="o">=</span><span class="s2">&quot;K&quot;</span><span class="p">,</span>
        <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;unsafe&quot;</span><span class="p">,</span>
        <span class="n">subok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the array with data type casting.</span>

<span class="sd">        Refer to :obj:`dpnp.astype` for full documentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : {None, str, dtype object}</span>
<span class="sd">            Target data type.</span>
<span class="sd">        order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;, &quot;K&quot;}, optional</span>
<span class="sd">            Row-major (C-style) or column-major (Fortran-style) order.</span>
<span class="sd">            When `order` is ``&quot;A&quot;``, it uses ``&quot;F&quot;`` if `a` is column-major and</span>
<span class="sd">            uses ``&quot;C&quot;`` otherwise. And when `order` is ``&quot;K&quot;``, it keeps</span>
<span class="sd">            strides as closely as possible.</span>

<span class="sd">            Default: ``&quot;K&quot;``.</span>
<span class="sd">        casting : {&quot;no&quot;, &quot;equiv&quot;, &quot;safe&quot;, &quot;same_kind&quot;, &quot;unsafe&quot;}, optional</span>
<span class="sd">            Controls what kind of data casting may occur. Defaults to</span>
<span class="sd">            ``&quot;unsafe&quot;`` for backwards compatibility.</span>

<span class="sd">                - &quot;no&quot; means the data types should not be cast at all.</span>
<span class="sd">                - &quot;equiv&quot; means only byte-order changes are allowed.</span>
<span class="sd">                - &quot;safe&quot; means only casts which can preserve values are allowed.</span>
<span class="sd">                - &quot;same_kind&quot; means only safe casts or casts within a kind,</span>
<span class="sd">                  like float64 to float32, are allowed.</span>
<span class="sd">                - &quot;unsafe&quot; means any data conversions may be done.</span>

<span class="sd">            Default: ``&quot;unsafe&quot;``.</span>
<span class="sd">        copy : bool, optional</span>
<span class="sd">            Specifies whether to copy an array when the specified dtype matches</span>
<span class="sd">            the data type of that array. If ``True``, a newly allocated array</span>
<span class="sd">            must always be returned. If ``False`` and the specified dtype</span>
<span class="sd">            matches the data type of that array, the self array must be</span>
<span class="sd">            returned; otherwise, a newly allocated array must be returned.</span>

<span class="sd">            Default: ``True``.</span>
<span class="sd">        device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">            An array API concept of device where the output array is created.</span>
<span class="sd">            `device` can be ``None``, a oneAPI filter selector string,</span>
<span class="sd">            an instance of :class:`dpctl.SyclDevice` corresponding to</span>
<span class="sd">            a non-partitioned SYCL device, an instance of</span>
<span class="sd">            :class:`dpctl.SyclQueue`, or a :class:`dpctl.tensor.Device` object</span>
<span class="sd">            returned by :attr:`dpnp.ndarray.device`.</span>
<span class="sd">            If the value is ``None``, returned array is created on the same</span>
<span class="sd">            device as that array.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dpnp.ndarray</span>
<span class="sd">            An array having the specified data type.</span>

<span class="sd">        Limitations</span>
<span class="sd">        -----------</span>
<span class="sd">        Parameter `subok` is supported with default value.</span>
<span class="sd">        Otherwise ``NotImplementedError`` exception will be raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([1, 2, 2.5]); x</span>
<span class="sd">        array([1. , 2. , 2.5])</span>

<span class="sd">        &gt;&gt;&gt; x.astype(int)</span>
<span class="sd">        array([1, 2, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">subok</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;subok=</span><span class="si">{</span><span class="n">subok</span><span class="si">}</span><span class="s2"> is currently not supported&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span>
        <span class="p">)</span></div>


    <span class="c1"># &#39;base&#39;,</span>
    <span class="c1"># &#39;byteswap&#39;,</span>

<div class="viewcode-block" id="dpnp_array.choose">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.choose.html#dpnp.dpnp_array.dpnp_array.choose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use an array as index array to construct a new array from a set of</span>
<span class="sd">        choices.</span>

<span class="sd">        Refer to :obj:`dpnp.choose` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.clip">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.clip.html#dpnp.dpnp_array.dpnp_array.clip">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clip (limit) the values in an array.</span>

<span class="sd">        Refer to :obj:`dpnp.clip` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.compress">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.compress.html#dpnp.dpnp_array.dpnp_array.compress">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select slices of an array along a given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.compress` for full documentation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.conj">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.conj.html#dpnp.dpnp_array.dpnp_array.conj">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">conj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Complex-conjugate all elements.</span>

<span class="sd">        Refer to :obj:`dpnp.conjugate` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span></div>


<div class="viewcode-block" id="dpnp_array.conjugate">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.conjugate.html#dpnp.dpnp_array.dpnp_array.conjugate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the complex conjugate, element-wise.</span>

<span class="sd">        Refer to :obj:`dpnp.conjugate` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.copy">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.copy.html#dpnp.dpnp_array.dpnp_array.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the array.</span>

<span class="sd">        Refer to :obj:`dpnp.copy` for full documentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;, &quot;K&quot;}, optional</span>
<span class="sd">            Memory layout of the newly output array.</span>

<span class="sd">            Default: ``&quot;C&quot;``.</span>
<span class="sd">        device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">            An array API concept of device where the output array is created.</span>
<span class="sd">            `device` can be ``None``, a oneAPI filter selector string,</span>
<span class="sd">            an instance of :class:`dpctl.SyclDevice` corresponding to</span>
<span class="sd">            a non-partitioned SYCL device, an instance of</span>
<span class="sd">            :class:`dpctl.SyclQueue`, or a :class:`dpctl.tensor.Device` object</span>
<span class="sd">            returned by :attr:`dpnp.ndarray.device`.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        usm_type : {None, &quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">            The type of SYCL USM allocation for the output array.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">            A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">            `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">            to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">            a default queue.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dpnp.ndarray</span>
<span class="sd">            A copy of the array.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.copy` : Similar function with different default behavior</span>
<span class="sd">        :obj:`dpnp.copyto` : Copies values from one array to another.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function is the preferred method for creating an array copy.</span>
<span class="sd">        The function :func:`dpnp.copy` is similar, but it defaults to using</span>
<span class="sd">        order ``&quot;K&quot;``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]], order=&#39;F&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = x.copy()</span>
<span class="sd">        &gt;&gt;&gt; x.fill(0)</span>

<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        array([[0, 0, 0],</span>
<span class="sd">               [0, 0, 0]])</span>

<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        array([[1, 2, 3],</span>
<span class="sd">               [4, 5, 6]])</span>

<span class="sd">        &gt;&gt;&gt; y.flags[&#39;C_CONTIGUOUS&#39;]</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># &#39;ctypes&#39;,</span>

<div class="viewcode-block" id="dpnp_array.cumprod">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.cumprod.html#dpnp.dpnp_array.dpnp_array.cumprod">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative product of the elements along the given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.cumprod` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.cumsum">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.cumsum.html#dpnp.dpnp_array.dpnp_array.cumsum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative sum of the elements along the given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.cumsum` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Python object pointing to the start of USM memory allocation with the</span>
<span class="sd">        array&#39;s data.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpm</span><span class="o">.</span><span class="n">create_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`dpctl.tensor.Device` object representing residence of</span>
<span class="sd">        the array data.</span>

<span class="sd">        The ``Device`` object represents Array API notion of the device, and</span>
<span class="sd">        contains :class:`dpctl.SyclQueue` associated with this array. Hence,</span>
<span class="sd">        ``.device`` property provides information distinct from ``.sycl_device``</span>
<span class="sd">        property.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.ones(10)</span>
<span class="sd">        &gt;&gt;&gt; x.device</span>
<span class="sd">        Device(level_zero:gpu:0)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">device</span>

<div class="viewcode-block" id="dpnp_array.diagonal">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.diagonal.html#dpnp.dpnp_array.dpnp_array.diagonal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return specified diagonals.</span>

<span class="sd">        Refer to :obj:`dpnp.diagonal` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.diagonal` : Equivalent function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(4).reshape(2, 2)</span>
<span class="sd">        &gt;&gt;&gt; a.diagonal()</span>
<span class="sd">        array([0, 3])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.dot">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.dot.html#dpnp.dpnp_array.dpnp_array.dot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dot product of two arrays.</span>

<span class="sd">        Refer to :obj:`dpnp.dot` for full documentation.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.eye(2)</span>
<span class="sd">        &gt;&gt;&gt; b = np.ones((2, 2)) * 2</span>
<span class="sd">        &gt;&gt;&gt; a.dot(b)</span>
<span class="sd">        array([[2., 2.],</span>
<span class="sd">               [2., 2.]])</span>

<span class="sd">        This array method can be conveniently chained:</span>

<span class="sd">        &gt;&gt;&gt; a.dot(b).dot(b)</span>
<span class="sd">        array([[8., 8.],</span>
<span class="sd">               [8., 8.]])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return NumPy&#39;s dtype corresponding to the type of the array elements.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D200</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">dtype</span>

    <span class="c1"># &#39;dump&#39;,</span>
    <span class="c1"># &#39;dumps&#39;,</span>

<div class="viewcode-block" id="dpnp_array.fill">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.fill.html#dpnp.dpnp_array.dpnp_array.fill">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill the array with a scalar value.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.fill`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : {dpnp.ndarray, usm_ndarray, scalar}</span>
<span class="sd">            All elements of `a` will be assigned this value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; a.fill(0)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([0, 0])</span>
<span class="sd">        &gt;&gt;&gt; a = np.empty(2)</span>
<span class="sd">        &gt;&gt;&gt; a.fill(1)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([1.,  1.])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># lazy import avoids circular imports</span>
        <span class="c1"># pylint: disable=import-outside-toplevel</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_algo.dpnp_fill</span><span class="w"> </span><span class="kn">import</span> <span class="n">dpnp_fill</span>

        <span class="n">dpnp_fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flags</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return information about the memory layout of the array.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">flags</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a flat iterator, or set a flattened version of self to value.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D200</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">flatiter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="dpnp_array.flatten">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.flatten.html#dpnp.dpnp_array.dpnp_array.flatten">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the array collapsed into one dimension.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.flatten`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {&quot;C&quot;, &quot;F&quot;}, optional</span>
<span class="sd">            Read the elements using this index order, and place the elements</span>
<span class="sd">            into the reshaped array using this index order.</span>

<span class="sd">                - ``&quot;C&quot;`` means to read / write the elements using C-like index</span>
<span class="sd">                  order, with the last axis index changing fastest, back to the</span>
<span class="sd">                  first axis index changing slowest.</span>
<span class="sd">                - ``&quot;F&quot;`` means to read / write the elements using Fortran-like</span>
<span class="sd">                  index order, with the first index changing fastest, and the</span>
<span class="sd">                  last index changing slowest.</span>

<span class="sd">            Default: ``&quot;C&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dpnp.ndarray</span>
<span class="sd">            A copy of the input array, flattened to one dimension.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.ravel` : Return a flattened array.</span>
<span class="sd">        :obj:`dpnp.flat` : A 1-D flat iterator over the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a.flatten()</span>
<span class="sd">        array([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; a.flatten(&quot;F&quot;)</span>
<span class="sd">        array([1, 3, 2, 4])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.get_array">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.get_array.html#dpnp.dpnp_array.dpnp_array.get_array">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get :class:`dpctl.tensor.usm_ndarray` object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span></div>


    <span class="c1"># &#39;getfield&#39;,</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The imaginary part of the array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.imag`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.sqrt(np.array([1+0j, 0+1j]))</span>
<span class="sd">        &gt;&gt;&gt; x.imag</span>
<span class="sd">        array([0.        , 0.70710677])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">imag</span>
        <span class="p">)</span>

    <span class="nd">@imag</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the imaginary part of the array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.imag`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])</span>
<span class="sd">        &gt;&gt;&gt; a.imag = 9</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([1.+9.j, 3.+9.j, 5.+9.j])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="n">dpnp</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;array does not have imaginary part to set&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="dpnp_array.item">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.item.html#dpnp.dpnp_array.dpnp_array.item">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy an element of an array to a standard Python scalar and return it.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.item`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : {none, int, tuple of ints}</span>
<span class="sd">            - none: in this case, the method only works for arrays with</span>
<span class="sd">              one element (``a.size == 1``), which element is copied into a</span>
<span class="sd">              standard Python scalar object and returned.</span>
<span class="sd">            - int: this argument is interpreted as a flat index into the array,</span>
<span class="sd">              specifying which element to copy and return.</span>
<span class="sd">            - tuple of ints: functions as does a single int argument, except</span>
<span class="sd">              that the argument is interpreted as an nd-index into the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : Standard Python scalar object</span>
<span class="sd">            A copy of the specified element of the array as a suitable Python</span>
<span class="sd">            scalar.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; np.random.seed(123)</span>
<span class="sd">        &gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        array([[0, 0, 7],</span>
<span class="sd">               [6, 6, 6],</span>
<span class="sd">               [0, 7, 1]])</span>
<span class="sd">        &gt;&gt;&gt; x.item(3)</span>
<span class="sd">        6</span>
<span class="sd">        &gt;&gt;&gt; x.item(7)</span>
<span class="sd">        7</span>
<span class="sd">        &gt;&gt;&gt; x.item((0, 1))</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x.item((2, 2))</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; x = np.array(5)</span>
<span class="sd">        &gt;&gt;&gt; x.item()</span>
<span class="sd">        5</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: implement a more efficient way to avoid copying to host</span>
        <span class="c1"># for large arrays using `asnumpy()`</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">itemsize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Size of one array element in bytes.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">itemsize</span>

<div class="viewcode-block" id="dpnp_array.max">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.max.html#dpnp.dpnp_array.dpnp_array.max">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum along an axis.</span>

<span class="sd">        Refer to :obj:`dpnp.max` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.mean">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.mean.html#dpnp.dpnp_array.dpnp_array.mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the average of the array elements.</span>

<span class="sd">        Refer to :obj:`dpnp.mean` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.min">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.min.html#dpnp.dpnp_array.dpnp_array.min">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum along a given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.min` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        View of the matrix transposed array.</span>

<span class="sd">        The matrix transpose is the transpose of the last two dimensions, even</span>
<span class="sd">        if the array is of higher dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the array is of dimension less than ``2``.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[1, 2],</span>
<span class="sd">               [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a.mT</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">               [2, 4]])</span>

<span class="sd">        &gt;&gt;&gt; a = np.arange(8).reshape((2, 2, 2))</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[[0, 1],</span>
<span class="sd">                [2, 3]],</span>
<span class="sd">               [[4, 5],</span>
<span class="sd">                [6, 7]]])</span>
<span class="sd">        &gt;&gt;&gt; a.mT</span>
<span class="sd">        array([[[0, 2],</span>
<span class="sd">                [1, 3]],</span>
<span class="sd">               [[4, 6],</span>
<span class="sd">                [5, 7]]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrix transpose with ndim &lt; 2 is undefined&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">mT</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nbytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total bytes consumed by the elements of the array.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">nbytes</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the number of dimensions of an array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.ndim`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        number_of_dimensions : int</span>
<span class="sd">            The number of dimensions in `a`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.ndim` : Equivalent method for any array-like input.</span>
<span class="sd">        :obj:`dpnp.shape` : Return the shape of an array.</span>
<span class="sd">        :obj:`dpnp.ndarray.shape` : Return the shape of an array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.ndim</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; y = np.zeros((2, 3, 4))</span>
<span class="sd">        &gt;&gt;&gt; y.ndim</span>
<span class="sd">        3</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">ndim</span>

<div class="viewcode-block" id="dpnp_array.nonzero">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.nonzero.html#dpnp.dpnp_array.dpnp_array.nonzero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of the elements that are non-zero.</span>

<span class="sd">        Refer to :obj:`dpnp.nonzero` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.partition">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.partition.html#dpnp.dpnp_array.dpnp_array.partition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;introselect&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a partitioned copy of an array.</span>

<span class="sd">        Rearranges the elements in the array in such a way that the value of</span>
<span class="sd">        the element in `kth` position is in the position it would be in</span>
<span class="sd">        a sorted array.</span>

<span class="sd">        All elements smaller than the `kth` element are moved before this</span>
<span class="sd">        element and all equal or greater are moved behind it. The ordering</span>
<span class="sd">        of the elements in the two partitions is undefined.</span>

<span class="sd">        Refer to `dpnp.partition` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.partition` : Return a partitioned copy of an array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([3, 4, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; a.partition(3)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([1, 2, 3, 4])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">kth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span>
        <span class="p">)</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span></div>


<div class="viewcode-block" id="dpnp_array.prod">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.prod.html#dpnp.dpnp_array.dpnp_array.prod">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prod</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the prod along a given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.prod` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.put">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.put.html#dpnp.dpnp_array.dpnp_array.put">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put values of an array into another array along a given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.put` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.ravel">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.ravel.html#dpnp.dpnp_array.dpnp_array.ravel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a contiguous flattened array.</span>

<span class="sd">        Refer to :obj:`dpnp.ravel` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The real part of the array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.real`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.sqrt(np.array([1+0j, 0+1j]))</span>
<span class="sd">        &gt;&gt;&gt; x.real</span>
<span class="sd">        array([1.        , 0.70710677])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span>
                <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@real</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">real</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the real part of the array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.real`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])</span>
<span class="sd">        &gt;&gt;&gt; a.real = 9</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([9.+2.j, 9.+4.j, 9.+6.j])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dpnp</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="dpnp_array.repeat">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.repeat.html#dpnp.dpnp_array.dpnp_array.repeat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of an array.</span>

<span class="sd">        Refer to :obj:`dpnp.repeat` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.reshape">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.reshape.html#dpnp.dpnp_array.dpnp_array.reshape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array containing the same data with a new shape.</span>

<span class="sd">        Refer to :obj:`dpnp.reshape` for full documentation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : dpnp.ndarray</span>
<span class="sd">            This will be a new view object if possible;</span>
<span class="sd">            otherwise, it will be a copy.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.reshape` : Equivalent function.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike the free function `dpnp.reshape`, this method on `ndarray` allows</span>
<span class="sd">        the elements of the shape parameter to be passed in as separate</span>
<span class="sd">        arguments.</span>
<span class="sd">        For example, ``a.reshape(10, 11)`` is equivalent to</span>
<span class="sd">        ``a.reshape((10, 11))``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


    <span class="c1"># &#39;resize&#39;,</span>

<div class="viewcode-block" id="dpnp_array.round">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.round.html#dpnp.dpnp_array.dpnp_array.round">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array with each element rounded to the given number of decimals.</span>

<span class="sd">        Refer to :obj:`dpnp.round` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.searchsorted">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.searchsorted.html#dpnp.dpnp_array.dpnp_array.searchsorted">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find indices where elements of `v` should be inserted in `a`</span>
<span class="sd">        to maintain order.</span>

<span class="sd">        Refer to :obj:`dpnp.searchsorted` for full documentation</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">sorter</span><span class="p">)</span></div>


    <span class="c1"># &#39;setfield&#39;,</span>
    <span class="c1"># &#39;setflags&#39;,</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tuple of array dimensions.</span>

<span class="sd">        The shape property is usually used to get the current shape of an array,</span>
<span class="sd">        but may also be used to reshape the array in-place by assigning a tuple</span>
<span class="sd">        of array dimensions to it. Unlike :obj:`dpnp.reshape`, only non-negative</span>
<span class="sd">        values are supported to be set as new shape. Reshaping an array in-place</span>
<span class="sd">        will fail if a copy is required.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.shape`.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        Using :obj:`dpnp.ndarray.reshape` or :obj:`dpnp.reshape` is the</span>
<span class="sd">        preferred approach to set new shape of an array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.shape` : Equivalent getter function.</span>
<span class="sd">        :obj:`dpnp.reshape` : Function similar to setting `shape`.</span>
<span class="sd">        :obj:`dpnp.ndarray.reshape` : Method similar to setting `shape`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; x.shape</span>
<span class="sd">        (4,)</span>
<span class="sd">        &gt;&gt;&gt; y = np.zeros((2, 3, 4))</span>
<span class="sd">        &gt;&gt;&gt; y.shape</span>
<span class="sd">        (2, 3, 4)</span>

<span class="sd">        &gt;&gt;&gt; y.shape = (3, 8)</span>
<span class="sd">        &gt;&gt;&gt; y</span>
<span class="sd">        array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">               [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">        &gt;&gt;&gt; y.shape = (3, 6)</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: Can not reshape array of size 24 into (3, 6)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@shape</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newshape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set new lengths of axes.</span>

<span class="sd">        Modifies array instance in-place by changing its metadata about the</span>
<span class="sd">        shape and the strides of the array, or raises `AttributeError`</span>
<span class="sd">        exception if in-place change is not possible.</span>

<span class="sd">        Whether the array can be reshape in-place depends on its strides. Use</span>
<span class="sd">        :obj:`dpnp.reshape` function which always succeeds to reshape the array</span>
<span class="sd">        by performing a copy if necessary.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.shape`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        newshape : {tuple, int}</span>
<span class="sd">            New shape. Only non-negative values are supported. The new shape</span>
<span class="sd">            may not lead to the change in the number of elements in the array.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">newshape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of elements in the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        element_count : int</span>
<span class="sd">            Number of elements in the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.size` : Return the number of elements along a given axis.</span>
<span class="sd">        :obj:`dpnp.shape` : Return the shape of an array.</span>
<span class="sd">        :obj:`dpnp.ndarray.shape` : Return the shape of an array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex64)</span>
<span class="sd">        &gt;&gt;&gt; x.size</span>
<span class="sd">        30</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">size</span>

<div class="viewcode-block" id="dpnp_array.sort">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.sort.html#dpnp.dpnp_array.dpnp_array.sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">descending</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">stable</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort an array in-place.</span>

<span class="sd">        Refer to :obj:`dpnp.sort` for full documentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort. The default is ``-1``, which sorts along</span>
<span class="sd">            the last axis.</span>

<span class="sd">            Default: ``-1``.</span>
<span class="sd">        kind : {None, &quot;stable&quot;, &quot;mergesort&quot;, &quot;radixsort&quot;}, optional</span>
<span class="sd">            Sorting algorithm. The default is ``None``, which uses parallel</span>
<span class="sd">            merge-sort or parallel radix-sort algorithms depending on the array</span>
<span class="sd">            data type.</span>

<span class="sd">            Default: ``None``.</span>
<span class="sd">        descending : bool, optional</span>
<span class="sd">            Sort order. If ``True``, the array must be sorted in descending</span>
<span class="sd">            order (by value). If ``False``, the array must be sorted in</span>
<span class="sd">            ascending order (by value).</span>

<span class="sd">            Default: ``False``.</span>
<span class="sd">        stable : {None, bool}, optional</span>
<span class="sd">            Sort stability. If ``True``, the returned array will maintain the</span>
<span class="sd">            relative order of `a` values which compare as equal. The same</span>
<span class="sd">            behavior applies when set to ``False`` or ``None``.</span>
<span class="sd">            Internally, this option selects ``kind=&quot;stable&quot;``.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.sort` : Return a sorted copy of an array.</span>
<span class="sd">        :obj:`dpnp.argsort` : Return the indices that would sort an array.</span>
<span class="sd">        :obj:`dpnp.lexsort` : Indirect stable sort on multiple keys.</span>
<span class="sd">        :obj:`dpnp.searchsorted` : Find elements in a sorted array.</span>
<span class="sd">        :obj:`dpnp.partition` : Partial sort.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        `axis` in :obj:`dpnp.sort` could be integer or ``None``. If ``None``,</span>
<span class="sd">        the array is flattened before sorting. However, `axis` in</span>
<span class="sd">        :obj:`dpnp.ndarray.sort` can only be integer since it sorts an array</span>
<span class="sd">        in-place.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 4], [3, 1]])</span>
<span class="sd">        &gt;&gt;&gt; a.sort(axis=1)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[1, 4],</span>
<span class="sd">              [1, 3]])</span>
<span class="sd">        &gt;&gt;&gt; a.sort(axis=0)</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[1, 1],</span>
<span class="sd">              [3, 4]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;NoneType&#39; object cannot be interpreted as an integer&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
            <span class="n">descending</span><span class="o">=</span><span class="n">descending</span><span class="p">,</span>
            <span class="n">stable</span><span class="o">=</span><span class="n">stable</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.squeeze">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.squeeze.html#dpnp.dpnp_array.dpnp_array.squeeze">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove single-dimensional entries from the shape of an array.</span>

<span class="sd">        Refer to :obj:`dpnp.squeeze` for full documentation</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.std">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.std.html#dpnp.dpnp_array.dpnp_array.std">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">std</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the standard deviation of the array elements, along given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.std` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">std</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">,</span>
            <span class="n">out</span><span class="p">,</span>
            <span class="n">ddof</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
            <span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span>
            <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">strides</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return memory displacement in array elements, upon unit</span>
<span class="sd">        change of respective index.</span>

<span class="sd">        For example, for strides ``(s1, s2, s3)`` and multi-index</span>
<span class="sd">        ``(i1, i2, i3)`` position of the respective element relative</span>
<span class="sd">        to zero multi-index element is ``s1*s1 + s2*i2 + s3*i3``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">strides</span>

<div class="viewcode-block" id="dpnp_array.sum">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.sum.html#dpnp.dpnp_array.dpnp_array.sum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">initial</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum along a given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.sum` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">,</span>
            <span class="n">initial</span><span class="o">=</span><span class="n">initial</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.swapaxes">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.swapaxes.html#dpnp.dpnp_array.dpnp_array.swapaxes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interchange two axes of an array.</span>

<span class="sd">        Refer to :obj:`dpnp.swapaxes` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sycl_context</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`dpctl.SyclContext` object to which USM data is bound.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D200</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">sycl_context</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sycl_device</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`dpctl.SyclDevice` object on which USM data was</span>
<span class="sd">        allocated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">sycl_device</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sycl_queue</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return :class:`dpctl.SyclQueue` object associated with USM data.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: D200</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">sycl_queue</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        View of the transposed array.</span>

<span class="sd">        Same as ``self.transpose()`` except that it requires</span>
<span class="sd">        the array to be 2-dimensional.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.transpose` : Equivalent function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[1, 2],</span>
<span class="sd">            [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a.T</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">            [2, 4]])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`.T` is deprecated for non-2D dpnp.ndarray &quot;</span>
                <span class="s2">&quot;and will raise an error in a future release. &quot;</span>
                <span class="s2">&quot;Either `self.transpose()` or `self.mT` (which swaps &quot;</span>
                <span class="s2">&quot;the last two axes only) should be used instead.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<div class="viewcode-block" id="dpnp_array.take">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.take.html#dpnp.dpnp_array.dpnp_array.take">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Take elements from an array along an axis.</span>

<span class="sd">        Refer to :obj:`dpnp.take` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.to_device">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.to_device.html#dpnp.dpnp_array.dpnp_array.to_device">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_device</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transfer this array to specified target device.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">            An array API concept of device where the output array is created.</span>
<span class="sd">            `device` can be ``None``, a oneAPI filter selector string,</span>
<span class="sd">            an instance of :class:`dpctl.SyclDevice` corresponding to</span>
<span class="sd">            a non-partitioned SYCL device, an instance of</span>
<span class="sd">            :class:`dpctl.SyclQueue`, or a :class:`dpctl.tensor.Device` object</span>
<span class="sd">            returned by :attr:`dpnp.ndarray.device`.</span>
<span class="sd">        stream : {SyclQueue, None}, optional</span>
<span class="sd">            Execution queue to synchronize with. If ``None``, synchronization</span>
<span class="sd">            is not performed.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dpnp.ndarray</span>
<span class="sd">            A view if data copy is not required, and a copy otherwise.</span>
<span class="sd">            If copying is required, it is done by copying from the original</span>
<span class="sd">            allocation device to the host, followed by copying from host</span>
<span class="sd">            to the target device.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np, dpctl</span>
<span class="sd">        &gt;&gt;&gt; x = np.full(100, 2, dtype=np.int64)</span>
<span class="sd">        &gt;&gt;&gt; q_prof = dpctl.SyclQueue(x.sycl_device, property=&quot;enable_profiling&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # return a view with profile-enabled queue</span>
<span class="sd">        &gt;&gt;&gt; y = x.to_device(q_prof)</span>
<span class="sd">        &gt;&gt;&gt; timer = dpctl.SyclTimer()</span>
<span class="sd">        &gt;&gt;&gt; with timer(q_prof):</span>
<span class="sd">        ...     z = y * y</span>
<span class="sd">        &gt;&gt;&gt; print(timer.dt)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">usm_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">to_device</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.tobytes">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.tobytes.html#dpnp.dpnp_array.dpnp_array.tobytes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructs Python bytes containing the raw data bytes in the array.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.tobytes`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {None, &quot;C&quot;, &quot;F&quot;, &quot;A&quot;, &quot;K&quot;}, optional</span>
<span class="sd">            Controls the memory layout of the bytes object.</span>

<span class="sd">            Default: ``&quot;C&quot;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : bytes</span>
<span class="sd">            Python bytes exhibiting a copy of array&#39;s raw data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.frombuffer` : Construct a 1D array from Python bytes.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype=&#39;i2&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.tobytes()</span>
<span class="sd">        b&#39;\x00\x00\x01\x00\x02\x00\x03\x00&#39;</span>
<span class="sd">        &gt;&gt;&gt; x.tobytes(&quot;C&quot;) == x.tobytes()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; x.tobytes(&quot;F&quot;)</span>
<span class="sd">        b&#39;\x00\x00\x02\x00\x01\x00\x03\x00&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.tofile">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.tofile.html#dpnp.dpnp_array.dpnp_array.tofile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the array to a file as text or binary (default).</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.tofile`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fid : {file. str, path}</span>
<span class="sd">            An open file object, or a string containing a filename.</span>
<span class="sd">        sep : str, optional</span>
<span class="sd">            Separator between array items for text output. If ``&quot;&quot;`` (empty),</span>
<span class="sd">            a binary file is written.</span>

<span class="sd">            Default: ``&quot;&quot;``.</span>
<span class="sd">        format : str, optional</span>
<span class="sd">            Format string for text file output (when non-empty `sep` is passed).</span>
<span class="sd">            Each entry in the array is formatted to text by first converting it</span>
<span class="sd">            to the closest Python type, and then using ``format % item``. If</span>
<span class="sd">            ``&quot;&quot;`` (empty), no formatting is used while converting to the</span>
<span class="sd">            string.</span>

<span class="sd">            Default: ``&quot;&quot;``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.fromfile` : Construct an array from data in a text or binary</span>
<span class="sd">            file.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="nb">format</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.tolist">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.tolist.html#dpnp.dpnp_array.dpnp_array.tolist">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the array to a (possibly nested) Python list.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.tolist`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : list</span>
<span class="sd">            The possibly nested Python list of array elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For a 1D array, ``a.tolist()`` is almost the same as ``list(a)``,</span>
<span class="sd">        except that ``tolist`` changes 0D arrays to Python scalars:</span>

<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([1, 2])</span>
<span class="sd">        &gt;&gt;&gt; list(a)</span>
<span class="sd">        [array(1), array(2)]</span>
<span class="sd">        &gt;&gt;&gt; a.tolist()</span>
<span class="sd">        [1, 2]</span>

<span class="sd">        Additionally, for a 2D array, ``tolist`` applies recursively:</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; list(a)</span>
<span class="sd">        [array([1, 2]), array([3, 4])]</span>
<span class="sd">        &gt;&gt;&gt; a.tolist()</span>
<span class="sd">        [[1, 2], [3, 4]]</span>

<span class="sd">        The base case for this recursion is a 0D array:</span>

<span class="sd">        &gt;&gt;&gt; a = np.array(1)</span>
<span class="sd">        &gt;&gt;&gt; list(a)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        ...</span>
<span class="sd">        TypeError: iteration over a 0-d array</span>
<span class="sd">        &gt;&gt;&gt; a.tolist()</span>
<span class="sd">        1</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>


<div class="viewcode-block" id="dpnp_array.trace">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.trace.html#dpnp.dpnp_array.dpnp_array.trace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum along diagonals of the array.</span>

<span class="sd">        Refer to :obj:`dpnp.trace` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.transpose">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.transpose.html#dpnp.dpnp_array.dpnp_array.transpose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">axes</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view of the array with axes transposed.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.transpose`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes : None, tuple or list of ints, n ints, optional</span>
<span class="sd">            * ``None`` or no argument: reverses the order of the axes.</span>
<span class="sd">            * ``tuple or list of ints``: `i` in the `j`-th place in the</span>
<span class="sd">              tuple/list means that the arrays `i`-th axis becomes the</span>
<span class="sd">              transposed arrays `j`-th axis.</span>
<span class="sd">            * ``n ints``: same as an n-tuple/n-list of the same integers (this</span>
<span class="sd">              form is intended simply as a convenience alternative to the</span>
<span class="sd">              tuple form).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        out : dpnp.ndarray</span>
<span class="sd">            View of the array with its axes suitably permuted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :obj:`dpnp.transpose` : Equivalent function.</span>
<span class="sd">        :obj:`dpnp.ndarray.ndarray.T` : Array property returning the array</span>
<span class="sd">            transposed.</span>
<span class="sd">        :obj:`dpnp.ndarray.reshape` : Give a new shape to an array without</span>
<span class="sd">            changing its data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([[1, 2],</span>
<span class="sd">               [3, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a.transpose()</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">               [2, 4]])</span>
<span class="sd">        &gt;&gt;&gt; a.transpose((1, 0))</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">               [2, 4]])</span>

<span class="sd">        &gt;&gt;&gt; a = np.array([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        array([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; a.transpose()</span>
<span class="sd">        array([1, 2, 3, 4])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">axes_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axes_len</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">axes_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">usm_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">T</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># self.transpose().shape == self.shape[::-1]</span>
                <span class="c1"># self.transpose(None).shape == self.shape[::-1]</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">ndim</span> <span class="o">-</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>

            <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">permute_dims</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.var">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.var.html#dpnp.dpnp_array.dpnp_array.var">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">var</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">where</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">correction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the variance of the array elements, along given axis.</span>

<span class="sd">        Refer to :obj:`dpnp.var` for full documentation.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">var</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">axis</span><span class="p">,</span>
            <span class="n">dtype</span><span class="p">,</span>
            <span class="n">out</span><span class="p">,</span>
            <span class="n">ddof</span><span class="p">,</span>
            <span class="n">keepdims</span><span class="p">,</span>
            <span class="n">where</span><span class="o">=</span><span class="n">where</span><span class="p">,</span>
            <span class="n">mean</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span>
            <span class="n">correction</span><span class="o">=</span><span class="n">correction</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="dpnp_array.view">
<a class="viewcode-back" href="../../reference/generated/dpnp.dpnp_array.dpnp_array.view.html#dpnp.dpnp_array.dpnp_array.view">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        New view of array with the same data.</span>

<span class="sd">        For full documentation refer to :obj:`numpy.ndarray.view`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : {None, str, dtype object}, optional</span>
<span class="sd">            The desired data type of the returned view, e.g. :obj:`dpnp.float32`</span>
<span class="sd">            or :obj:`dpnp.int16`. By default, it results in the view having the</span>
<span class="sd">            same data type.</span>

<span class="sd">            Default: ``None``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Passing ``None`` for `dtype` is the same as omitting the parameter,</span>
<span class="sd">        opposite to NumPy where they have different meaning.</span>

<span class="sd">        ``view(some_dtype)`` or ``view(dtype=some_dtype)`` constructs a view of</span>
<span class="sd">        the array&#39;s memory with a different data type. This can cause a</span>
<span class="sd">        reinterpretation of the bytes of memory.</span>

<span class="sd">        Only the last axis has to be contiguous.</span>

<span class="sd">        Limitations</span>
<span class="sd">        -----------</span>
<span class="sd">        Parameter `type` is supported only with default value ``None``.</span>
<span class="sd">        Otherwise, the function raises ``NotImplementedError`` exception.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">        &gt;&gt;&gt; x = np.ones((4,), dtype=np.float32)</span>
<span class="sd">        &gt;&gt;&gt; xv = x.view(dtype=np.int32)</span>
<span class="sd">        &gt;&gt;&gt; xv[:] = 0</span>
<span class="sd">        &gt;&gt;&gt; xv</span>
<span class="sd">        array([0, 0, 0, 0], dtype=int32)</span>

<span class="sd">        However, views that change dtype are totally fine for arrays with a</span>
<span class="sd">        contiguous last axis, even if the rest of the axes are not C-contiguous:</span>

<span class="sd">        &gt;&gt;&gt; x = np.arange(2 * 3 * 4, dtype=np.int8).reshape(2, 3, 4)</span>
<span class="sd">        &gt;&gt;&gt; x.transpose(1, 0, 2).view(np.int16)</span>
<span class="sd">        array([[[ 256,  770],</span>
<span class="sd">                [3340, 3854]],</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">            [[1284, 1798],</span>
<span class="sd">                [4368, 4882]],</span>
<span class="sd">        &lt;BLANKLINE&gt;</span>
<span class="sd">            [[2312, 2826],</span>
<span class="sd">                [5396, 5910]]], dtype=int16)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Keyword argument `type` is supported only with &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;default value ``None``, but got </span><span class="si">{</span><span class="nb">type</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="n">old_sh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">old_strides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strides</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dpnp_array</span><span class="p">(</span><span class="n">old_sh</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">old_strides</span><span class="p">)</span>

        <span class="n">new_dt</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">new_dt</span> <span class="o">=</span> <span class="n">dtu</span><span class="o">.</span><span class="n">_to_device_supported_dtype</span><span class="p">(</span><span class="n">new_dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sycl_device</span><span class="p">)</span>

        <span class="n">new_itemsz</span> <span class="o">=</span> <span class="n">new_dt</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">old_itemsz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="k">if</span> <span class="n">new_itemsz</span> <span class="o">==</span> <span class="n">old_itemsz</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dpnp_array</span><span class="p">(</span>
                <span class="n">old_sh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dt</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">old_strides</span>
            <span class="p">)</span>

        <span class="n">ndim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Changing the dtype of a 0d array is only supported &quot;</span>
                <span class="s2">&quot;if the itemsize is unchanged&quot;</span>
            <span class="p">)</span>

        <span class="c1"># resize on last axis only</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">old_sh</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">old_strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;To change to a dtype of a different size, &quot;</span>
                <span class="s2">&quot;the last axis must be contiguous&quot;</span>
            <span class="p">)</span>

        <span class="c1"># normalize strides whenever itemsize changes</span>
        <span class="k">if</span> <span class="n">old_itemsz</span> <span class="o">&gt;</span> <span class="n">new_itemsz</span><span class="p">:</span>
            <span class="n">new_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">el</span> <span class="o">*</span> <span class="p">(</span><span class="n">old_itemsz</span> <span class="o">//</span> <span class="n">new_itemsz</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">old_strides</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_strides</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">el</span> <span class="o">//</span> <span class="p">(</span><span class="n">new_itemsz</span> <span class="o">//</span> <span class="n">old_itemsz</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">old_strides</span>
            <span class="p">)</span>
        <span class="n">new_strides</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">new_strides</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_strides</span><span class="p">)</span>

        <span class="n">new_dim</span> <span class="o">=</span> <span class="n">old_sh</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">old_itemsz</span>
        <span class="k">if</span> <span class="n">new_dim</span> <span class="o">%</span> <span class="n">new_itemsz</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;When changing to a larger dtype, its size must be a divisor &quot;</span>
                <span class="s2">&quot;of the total size in bytes of the last axis of the array&quot;</span>
            <span class="p">)</span>

        <span class="c1"># normalize shape whenever itemsize changes</span>
        <span class="n">new_sh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">old_sh</span><span class="p">)</span>
        <span class="n">new_sh</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dim</span> <span class="o">//</span> <span class="n">new_itemsz</span>
        <span class="n">new_sh</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_sh</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dpnp_array</span><span class="p">(</span>
            <span class="n">new_sh</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">new_dt</span><span class="p">,</span>
            <span class="n">buffer</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">strides</span><span class="o">=</span><span class="n">new_strides</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">usm_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        USM type of underlying memory. Possible values are:</span>

<span class="sd">        * ``&quot;device&quot;``</span>
<span class="sd">            USM-device allocation in device memory, only accessible to kernels</span>
<span class="sd">            executed on the device</span>
<span class="sd">        * ``&quot;shared&quot;``</span>
<span class="sd">            USM-shared allocation in device memory, accessible both from the</span>
<span class="sd">            device and from the host</span>
<span class="sd">        * ``&quot;host&quot;``</span>
<span class="sd">            USM-host allocation in host memory, accessible both from the device</span>
<span class="sd">            and from the host</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_array_obj</span><span class="o">.</span><span class="n">usm_type</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2025, Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>