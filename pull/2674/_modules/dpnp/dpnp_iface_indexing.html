

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-554F8VNE28"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-554F8VNE28');
    </script>
    
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>dpnp.dpnp_iface_indexing &mdash; Data Parallel Extension for NumPy 0.20.0dev1+45.g4d61556a480 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=2e3f1f4a"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Data Parallel Extension for NumPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick_start_guide.html">Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference/index.html">API Reference</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dpnp_backend_api.html">C++ backend API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Data Parallel Extension for NumPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">dpnp.dpnp_iface_indexing</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for dpnp.dpnp_iface_indexing</h1><div class="highlight"><pre>
<span></span><span class="c1"># *****************************************************************************</span>
<span class="c1"># Copyright (c) 2016, Intel Corporation</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions are met:</span>
<span class="c1"># - Redistributions of source code must retain the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer.</span>
<span class="c1"># - Redistributions in binary form must reproduce the above copyright notice,</span>
<span class="c1">#   this list of conditions and the following disclaimer in the documentation</span>
<span class="c1">#   and/or other materials provided with the distribution.</span>
<span class="c1"># - Neither the name of the copyright holder nor the names of its contributors</span>
<span class="c1">#   may be used to endorse or promote products derived from this software</span>
<span class="c1">#   without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="c1"># AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="c1"># IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span class="c1"># ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE</span>
<span class="c1"># LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span>
<span class="c1"># CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span>
<span class="c1"># SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span>
<span class="c1"># INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span>
<span class="c1"># CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span>
<span class="c1"># ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF</span>
<span class="c1"># THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1"># *****************************************************************************</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Interface of the Indexing part of the DPNP</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">This module is a face or public interface file for the library</span>
<span class="sd">it contains:</span>
<span class="sd"> - Interface functions</span>
<span class="sd"> - documentation for the functions</span>
<span class="sd"> - The functions parameters check</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># pylint: disable=protected-access</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.tensor</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.tensor._tensor_impl</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ti</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dpctl.utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">dpu</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._copy_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">_nonzero_impl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._indexing_functions</span><span class="w"> </span><span class="kn">import</span> <span class="n">_get_indexing_mode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dpctl.tensor._numpy_helper</span><span class="w"> </span><span class="kn">import</span> <span class="n">normalize_axis_index</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp</span>

<span class="c1"># pylint: disable=no-name-in-module</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dpnp.backend.extensions.indexing._indexing_impl</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">indexing_ext</span>

<span class="c1"># pylint: disable=no-name-in-module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_algo</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">dpnp_putmask</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_array</span><span class="w"> </span><span class="kn">import</span> <span class="n">dpnp_array</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.dpnp_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">call_origin</span><span class="p">,</span> <span class="n">get_usm_allocations</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ravel_multi_index_checks</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;parameter multi_index must be a sequence of length </span><span class="si">{</span><span class="n">ndim</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="n">dim_mul</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="si">}</span><span class="s2"> object cannot be interpreted as an integer&quot;</span>
            <span class="p">)</span>
        <span class="n">dim_mul</span> <span class="o">*=</span> <span class="n">d</span>

    <span class="k">if</span> <span class="n">dim_mul</span> <span class="o">&gt;</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;invalid dims: array size defined by dims is larger than the &quot;</span>
            <span class="s2">&quot;maximum possible size&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unrecognized `order` keyword value, expecting &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;C&#39; or &#39;F&#39;, but got &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_choices_list</span><span class="p">(</span><span class="n">choices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Gather queues and USM types for the input, expected to be an array or</span>
<span class="sd">    list of arrays. If a single array of dimension greater than one, the array</span>
<span class="sd">    will be unstacked.</span>

<span class="sd">    Returns a list of :class:`dpctl.tensor.usm_ndarray`s.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">choices</span><span class="p">):</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">choices</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`choices` must be an array or sequence of arrays&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">chc</span><span class="p">)</span> <span class="k">for</span> <span class="n">chc</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_choose_run</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">chcs</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">usm_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># arg validation, broadcasting, type coercion assumed done by caller</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;provided `out` array is read-only&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The shape of input and output arrays are inconsistent. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected output shape is </span><span class="si">{</span><span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">chcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output array of type </span><span class="si">{</span><span class="n">chcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> is needed, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dpu</span><span class="o">.</span><span class="n">get_execution_queue</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">dpu</span><span class="o">.</span><span class="n">ExecutionPlacementError</span><span class="p">(</span>
                <span class="s2">&quot;Input and output allocation queues are not compatible&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">ti</span><span class="o">.</span><span class="n">_array_overlap</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span>
            <span class="n">ti</span><span class="o">.</span><span class="n">_array_overlap</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">chc</span><span class="p">)</span> <span class="k">for</span> <span class="n">chc</span> <span class="ow">in</span> <span class="n">chcs</span>
        <span class="p">):</span>
            <span class="c1"># Allocate a temporary buffer to avoid memory overlapping.</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="n">inds</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">chcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">q</span>
        <span class="p">)</span>

    <span class="n">_manager</span> <span class="o">=</span> <span class="n">dpu</span><span class="o">.</span><span class="n">SequentialOrderManager</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
    <span class="n">dep_evs</span> <span class="o">=</span> <span class="n">_manager</span><span class="o">.</span><span class="n">submitted_events</span>

    <span class="n">h_ev</span><span class="p">,</span> <span class="n">choose_ev</span> <span class="o">=</span> <span class="n">indexing_ext</span><span class="o">.</span><span class="n">_choose</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">chcs</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">dep_evs</span><span class="p">)</span>
    <span class="n">_manager</span><span class="o">.</span><span class="n">add_event_pair</span><span class="p">(</span><span class="n">h_ev</span><span class="p">,</span> <span class="n">choose_ev</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="choose">
<a class="viewcode-back" href="../../reference/generated/dpnp.choose.html#dpnp.choose">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array from an index array and a set of arrays to choose from.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.choose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        An integer array of indices indicating the position of the array</span>
<span class="sd">        in `choices` to choose from. Behavior of out-of-bounds integers (i.e.,</span>
<span class="sd">        integers outside of `[0, n-1]` where `n` is the number of choices) is</span>
<span class="sd">        determined by the `mode` keyword.</span>
<span class="sd">    choices : {dpnp.ndarray, usm_ndarray, \</span>
<span class="sd">               sequence of dpnp.ndarrays and usm_ndarrays}</span>
<span class="sd">        Choice arrays. `a` and choice arrays must be broadcast-compatible.</span>
<span class="sd">        If `choices` is an array, the array is unstacked into a sequence of</span>
<span class="sd">        arrays.</span>
<span class="sd">    out : {None, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        If provided, the result will be placed in this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    mode : {&quot;wrap&quot;, &quot;clip&quot;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will be handled. Possible values</span>
<span class="sd">        are:</span>

<span class="sd">        - ``&quot;wrap&quot;``: clamps indices to (``-n &lt;= i &lt; n``), then wraps</span>
<span class="sd">          negative indices.</span>
<span class="sd">        - ``&quot;clip&quot;``: clips indices to (``0 &lt;= i &lt; n``).</span>

<span class="sd">        Default: ``&quot;wrap&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The merged result.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndarray.choose` : Equivalent method.</span>
<span class="sd">    :obj:`dpnp.take_along_axis` : Preferable if `choices` is an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; choices = np.array([[0, 1, 2, 3], [10, 11, 12, 13],</span>
<span class="sd">    ...   [20, 21, 22, 23], [30, 31, 32, 33]])</span>
<span class="sd">    &gt;&gt;&gt; np.choose(np.array([2, 3, 1, 0]), choices</span>
<span class="sd">    ... # the first element of the result will be the first element of the</span>
<span class="sd">    ... # third (2+1) &quot;array&quot; in choices, namely, 20; the second element</span>
<span class="sd">    ... # will be the second element of the fourth (3+1) choice array, i.e.,</span>
<span class="sd">    ... # 31, etc.</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.choose(np.array([2, 4, 1, 0]), choices, mode=&#39;clip&#39;</span>
<span class="sd">    ... # 4 goes to 3 (4-1)</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12, 3])</span>
<span class="sd">    &gt;&gt;&gt; # because there are 4 choice arrays</span>
<span class="sd">    &gt;&gt;&gt; np.choose(np.array([2, 4, 1, 0]), choices, mode=&#39;wrap&#39;</span>
<span class="sd">    ... # 4 is clipped to 3</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.choose(np.array([2, -1, 1, 0]), choices, mode=&#39;wrap&#39;</span>
<span class="sd">    ... # -1 goes to 3 (-1+4)</span>
<span class="sd">    ... )</span>
<span class="sd">    array([20, 31, 12, 3])</span>

<span class="sd">    An example using broadcasting:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; choices = np.array([-10, 10])</span>
<span class="sd">    &gt;&gt;&gt; np.choose(a, choices)</span>
<span class="sd">    array([[ 10, -10,  10],</span>
<span class="sd">           [-10,  10, -10],</span>
<span class="sd">           [ 10, -10,  10]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_get_indexing_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">inds</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">ind_dt</span> <span class="o">=</span> <span class="n">inds</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">ind_dt</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="c1"># NumPy will cast up to int64 in general but</span>
        <span class="c1"># int32 is more than safe for bool</span>
        <span class="k">if</span> <span class="n">ind_dt</span> <span class="o">==</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;input index array must be of integer data type&quot;</span><span class="p">)</span>

    <span class="n">choices</span> <span class="o">=</span> <span class="n">_build_choices_list</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>

    <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">(</span><span class="n">choices</span> <span class="o">+</span> <span class="p">[</span><span class="n">inds</span><span class="p">])</span>
    <span class="c1"># apply type promotion to input choices</span>
    <span class="n">res_dt</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">choices</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">choices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">chc</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">chc</span> <span class="k">if</span> <span class="n">chc</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">res_dt</span> <span class="k">else</span> <span class="n">dpt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">chc</span><span class="p">,</span> <span class="n">res_dt</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">choices</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="n">arrs_broadcast</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">arrs_broadcast</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">choices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arrs_broadcast</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_choose_run</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_result_array</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_take_index</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">inds</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">usm_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="c1"># arg validation assumed done by caller</span>
    <span class="n">x_sh</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">axis_end</span> <span class="o">=</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">x_sh</span><span class="p">[</span><span class="n">axis</span><span class="p">:</span><span class="n">axis_end</span><span class="p">]</span> <span class="ow">and</span> <span class="n">inds</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;cannot take non-empty indices from an empty axis&quot;</span><span class="p">)</span>
    <span class="n">res_sh</span> <span class="o">=</span> <span class="n">x_sh</span><span class="p">[:</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="n">inds</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">x_sh</span><span class="p">[</span><span class="n">axis_end</span><span class="p">:]</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">writable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;provided `out` array is read-only&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">res_sh</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The shape of input and output arrays are inconsistent. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Expected output shape is </span><span class="si">{</span><span class="n">res_sh</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output array of type </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> is needed, &quot;</span> <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">dpu</span><span class="o">.</span><span class="n">get_execution_queue</span><span class="p">((</span><span class="n">q</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">))</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">dpu</span><span class="o">.</span><span class="n">ExecutionPlacementError</span><span class="p">(</span>
                <span class="s2">&quot;Input and output allocation queues are not compatible&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">ti</span><span class="o">.</span><span class="n">_array_overlap</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
            <span class="c1"># Allocate a temporary buffer to avoid memory overlapping.</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">res_sh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">q</span><span class="p">)</span>

    <span class="n">_manager</span> <span class="o">=</span> <span class="n">dpu</span><span class="o">.</span><span class="n">SequentialOrderManager</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
    <span class="n">dep_evs</span> <span class="o">=</span> <span class="n">_manager</span><span class="o">.</span><span class="n">submitted_events</span>

    <span class="n">h_ev</span><span class="p">,</span> <span class="n">take_ev</span> <span class="o">=</span> <span class="n">ti</span><span class="o">.</span><span class="n">_take</span><span class="p">(</span>
        <span class="n">src</span><span class="o">=</span><span class="n">x</span><span class="p">,</span>
        <span class="n">ind</span><span class="o">=</span><span class="p">(</span><span class="n">inds</span><span class="p">,),</span>
        <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
        <span class="n">axis_start</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
        <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">q</span><span class="p">,</span>
        <span class="n">depends</span><span class="o">=</span><span class="n">dep_evs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">_manager</span><span class="o">.</span><span class="n">add_event_pair</span><span class="p">(</span><span class="n">h_ev</span><span class="p">,</span> <span class="n">take_ev</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span>


<div class="viewcode-block" id="compress">
<a class="viewcode-back" href="../../reference/generated/dpnp.compress.html#dpnp.compress">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return selected slices of an array along given axis.</span>

<span class="sd">    A slice of `a` is returned for each index along `axis` where `condition`</span>
<span class="sd">    is ``True``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.choose`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : {array_like, dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array that selects which entries to extract. If the length of</span>
<span class="sd">        `condition` is less than the size of `a` along `axis`, then</span>
<span class="sd">        the output is truncated to the length of `condition`.</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to extract from.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        Axis along which to extract slices. If ``None``, works over the</span>
<span class="sd">        flattened array.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    out : {None, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        If provided, the result will be placed in this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        A copy of the slices of `a` where `condition` is ``True``.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.take` :  Take elements from an array along an axis.</span>
<span class="sd">    :obj:`dpnp.choose` : Construct an array from an index array and a set of</span>
<span class="sd">                         arrays to choose from.</span>
<span class="sd">    :obj:`dpnp.diag` : Extract a diagonal or construct a diagonal array.</span>
<span class="sd">    :obj:`dpnp.diagonal` : Return specified diagonals.</span>
<span class="sd">    :obj:`dpnp.select` : Return an array drawn from elements in `choicelist`,</span>
<span class="sd">                         depending on conditions.</span>
<span class="sd">    :obj:`dpnp.ndarray.compress` : Equivalent method.</span>
<span class="sd">    :obj:`dpnp.extract` : Equivalent function when working on 1-D arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([0, 1], a, axis=0)</span>
<span class="sd">    array([[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True, True], a, axis=0)</span>
<span class="sd">    array([[3, 4],</span>
<span class="sd">           [5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a, axis=1)</span>
<span class="sd">    array([[2],</span>
<span class="sd">           [4],</span>
<span class="sd">           [6]])</span>

<span class="sd">    Working on the flattened array does not return slices along an axis but</span>
<span class="sd">    selects elements.</span>

<span class="sd">    &gt;&gt;&gt; np.compress([False, True], a)</span>
<span class="sd">    array([2])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

    <span class="n">a_ary</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">cond_ary</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">condition</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">a_ary</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a_ary</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">cond_ary</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;`condition` must be a 1-D array or un-nested sequence&quot;</span>
        <span class="p">)</span>

    <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">a_ary</span><span class="p">,</span> <span class="n">cond_ary</span><span class="p">])</span>

    <span class="c1"># _nonzero_impl synchronizes and returns a tuple of usm_ndarray indices</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">_nonzero_impl</span><span class="p">(</span><span class="n">cond_ary</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">_take_index</span><span class="p">(</span><span class="n">a_ary</span><span class="p">,</span> <span class="n">inds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_result_array</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="diag_indices">
<a class="viewcode-back" href="../../reference/generated/dpnp.diag_indices.html#dpnp.diag_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diag_indices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ndim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices to access the main diagonal of an array.</span>

<span class="sd">    This returns a tuple of indices that can be used to access the main</span>
<span class="sd">    diagonal of an array `a` with ``a.ndim &gt;= 2`` dimensions and shape</span>
<span class="sd">    (n, n, ..., n). For ``a.ndim = 2`` this is the usual diagonal, for</span>
<span class="sd">    ``a.ndim &gt; 2`` this is the set of indices to access ``a[i, i, ..., i]``</span>
<span class="sd">    for ``i = [0..n-1]``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.diag_indices`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The size, along each dimension, of the arrays for which the returned</span>
<span class="sd">        indices can be used.</span>
<span class="sd">    ndim : int, optional</span>
<span class="sd">        The number of dimensions.</span>

<span class="sd">        Default: ``2``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {&quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``&quot;device&quot;``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple of dpnp.ndarray</span>
<span class="sd">        The indices to access the main diagonal of an array.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.diag_indices_from` : Return the indices to access the main</span>
<span class="sd">                                    diagonal of an n-dimensional array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a set of indices to access the diagonal of a (4, 4) array:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; di = np.diag_indices(4)</span>
<span class="sd">    &gt;&gt;&gt; di</span>
<span class="sd">    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>
<span class="sd">    &gt;&gt;&gt; a[di] = 100</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[100,   1,   2,   3],</span>
<span class="sd">           [  4, 100,   6,   7],</span>
<span class="sd">           [  8,   9, 100,  11],</span>
<span class="sd">           [ 12,  13,  14, 100]])</span>

<span class="sd">    Now, we create indices to manipulate a 3-D array:</span>

<span class="sd">    &gt;&gt;&gt; d3 = np.diag_indices(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; d3</span>
<span class="sd">    (array([0, 1]), array([0, 1]), array([0, 1]))</span>

<span class="sd">    And use it to set the diagonal of an array of zeros to 1:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((2, 2, 2), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; a[d3] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[[1, 0],</span>
<span class="sd">            [0, 0]],</span>
<span class="sd">           [[0, 0],</span>
<span class="sd">            [0, 1]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span></div>



<div class="viewcode-block" id="diag_indices_from">
<a class="viewcode-back" href="../../reference/generated/dpnp.diag_indices_from.html#dpnp.diag_indices_from">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diag_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices to access the main diagonal of an n-dimensional array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.diag_indices_from`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array at least 2-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple of dpnp.ndarray</span>
<span class="sd">        The indices to access the main diagonal of an n-dimensional array.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.diag_indices` : Return the indices to access the main diagonal</span>
<span class="sd">                               of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a 4 by 4 array.</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>

<span class="sd">    Get the indices of the diagonal elements.</span>

<span class="sd">    &gt;&gt;&gt; di = np.diag_indices_from(a)</span>
<span class="sd">    &gt;&gt;&gt; di</span>
<span class="sd">    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>

<span class="sd">    &gt;&gt;&gt; a[di]</span>
<span class="sd">    array([ 0,  5, 10, 15])</span>

<span class="sd">    This is simply syntactic sugar for diag_indices.</span>

<span class="sd">    &gt;&gt;&gt; np.diag_indices(a.shape[0])</span>
<span class="sd">    (array([0, 1, 2, 3]), array([0, 1, 2, 3]))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be at least 2-d&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions of input must be of equal length&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">diag_indices</span><span class="p">(</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="diagonal">
<a class="viewcode-back" href="../../reference/generated/dpnp.diagonal.html#dpnp.diagonal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return specified diagonals.</span>

<span class="sd">    This function always returns a read/write view, and writing to</span>
<span class="sd">    the returned array will alter your original array.</span>

<span class="sd">    If you need to modify the array returned by this function without affecting</span>
<span class="sd">    the original array, we suggest copying the returned array explicitly, i.e.,</span>
<span class="sd">    use ``dpnp.diagonal(a).copy()`` instead of ``dpnp.diagonal(a)``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.diagonal`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array from which the diagonals are taken.</span>
<span class="sd">    offset : int, optional</span>
<span class="sd">        Offset of the diagonal from the main diagonal. Can be positive or</span>
<span class="sd">        negative. Defaults to main diagonal.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    axis1 : int, optional</span>
<span class="sd">        Axis to be used as the first axis of the 2-D sub-arrays from which</span>
<span class="sd">        the diagonals should be taken. Defaults to first axis.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    axis2 : int, optional</span>
<span class="sd">        Axis to be used as the second axis of the 2-D sub-arrays from</span>
<span class="sd">        which the diagonals should be taken. Defaults to second axis.</span>

<span class="sd">        Default: ``1``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_of_diagonals : dpnp.ndarray</span>
<span class="sd">        Array is a read/write view.</span>
<span class="sd">        If `a` is 2-D, then a 1-D array containing the diagonal and of the</span>
<span class="sd">        same type as `a` is returned.</span>
<span class="sd">        If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`</span>
<span class="sd">        are removed, and a new axis inserted at the end corresponding to the</span>
<span class="sd">        diagonal.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.linalg.diagonal` : Array API compatible version.</span>
<span class="sd">    :obj:`dpnp.diag` : Extract a diagonal or construct a diagonal array.</span>
<span class="sd">    :obj:`dpnp.diagflat` : Create a two-dimensional array</span>
<span class="sd">                           with the flattened input as a diagonal.</span>
<span class="sd">    :obj:`dpnp.trace` : Return the sum along diagonals of the array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4).reshape(2, 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal()</span>
<span class="sd">    array([0, 3])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(1)</span>
<span class="sd">    array([1])</span>

<span class="sd">    A 3-D example:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(8).reshape(2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[[0, 1],</span>
<span class="sd">            [2, 3]],</span>
<span class="sd">           [[4, 5],</span>
<span class="sd">            [6, 7]]])</span>
<span class="sd">    &gt;&gt;&gt; a.diagonal(0,  # Main diagonals of two arrays created by skipping</span>
<span class="sd">    ...            0,  # across the outer(left)-most axis last and</span>
<span class="sd">    ...            1)  # the &quot;middle&quot; (row) axis first.</span>
<span class="sd">    array([[0, 6],</span>
<span class="sd">           [1, 7]])</span>

<span class="sd">    The sub-arrays whose main diagonals we just obtained; note that each</span>
<span class="sd">    corresponds to fixing the right-most (column) axis, and that the</span>
<span class="sd">    diagonals are &quot;packed&quot; in rows.</span>

<span class="sd">    &gt;&gt;&gt; a[:,:,0]  # main diagonal is [0 6]</span>
<span class="sd">    array([[0, 2],</span>
<span class="sd">           [4, 6]])</span>
<span class="sd">    &gt;&gt;&gt; a[:,:,1]  # main diagonal is [1 7]</span>
<span class="sd">    array([[1, 3],</span>
<span class="sd">           [5, 7]])</span>

<span class="sd">    The anti-diagonal can be obtained by reversing the order of elements</span>
<span class="sd">    using either :obj:`dpnp.flipud` or :obj:`dpnp.fliplr`.</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.fliplr(a).diagonal()  # Horizontal flip</span>
<span class="sd">    array([2, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.flipud(a).diagonal()  # Vertical flip</span>
<span class="sd">    array([6, 4, 2])</span>

<span class="sd">    Note that the order in which the diagonal is retrieved varies depending</span>
<span class="sd">    on the flip function.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diag requires an array of at least two dimensions&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;`offset` must be an integer data type, but got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">axis1</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
    <span class="n">axis2</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">axis2</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis1</span> <span class="o">==</span> <span class="n">axis2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`axis1` and `axis2` cannot be the same&quot;</span><span class="p">)</span>

    <span class="c1"># get list of the order of all axes excluding the two target axes</span>
    <span class="n">axes_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">]]</span>

    <span class="c1"># transpose the input array to put the target axes at the end</span>
    <span class="c1"># to simplify diagonal extraction</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes_order</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes_order</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis2</span><span class="p">,</span> <span class="n">axis1</span><span class="p">])</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">offset</span>

    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">a_straides</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">strides</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="n">st_n</span><span class="p">,</span> <span class="n">st_m</span> <span class="o">=</span> <span class="n">a_straides</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
    <span class="c1"># pylint: disable=W0212</span>
    <span class="n">a_element_offset</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">_element_offset</span>

    <span class="c1"># Compute shape, strides and offset of the resulting diagonal array</span>
    <span class="c1"># based on the input offset</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),)</span>
        <span class="n">out_strides</span> <span class="o">=</span> <span class="n">a_straides</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">st_n</span> <span class="o">+</span> <span class="n">st_m</span><span class="p">,)</span>
        <span class="n">out_offset</span> <span class="o">=</span> <span class="n">a_element_offset</span>
    <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">offset</span><span class="p">),)</span>
        <span class="n">out_strides</span> <span class="o">=</span> <span class="n">a_straides</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">st_n</span> <span class="o">+</span> <span class="n">st_m</span><span class="p">,)</span>
        <span class="n">out_offset</span> <span class="o">=</span> <span class="n">a_element_offset</span> <span class="o">+</span> <span class="n">st_m</span> <span class="o">*</span> <span class="n">offset</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out_shape</span> <span class="o">=</span> <span class="n">a_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="p">,)</span>
        <span class="n">out_strides</span> <span class="o">=</span> <span class="n">a_straides</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="n">out_offset</span> <span class="o">=</span> <span class="n">a_element_offset</span>

    <span class="k">return</span> <span class="n">dpnp_array</span><span class="p">(</span>
        <span class="n">out_shape</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">out_strides</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">out_offset</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="extract">
<a class="viewcode-back" href="../../reference/generated/dpnp.extract.html#dpnp.extract">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the elements of an array that satisfy some condition.</span>

<span class="sd">    This is equivalent to</span>
<span class="sd">    ``dpnp.compress(dpnp.ravel(condition), dpnp.ravel(a))``. If `condition`</span>
<span class="sd">    is boolean :obj:`dpnp.extract` is equivalent to ``a[condition]``.</span>

<span class="sd">    Note that :obj:`dpnp.place` does the exact opposite of :obj:`dpnp.extract`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.extract`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : {array_like, scalar}</span>
<span class="sd">        An array whose non-zero or ``True`` entries indicate the element of `a`</span>
<span class="sd">        to extract.</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array of the same size as `condition`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Rank 1 array of values from `a` where `condition` is ``True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.take` : Take elements from an array along an axis.</span>
<span class="sd">    :obj:`dpnp.put` : Replaces specified elements of an array with given values.</span>
<span class="sd">    :obj:`dpnp.copyto` : Copies values from one array to another, broadcasting</span>
<span class="sd">                         as necessary.</span>
<span class="sd">    :obj:`dpnp.compress` : Return selected slices of an array along given axis.</span>
<span class="sd">    :obj:`dpnp.place` : Change elements of an array based on conditional and</span>
<span class="sd">                        input values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(12).reshape((3, 4))</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11]])</span>
<span class="sd">    &gt;&gt;&gt; condition = np.mod(a, 3) == 0</span>
<span class="sd">    &gt;&gt;&gt; condition</span>
<span class="sd">    array([[ True, False, False,  True],</span>
<span class="sd">           [False, False,  True, False],</span>
<span class="sd">           [False,  True, False, False]])</span>
<span class="sd">    &gt;&gt;&gt; np.extract(condition, a)</span>
<span class="sd">    array([0, 3, 6, 9])</span>

<span class="sd">    If `condition` is boolean:</span>

<span class="sd">    &gt;&gt;&gt; a[condition]</span>
<span class="sd">    array([0, 3, 6, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">condition</span><span class="p">])</span>
    <span class="n">usm_cond</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">condition</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">exec_q</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">usm_cond</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">usm_cond</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_cond</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">dpt</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">usm_cond</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">usm_cond</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">usm_cond</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_cond</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">usm_cond</span><span class="p">,</span> <span class="n">usm_a</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="fill_diagonal">
<a class="viewcode-back" href="../../reference/generated/dpnp.fill_diagonal.html#dpnp.fill_diagonal">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fill_diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill the main diagonal of the given array of any dimensionality.</span>

<span class="sd">    For an array `a` with ``a.ndim &gt;= 2``, the diagonal is the list of values</span>
<span class="sd">    ``a[i, ..., i]`` with indices ``i`` all identical. This function modifies</span>
<span class="sd">    the input array in-place without returning a value.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.fill_diagonal`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array whose diagonal is to be filled in-place. It must be at least 2-D.</span>
<span class="sd">    val : {dpnp.ndarray, usm_ndarray, scalar}</span>
<span class="sd">        Value(s) to write on the diagonal. If `val` is scalar, the value is</span>
<span class="sd">        written along the diagonal. If array, the flattened `val` is</span>
<span class="sd">        written along the diagonal, repeating if necessary to fill all</span>
<span class="sd">        diagonal entries.</span>
<span class="sd">    wrap : bool</span>
<span class="sd">        It enables the diagonal &quot;wrapped&quot; after N columns. This affects only</span>
<span class="sd">        tall matrices.</span>

<span class="sd">        Default: ``False``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.diag_indices` : Return the indices to access the main diagonal</span>
<span class="sd">                               of an array.</span>
<span class="sd">    :obj:`dpnp.diag_indices_from` : Return the indices to access the main</span>
<span class="sd">                                    diagonal of an n-dimensional array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(a, 5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[5, 0, 0],</span>
<span class="sd">           [0, 5, 0],</span>
<span class="sd">           [0, 0, 5]])</span>

<span class="sd">    The same function can operate on a 4-D array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3, 3, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(a, 4)</span>

<span class="sd">    We only show a few blocks for clarity:</span>

<span class="sd">    &gt;&gt;&gt; a[0, 0]</span>
<span class="sd">    array([[4, 0, 0],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1]</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 4, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a[2, 2]</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [0, 0, 4]])</span>

<span class="sd">    The `wrap` option affects only tall matrices:</span>

<span class="sd">    &gt;&gt;&gt; # tall matrices no wrap</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(a, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[4, 0, 0],</span>
<span class="sd">           [0, 4, 0],</span>
<span class="sd">           [0, 0, 4],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [0, 0, 0]])</span>

<span class="sd">    &gt;&gt;&gt; # tall matrices wrap</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((5, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(a, 4, wrap=True)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[4, 0, 0],</span>
<span class="sd">           [0, 4, 0],</span>
<span class="sd">           [0, 0, 4],</span>
<span class="sd">           [0, 0, 0],</span>
<span class="sd">           [4, 0, 0]])</span>

<span class="sd">    &gt;&gt;&gt; # wide matrices</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 5), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(a, 4, wrap=True)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[4, 0, 0, 0, 0],</span>
<span class="sd">           [0, 4, 0, 0, 0],</span>
<span class="sd">           [0, 0, 4, 0, 0]])</span>

<span class="sd">    The anti-diagonal can be filled by reversing the order of elements</span>
<span class="sd">    using either `dpnp.flipud` or `dpnp.fliplr`.</span>

<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)</span>
<span class="sd">    &gt;&gt;&gt; val = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(np.fliplr(a), val)  # Horizontal flip</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 1],</span>
<span class="sd">           [0, 2, 0],</span>
<span class="sd">           [3, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.fill_diagonal(np.flipud(a), val)  # Vertical flip</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 3],</span>
<span class="sd">           [0, 2, 0],</span>
<span class="sd">           [1, 0, 0]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_val</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray_or_scalar</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array must be at least 2-d&quot;</span><span class="p">)</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">wrap</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions of input must be of equal length&quot;</span><span class="p">)</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

    <span class="c1"># TODO: implement flatiter for slice key</span>
    <span class="c1"># a.flat[:end:step] = val</span>
    <span class="c1"># but need to consider use case when `a` is usm_ndarray also</span>
    <span class="n">a_sh</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">usm_val</span><span class="p">):</span>
        <span class="n">tmp_a</span><span class="p">[:</span><span class="n">end</span><span class="p">:</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">usm_val</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usm_val</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_val</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Setitem can work only if index size equal val size.</span>
        <span class="c1"># Using loop for general case without dependencies of val size.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">usm_val</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">tmp_a</span><span class="p">[</span><span class="n">step</span> <span class="o">*</span> <span class="n">i</span> <span class="p">:</span> <span class="n">end</span> <span class="p">:</span> <span class="n">step</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">usm_val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">tmp_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tmp_a</span><span class="p">,</span> <span class="n">a_sh</span><span class="p">)</span>
    <span class="n">usm_a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">tmp_a</span></div>



<div class="viewcode-block" id="flatnonzero">
<a class="viewcode-back" href="../../reference/generated/dpnp.flatnonzero.html#dpnp.flatnonzero">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flatnonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return indices that are non-zero in the flattened version of `a`.</span>

<span class="sd">    This is equivalent to ``dpnp.nonzero(dpnp.ravel(a))[0]``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.flatnonzero`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input data.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        Output array, containing the indices of the elements of ``a.ravel()``</span>
<span class="sd">        that are non-zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.nonzero` : Return the indices of the non-zero elements of</span>
<span class="sd">                          the input array.</span>
<span class="sd">    :obj:`dpnp.ravel` : Return a 1-D array containing the elements of</span>
<span class="sd">                        the input array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(-2, 3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([-2, -1,  0,  1,  2])</span>
<span class="sd">    &gt;&gt;&gt; np.flatnonzero(x)</span>
<span class="sd">    array([0, 1, 3, 4])</span>

<span class="sd">    Use the indices of the non-zero elements as an index array to extract</span>
<span class="sd">    these elements:</span>

<span class="sd">    &gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]</span>
<span class="sd">    array([-2, -1,  1,  2])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="indices">
<a class="viewcode-back" href="../../reference/generated/dpnp.indices.html#dpnp.indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">indices</span><span class="p">(</span>
    <span class="n">dimensions</span><span class="p">,</span>
    <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span>
    <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array representing the indices of a grid.</span>

<span class="sd">    Compute an array where the subarrays contain index values 0, 1, </span>
<span class="sd">    varying only along the corresponding axis.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.indices`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : sequence of ints</span>
<span class="sd">        The shape of the grid.</span>
<span class="sd">    dtype : {None, str, dtype object}, optional</span>
<span class="sd">        Data type of the result.</span>

<span class="sd">        Default: ``int``.</span>
<span class="sd">    sparse : {None, boolean}, optional</span>
<span class="sd">        Return a sparse representation of the grid instead of a dense</span>
<span class="sd">        representation.</span>

<span class="sd">        Default is ``False``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {&quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``&quot;device&quot;``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : one dpnp.ndarray or tuple of dpnp.ndarray</span>
<span class="sd">        If sparse is ``False``:</span>
<span class="sd">        Returns one array of grid indices,</span>
<span class="sd">        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.</span>

<span class="sd">        If sparse is ``True``:</span>
<span class="sd">        Returns a tuple of arrays,</span>
<span class="sd">        with grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)</span>
<span class="sd">        with dimensions[i] in the i-th place.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.mgrid` : Return a dense multi-dimensional meshgrid.</span>
<span class="sd">    :obj:`dpnp.ogrid` : Return an open multi-dimensional meshgrid.</span>
<span class="sd">    :obj:`dpnp.meshgrid` : Return a tuple of coordinate matrices from</span>
<span class="sd">                           coordinate vectors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; grid = np.indices((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; grid.shape</span>
<span class="sd">    (2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; grid[0]</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; grid[1]</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [0, 1, 2]])</span>

<span class="sd">    The indices can be used as an index into an array.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(20).reshape(5, 4)</span>
<span class="sd">    &gt;&gt;&gt; row, col = np.indices((2, 3))</span>
<span class="sd">    &gt;&gt;&gt; x[row, col]</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [4, 5, 6]])</span>

<span class="sd">    Note that it would be more straightforward in the above example to</span>
<span class="sd">    extract the required elements directly with ``x[:2, :3]``.</span>
<span class="sd">    If sparse is set to ``True``, the grid will be returned in a sparse</span>
<span class="sd">    representation.</span>

<span class="sd">    &gt;&gt;&gt; i, j = np.indices((2, 3), sparse=True)</span>
<span class="sd">    &gt;&gt;&gt; i.shape</span>
<span class="sd">    (2, 1)</span>
<span class="sd">    &gt;&gt;&gt; j.shape</span>
<span class="sd">    (1, 3)</span>
<span class="sd">    &gt;&gt;&gt; i</span>
<span class="sd">    array([[0],</span>
<span class="sd">           [1]])</span>
<span class="sd">    &gt;&gt;&gt; j</span>
<span class="sd">    array([[0, 1, 2]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dimensions</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>

        <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="iterable">
<a class="viewcode-back" href="../../reference/generated/dpnp.iterable.html#dpnp.iterable">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether or not an object can be iterated over.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.iterable`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : object</span>
<span class="sd">        Input object.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : bool</span>
<span class="sd">        Return ``True`` if the object has an iterator method or is a sequence</span>
<span class="sd">        and ``False`` otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.iterable([1, 2, 3])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.iterable(2)</span>
<span class="sd">    False</span>

<span class="sd">    In most cases, the results of ``np.iterable(obj)`` are consistent with</span>
<span class="sd">    ``isinstance(obj, collections.abc.Iterable)``. One notable exception is</span>
<span class="sd">    the treatment of 0-dimensional arrays:</span>

<span class="sd">    &gt;&gt;&gt; from collections.abc import Iterable</span>
<span class="sd">    &gt;&gt;&gt; a = np.array(1.0)  # 0-dimensional array</span>
<span class="sd">    &gt;&gt;&gt; isinstance(a, Iterable)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.iterable(a)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>



<div class="viewcode-block" id="ix_">
<a class="viewcode-back" href="../../reference/generated/dpnp.ix_.html#dpnp.ix_">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct an open mesh from multiple sequences.</span>

<span class="sd">    This function takes N 1-D sequences and returns N outputs with N</span>
<span class="sd">    dimensions each, such that the shape is 1 in all but one dimension</span>
<span class="sd">    and the dimension with the non-unit shape value cycles through all</span>
<span class="sd">    N dimensions.</span>

<span class="sd">    Using :obj:`dpnp.ix_` one can quickly construct index arrays that will</span>
<span class="sd">    index the cross product. ``a[dpnp.ix_([1, 3],[2, 5])]`` returns the array</span>
<span class="sd">    ``[[a[1, 2] a[1, 5]], [a[3, 2] a[3, 5]]]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x1, x2,..., xn : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        1-D sequences. Each sequence should be of integer or boolean type.</span>
<span class="sd">        Boolean sequences will be interpreted as boolean masks for the</span>
<span class="sd">        corresponding dimension (equivalent to passing in</span>
<span class="sd">        ``dpnp.nonzero(boolean_sequence)``).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple of dpnp.ndarray</span>
<span class="sd">        N arrays with N dimensions each, with N the number of input sequences.</span>
<span class="sd">        Together these arrays form an open mesh.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.mgrid` : Return a dense multi-dimensional meshgrid.</span>
<span class="sd">    :obj:`dpnp.ogrid` : Return an open multi-dimensional meshgrid.</span>
<span class="sd">    :obj:`dpnp.meshgrid` : Return a tuple of coordinate matrices from</span>
<span class="sd">                           coordinate vectors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(10).reshape(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2, 3, 4],</span>
<span class="sd">           [5, 6, 7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.array([0, 1])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.array([2, 4])</span>
<span class="sd">    &gt;&gt;&gt; ixgrid = np.ix_(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; ixgrid</span>
<span class="sd">    (array([[0],</span>
<span class="sd">           [1]]), array([[2, 4]]))</span>
<span class="sd">    &gt;&gt;&gt; ixgrid[0].shape, ixgrid[1].shape</span>
<span class="sd">    ((2, 1), (1, 2))</span>
<span class="sd">    &gt;&gt;&gt; a[ixgrid]</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [7, 9]])</span>

<span class="sd">    &gt;&gt;&gt; x1 = np.array([True, True])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.array([2, 4])</span>
<span class="sd">    &gt;&gt;&gt; ixgrid = np.ix_(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; a[ixgrid]</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [7, 9]])</span>
<span class="sd">    &gt;&gt;&gt; x1 = np.array([True, True])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.array([False, False, True, False, True])</span>
<span class="sd">    &gt;&gt;&gt; ixgrid = np.ix_(x1, x2)</span>
<span class="sd">    &gt;&gt;&gt; a[ixgrid]</span>
<span class="sd">    array([[2, 4],</span>
<span class="sd">           [7, 9]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cross index must be 1 dimensional&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">):</span>
            <span class="p">(</span><span class="n">new</span><span class="p">,)</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">nd</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="mask_indices">
<a class="viewcode-back" href="../../reference/generated/dpnp.mask_indices.html#dpnp.mask_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mask_indices</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">mask_func</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span>
    <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices to access (n, n) arrays, given a masking function.</span>

<span class="sd">    Assume `mask_func` is a function that, for a square array a of size</span>
<span class="sd">    ``(n, n)`` with a possible offset argument `k`, when called as</span>
<span class="sd">    ``mask_func(a, k=k)`` returns a new array with zeros in certain locations</span>
<span class="sd">    (functions like :obj:`dpnp.triu` or :obj:`dpnp.tril` do precisely this).</span>
<span class="sd">    Then this function returns the indices where the non-zero values would be</span>
<span class="sd">    located.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The returned indices will be valid to access arrays of shape (n, n).</span>
<span class="sd">    mask_func : callable</span>
<span class="sd">        A function whose call signature is similar to that of :obj:`dpnp.triu`,</span>
<span class="sd">        :obj:`dpnp.tril`. That is, ``mask_func(x, k=k)`` returns a boolean</span>
<span class="sd">        array, shaped like `x`.`k` is an optional argument to the function.</span>
<span class="sd">    k : scalar</span>
<span class="sd">        An optional argument which is passed through to `mask_func`. Functions</span>
<span class="sd">        like :obj:`dpnp.triu`, :obj:`dpnp.tril` take a second argument that is</span>
<span class="sd">        interpreted as an offset.</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {&quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``&quot;device&quot;``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : tuple of dpnp.ndarray</span>
<span class="sd">        The `n` arrays of indices corresponding to the locations where</span>
<span class="sd">        ``mask_func(np.ones((n, n)), k)`` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.tril` : Return lower triangle of an array.</span>
<span class="sd">    :obj:`dpnp.triu` : Return upper triangle of an array.</span>
<span class="sd">    :obj:`dpnp.triu_indices` : Return the indices for the upper-triangle of an</span>
<span class="sd">                               (n, m) array.</span>
<span class="sd">    :obj:`dpnp.tril_indices` : Return the indices for the lower-triangle of an</span>
<span class="sd">                               (n, m) array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    These are the indices that would allow you to access the upper triangular</span>
<span class="sd">    part of any 3x3 array:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; iu = np.mask_indices(3, np.triu)</span>

<span class="sd">    For example, if `a` is a 3x3 array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; a[iu]</span>
<span class="sd">    array([0, 1, 2, 4, 5, 8])</span>

<span class="sd">    An offset can be passed also to the masking function. This gets us the</span>
<span class="sd">    indices starting on the first diagonal right of the main one:</span>

<span class="sd">    &gt;&gt;&gt; iu1 = np.mask_indices(3, np.triu, 1)</span>

<span class="sd">    with which we now extract only three elements:</span>

<span class="sd">    &gt;&gt;&gt; a[iu1]</span>
<span class="sd">    array([1, 2, 5])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span>
        <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">mask_func</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span></div>



<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=too-few-public-methods</span>
<div class="viewcode-block" id="ndindex">
<a class="viewcode-back" href="../../reference/generated/dpnp.ndindex.html#dpnp.ndindex">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ndindex</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An N-dimensional iterator object to index arrays.</span>

<span class="sd">    Given the shape of an array, an :obj:`dpnp.ndindex` instance iterates over</span>
<span class="sd">    the N-dimensional index of the array. At each iteration a tuple of indices</span>
<span class="sd">    is returned, the last dimension is iterated over first.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.ndindex`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : ints, or a single tuple of ints</span>
<span class="sd">        The size of each dimension of the array can be passed as individual</span>
<span class="sd">        parameters or as the elements of a tuple.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ndenumerate` : Multidimensional index iterator.</span>
<span class="sd">    :obj:`dpnp.flatiter` : Flat iterator object to iterate over arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>

<span class="sd">    Dimensions as individual arguments</span>

<span class="sd">    &gt;&gt;&gt; for index in np.ndindex(3, 2, 1):</span>
<span class="sd">    ...     print(index)</span>
<span class="sd">    (0, 0, 0)</span>
<span class="sd">    (0, 1, 0)</span>
<span class="sd">    (1, 0, 0)</span>
<span class="sd">    (1, 1, 0)</span>
<span class="sd">    (2, 0, 0)</span>
<span class="sd">    (2, 1, 0)</span>

<span class="sd">    Same dimensions - but in a tuple ``(3, 2, 1)``</span>

<span class="sd">    &gt;&gt;&gt; for index in np.ndindex((3, 2, 1)):</span>
<span class="sd">    ...     print(index)</span>
<span class="sd">    (0, 0, 0)</span>
<span class="sd">    (0, 1, 0)</span>
<span class="sd">    (1, 0, 0)</span>
<span class="sd">    (1, 1, 0)</span>
<span class="sd">    (2, 0, 0)</span>
<span class="sd">    (2, 1, 0)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndindex_</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="o">*</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndindex_</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Standard iterator method, updates the index and returns the index tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        val : tuple of ints</span>
<span class="sd">            Returns a tuple containing the indices of the current iteration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndindex_</span><span class="o">.</span><span class="fm">__next__</span><span class="p">()</span></div>



<div class="viewcode-block" id="nonzero">
<a class="viewcode-back" href="../../reference/generated/dpnp.nonzero.html#dpnp.nonzero">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the elements that are non-zero.</span>

<span class="sd">    Returns a tuple of arrays, one for each dimension of `a`, containing</span>
<span class="sd">    the indices of the non-zero elements in that dimension. The values in `a`</span>
<span class="sd">    are always tested and returned in row-major, C-style order.</span>

<span class="sd">    To group the indices by element, rather than dimension, use</span>
<span class="sd">    :obj:`dpnp.argwhere`, which returns a row for each non-zero element.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.nonzero`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple[dpnp.ndarray]</span>
<span class="sd">        Indices of elements that are non-zero.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.flatnonzero` : Return indices that are non-zero in</span>
<span class="sd">                              the flattened version of the input array.</span>
<span class="sd">    :obj:`dpnp.ndarray.nonzero` : Equivalent ndarray method.</span>
<span class="sd">    :obj:`dpnp.count_nonzero` : Counts the number of non-zero elements</span>
<span class="sd">                                in the input array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is</span>
<span class="sd">    recommended to use ``a[a.astype(bool)]`` or ``a[a != 0]`` instead, which</span>
<span class="sd">    will correctly handle 0-d arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[3, 0, 0],</span>
<span class="sd">           [0, 4, 0],</span>
<span class="sd">           [5, 6, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(x)</span>
<span class="sd">    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))</span>

<span class="sd">    &gt;&gt;&gt; x[np.nonzero(x)]</span>
<span class="sd">    array([3, 4, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.stack(np.nonzero(x)).T</span>
<span class="sd">    array([[0, 0],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [2, 0],</span>
<span class="sd">           [2, 1]])</span>

<span class="sd">    A common use for ``nonzero`` is to find the indices of an array, where</span>
<span class="sd">    a condition is ``True``. Given an array `a`, the condition `a` &gt; 3 is</span>
<span class="sd">    a boolean array and since ``False`` is interpreted as ``0``,</span>
<span class="sd">    ``np.nonzero(a &gt; 3)`` yields the indices of the `a` where the condition is</span>
<span class="sd">    true.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; a &gt; 3</span>
<span class="sd">    array([[False, False, False],</span>
<span class="sd">           [ True,  True,  True],</span>
<span class="sd">           [ True,  True,  True]])</span>
<span class="sd">    &gt;&gt;&gt; np.nonzero(a &gt; 3)</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    Using this result to index `a` is equivalent to using the mask directly:</span>

<span class="sd">    &gt;&gt;&gt; a[np.nonzero(a &gt; 3)]</span>
<span class="sd">    array([4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; a[a &gt; 3]  # prefer this spelling</span>
<span class="sd">    array([4, 5, 6, 7, 8, 9])</span>

<span class="sd">    ``nonzero`` can also be called as a method of the array.</span>

<span class="sd">    &gt;&gt;&gt; (a &gt; 3).nonzero()</span>
<span class="sd">    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dpt</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">usm_a</span><span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="place">
<a class="viewcode-back" href="../../reference/generated/dpnp.place.html#dpnp.place">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">place</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Change elements of an array based on conditional and input values.</span>

<span class="sd">    Similar to ``dpnp.copyto(a, vals, where=mask)``, the difference is that</span>
<span class="sd">    :obj:`dpnp.place` uses the first N elements of `vals`, where N is</span>
<span class="sd">    the number of ``True`` values in `mask`, while :obj:`dpnp.copyto` uses</span>
<span class="sd">    the elements where `mask` is ``True``.</span>

<span class="sd">    Note that :obj:`dpnp.extract` does the exact opposite of :obj:`dpnp.place`.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.place`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        Array to put data into.</span>
<span class="sd">    mask : {array_like, scalar}</span>
<span class="sd">        Boolean mask array. Must have the same size as `a`.</span>
<span class="sd">    vals : {array_like, scalar}</span>
<span class="sd">        Values to put into `a`. Only the first N elements are used, where N is</span>
<span class="sd">        the number of ``True`` values in `mask`. If `vals` is smaller than N,</span>
<span class="sd">        it will be repeated, and if elements of `a` are to be masked, this</span>
<span class="sd">        sequence must be non-empty.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.copyto` : Copies values from one array to another.</span>
<span class="sd">    :obj:`dpnp.put` : Replaces specified elements of an array with given values.</span>
<span class="sd">    :obj:`dpnp.take` : Take elements from an array along an axis.</span>
<span class="sd">    :obj:`dpnp.extract` : Return the elements of an array that satisfy some</span>
<span class="sd">                         condition.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(6).reshape(2, 3)</span>
<span class="sd">    &gt;&gt;&gt; np.place(a, a &gt; 2, [44, 55])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2],</span>
<span class="sd">           [44, 55, 44]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_mask</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">mask</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">usm_vals</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">vals</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">usm_vals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># dpt.place supports only 1-D array of values</span>
        <span class="n">usm_vals</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_vals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">usm_vals</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
        <span class="c1"># dpt.place casts values to a.dtype with &quot;unsafe&quot; rule,</span>
        <span class="c1"># while numpy.place does that with &quot;safe&quot; casting rule</span>
        <span class="n">usm_vals</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">usm_vals</span><span class="p">,</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">dpt</span><span class="o">.</span><span class="n">place</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_mask</span><span class="p">,</span> <span class="n">usm_vals</span><span class="p">)</span></div>



<div class="viewcode-block" id="put">
<a class="viewcode-back" href="../../reference/generated/dpnp.put.html#dpnp.put">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Puts values of an array into another array along a given axis.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.put`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The array the values will be put into.</span>
<span class="sd">    ind : {array_like}</span>
<span class="sd">        Target indices, interpreted as integers.</span>
<span class="sd">    v : {scalar, array_like}</span>
<span class="sd">         Values to be put into `a`. Must be broadcastable to the result shape</span>
<span class="sd">         ``a.shape[:axis] + ind.shape + a.shape[axis+1:]``.</span>
<span class="sd">    axis : {None, int}, optional</span>
<span class="sd">        The axis along which the values will be placed. If `a` is 1-D array,</span>
<span class="sd">        this argument is optional.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    mode : {&#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        - &#39;wrap&#39;: clamps indices to (``-n &lt;= i &lt; n``), then wraps negative</span>
<span class="sd">          indices.</span>
<span class="sd">        - &#39;clip&#39;: clips indices to (``0 &lt;= i &lt; n``).</span>

<span class="sd">        Default: ``&#39;wrap&#39;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.putmask` : Changes elements of an array based on conditional</span>
<span class="sd">                          and input values.</span>
<span class="sd">    :obj:`dpnp.place` : Change elements of an array based on conditional and</span>
<span class="sd">                        input values.</span>
<span class="sd">    :obj:`dpnp.put_along_axis` : Put values into the destination array</span>
<span class="sd">                                 by matching 1d index and data slices.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In contrast to :obj:`numpy.put` `wrap` mode which wraps indices around</span>
<span class="sd">    the array for cyclic operations, :obj:`dpnp.put` `wrap` mode clamps indices</span>
<span class="sd">    to a fixed range within the array boundaries (-n &lt;= i &lt; n).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-44,   1, -55,   3,   4])</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; np.put(a, 22, -5, mode=&#39;clip&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([ 0,  1,  2,  3, -5])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`axis` must be of integer type, got </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;wrap&quot;</span><span class="p">,</span> <span class="s2">&quot;clip&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;clipmode must be one of &#39;clip&#39; or &#39;wrap&#39; (got &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
        <span class="p">)</span>

    <span class="n">usm_v</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">v</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">usm_v</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">as_usm_ndarray</span><span class="p">(</span>
        <span class="n">ind</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">usm_a</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">usm_ind</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># dpt.put supports only 1-D array of indices</span>
        <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_ind</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">usm_ind</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="c1"># dpt.put supports only integer dtype for array of indices</span>
        <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">usm_ind</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span>

    <span class="n">in_usm_a</span> <span class="o">=</span> <span class="n">usm_a</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">dpt</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_ind</span><span class="p">,</span> <span class="n">usm_v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">in_usm_a</span><span class="o">.</span><span class="n">_pointer</span> <span class="o">!=</span> <span class="n">usm_a</span><span class="o">.</span><span class="n">_pointer</span><span class="p">:</span>  <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">in_usm_a</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">in_usm_a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="put_along_axis">
<a class="viewcode-back" href="../../reference/generated/dpnp.put_along_axis.html#dpnp.put_along_axis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">put_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Put values into the destination array by matching 1d index and data slices.</span>

<span class="sd">    This iterates over matching 1d slices oriented along the specified axis in</span>
<span class="sd">    the index and data arrays, and uses the former to place values into the</span>
<span class="sd">    latter. These slices can be different lengths.</span>

<span class="sd">    Functions returning an index along an `axis`, like :obj:`dpnp.argsort` and</span>
<span class="sd">    :obj:`dpnp.argpartition`, produce suitable indices for this function.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.put_along_axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}, (Ni..., M, Nk...)</span>
<span class="sd">        Destination array.</span>
<span class="sd">    ind : {dpnp.ndarray, usm_ndarray}, (Ni..., J, Nk...)</span>
<span class="sd">        Indices to change along each 1d slice of `a`. This must match the</span>
<span class="sd">        dimension of input array, but dimensions in ``Ni`` and ``Nj``</span>
<span class="sd">        may be 1 to broadcast against `a`.</span>
<span class="sd">    values : {scalar, array_like}, (Ni..., J, Nk...)</span>
<span class="sd">        Values to insert at those indices. Its shape and dimension are</span>
<span class="sd">        broadcast to match that of `ind`.</span>
<span class="sd">    axis : {None, int}</span>
<span class="sd">        The axis to take 1d slices along. If axis is ``None``, the destination</span>
<span class="sd">        array is treated as if a flattened 1d view had been created of it.</span>
<span class="sd">    mode : {&quot;wrap&quot;, &quot;clip&quot;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will be handled. Possible values</span>
<span class="sd">        are:</span>

<span class="sd">        - ``&quot;wrap&quot;``: clamps indices to (``-n &lt;= i &lt; n``), then wraps</span>
<span class="sd">          negative indices.</span>
<span class="sd">        - ``&quot;clip&quot;``: clips indices to (``0 &lt;= i &lt; n``).</span>

<span class="sd">        Default: ``&quot;wrap&quot;``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.put` : Put values along an axis, using the same indices</span>
<span class="sd">                      for every 1d slice.</span>
<span class="sd">    :obj:`dpnp.take_along_axis` : Take values from the input array</span>
<span class="sd">                                  by matching 1d index and data slices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For this sample array</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]])</span>

<span class="sd">    We can replace the maximum values with:</span>

<span class="sd">    &gt;&gt;&gt; ai = np.argmax(a, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [0]])</span>
<span class="sd">    &gt;&gt;&gt; np.put_along_axis(a, ai, 99, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[10, 99, 20],</span>
<span class="sd">           [99, 40, 50]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ind</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;when axis=None, `ind` must have a single dimension.&quot;</span>
            <span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">usm_vals</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usm_vals</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">values</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">sycl_queue</span>
        <span class="p">)</span>

    <span class="n">dpt</span><span class="o">.</span><span class="n">put_along_axis</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_ind</span><span class="p">,</span> <span class="n">usm_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span></div>



<div class="viewcode-block" id="putmask">
<a class="viewcode-back" href="../../reference/generated/dpnp.putmask.html#dpnp.putmask">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">putmask</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes elements of an array based on conditional and input values.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.putmask`.</span>

<span class="sd">    Limitations</span>
<span class="sd">    -----------</span>
<span class="sd">    Input arrays ``arr``, ``mask`` and ``values`` are supported</span>
<span class="sd">    as :obj:`dpnp.ndarray`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">x1_desc</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_dpnp_descriptor</span><span class="p">(</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">copy_when_strides</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">copy_when_nondefault_queue</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="n">mask_desc</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_dpnp_descriptor</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy_when_nondefault_queue</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">values_desc</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_dpnp_descriptor</span><span class="p">(</span>
        <span class="n">values</span><span class="p">,</span> <span class="n">copy_when_nondefault_queue</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">x1_desc</span> <span class="ow">and</span> <span class="n">mask_desc</span> <span class="ow">and</span> <span class="n">values_desc</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dpnp_putmask</span><span class="p">(</span><span class="n">x1_desc</span><span class="p">,</span> <span class="n">mask_desc</span><span class="p">,</span> <span class="n">values_desc</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">call_origin</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">putmask</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">dpnp_inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<div class="viewcode-block" id="ravel_multi_index">
<a class="viewcode-back" href="../../reference/generated/dpnp.ravel_multi_index.html#dpnp.ravel_multi_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ravel_multi_index</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;raise&quot;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a tuple of index arrays into an array of flat indices, applying</span>
<span class="sd">    boundary modes to the multi-index.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.ravel_multi_index`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    multi_index : tuple of {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        A tuple of integer arrays, one array for each dimension.</span>
<span class="sd">    dims : tuple or list of ints</span>
<span class="sd">        The shape of array into which the indices from `multi_index` apply.</span>
<span class="sd">    mode : {&quot;raise&quot;, &quot;wrap&quot; or &quot;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices are handled. Can specify either</span>
<span class="sd">        one mode or a tuple of modes, one mode per index:</span>

<span class="sd">        - &quot;raise&quot; -- raise an error</span>
<span class="sd">        - &quot;wrap&quot; -- wrap around</span>
<span class="sd">        - &quot;clip&quot; -- clip to the range</span>

<span class="sd">        In ``&quot;clip&quot;`` mode, a negative index which would normally wrap will</span>
<span class="sd">        clip to 0 instead.</span>

<span class="sd">        Default: ``&quot;raise&quot;``.</span>
<span class="sd">    order : {None, &quot;C&quot;, &quot;F&quot;}, optional</span>
<span class="sd">        Determines whether the multi-index should be viewed as indexing in</span>
<span class="sd">        row-major (C-style) or column-major (Fortran-style) order.</span>

<span class="sd">        Default: ``&quot;C&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    raveled_indices : dpnp.ndarray</span>
<span class="sd">        An array of indices into the flattened version of an array of</span>
<span class="sd">        dimensions `dims`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.unravel_index` : Converts array of flat indices into a tuple of</span>
<span class="sd">                                coordinate arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array([[3, 6, 6], [4, 5, 1]])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel_multi_index(arr, (7, 6))</span>
<span class="sd">    array([22, 41, 37])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel_multi_index(arr, (7, 6), order=&quot;F&quot;)</span>
<span class="sd">    array([31, 41, 13])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel_multi_index(arr, (4, 6), mode=&quot;clip&quot;)</span>
<span class="sd">    array([22, 23, 19])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel_multi_index(arr, (4, 4), mode=(&quot;clip&quot;, &quot;wrap&quot;))</span>
<span class="sd">    array([12, 13, 13])</span>

<span class="sd">    &gt;&gt;&gt; arr = np.array([3, 1, 4, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.ravel_multi_index(arr, (6, 7, 8, 9))</span>
<span class="sd">    array(1621)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ravel_multi_index_checks</span><span class="p">(</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span><span class="p">,)</span> <span class="o">*</span> <span class="n">ndim</span>

    <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ravel_strides</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span>

    <span class="n">multi_index</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span>
    <span class="n">usm_type_alloc</span><span class="p">,</span> <span class="n">sycl_queue_alloc</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span>

    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span> <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">order</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">dims</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ravel_strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">dims</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">ravel_strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>

    <span class="n">multi_index</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
    <span class="n">raveled_indices</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="n">multi_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type_alloc</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue_alloc</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_mode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">ravel_strides</span><span class="p">,</span> <span class="n">multi_index</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;multi_index entries could not be cast from dtype(</span><span class="si">{</span><span class="n">idx</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; to dtype(</span><span class="si">{</span><span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="si">}</span><span class="s2">) according to the rule &#39;same_kind&#39;&quot;</span>
            <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dpnp</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">,</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in coordinates array&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">%</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized mode: </span><span class="si">{</span><span class="n">_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">raveled_indices</span> <span class="o">+=</span> <span class="n">stride</span> <span class="o">*</span> <span class="n">idx</span>
    <span class="k">return</span> <span class="n">raveled_indices</span></div>



<div class="viewcode-block" id="select">
<a class="viewcode-back" href="../../reference/generated/dpnp.select.html#dpnp.select">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an array drawn from elements in `choicelist`, depending on</span>
<span class="sd">    conditions.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.select`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condlist : list of bool dpnp.ndarray or usm_ndarray</span>
<span class="sd">        The list of conditions which determine from which array in `choicelist`</span>
<span class="sd">        the output elements are taken. When multiple conditions are satisfied,</span>
<span class="sd">        the first one encountered in `condlist` is used.</span>
<span class="sd">    choicelist : list of dpnp.ndarray or usm_ndarray</span>
<span class="sd">        The list of arrays from which the output elements are taken. It has</span>
<span class="sd">        to be of the same length as `condlist`.</span>
<span class="sd">    default : {scalar, dpnp.ndarray, usm_ndarray}, optional</span>
<span class="sd">        The element inserted in `output` when all conditions evaluate to</span>
<span class="sd">        ``False``.</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The output at position m is the m-th element of the array in</span>
<span class="sd">        `choicelist` where the m-th element of the corresponding array in</span>
<span class="sd">        `condlist` is ``True``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.where` : Return elements from one of two arrays depending on</span>
<span class="sd">                       condition.</span>
<span class="sd">    :obj:`dpnp.take` : Take elements from an array along an axis.</span>
<span class="sd">    :obj:`dpnp.choose` : Construct an array from an index array and a set of</span>
<span class="sd">                         arrays to choose from.</span>
<span class="sd">    :obj:`dpnp.compress` : Return selected slices of an array along given axis.</span>
<span class="sd">    :obj:`dpnp.diag` : Extract a diagonal or construct a diagonal array.</span>
<span class="sd">    :obj:`dpnp.diagonal` : Return specified diagonals.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>

<span class="sd">    Beginning with an array of integers from 0 to 5 (inclusive),</span>
<span class="sd">    elements less than ``3`` are negated, elements greater than ``3``</span>
<span class="sd">    are squared, and elements not meeting either of these conditions</span>
<span class="sd">    (exactly ``3``) are replaced with a `default` value of ``42``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(6)</span>
<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;3, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [-x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 42)</span>
<span class="sd">    array([ 0, -1, -2, 42, 16, 25])</span>

<span class="sd">    When multiple conditions are satisfied, the first one encountered in</span>
<span class="sd">    `condlist` is used.</span>

<span class="sd">    &gt;&gt;&gt; condlist = [x&lt;=4, x&gt;3]</span>
<span class="sd">    &gt;&gt;&gt; choicelist = [x, x**2]</span>
<span class="sd">    &gt;&gt;&gt; np.select(condlist, choicelist, 55)</span>
<span class="sd">    array([ 0,  1,  2,  3,  4, 25])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;list of cases must be same length as list of conditions&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;select with an empty condition list is not possible&quot;</span><span class="p">)</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="ow">and</span> <span class="n">default</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;A default value must be any of scalar or 0-d supported array type&quot;</span>
        <span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="n">usm_type_alloc</span><span class="p">,</span> <span class="n">sycl_queue_alloc</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">(</span>
        <span class="n">condlist</span> <span class="o">+</span> <span class="n">choicelist</span> <span class="o">+</span> <span class="p">[</span><span class="n">default</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">condlist</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;invalid entry </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> in condlist: should be boolean ndarray&quot;</span>
            <span class="p">)</span>

    <span class="c1"># Convert conditions to arrays and broadcast conditions and choices</span>
    <span class="c1"># as the shape is needed for the result</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">condlist</span><span class="p">)</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>

    <span class="n">result_shape</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">condlist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
        <span class="n">result_shape</span><span class="p">,</span>
        <span class="n">default</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type_alloc</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue_alloc</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Do in reverse order since the first choice should take precedence.</span>
    <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choicelist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">condlist</span> <span class="o">=</span> <span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">choice</span><span class="p">,</span> <span class="n">cond</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">choicelist</span><span class="p">,</span> <span class="n">condlist</span><span class="p">):</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">result</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">result</span></div>



<span class="c1"># pylint: disable=redefined-outer-name</span>
<div class="viewcode-block" id="take">
<a class="viewcode-back" href="../../reference/generated/dpnp.take.html#dpnp.take">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take elements from an array along an axis.</span>

<span class="sd">    When `axis` is not ``None``, this function does the same thing as &quot;fancy&quot;</span>
<span class="sd">    indexing (indexing arrays using arrays); however, it can be easier to use</span>
<span class="sd">    if you need elements along a given axis. A call such as</span>
<span class="sd">    ``dpnp.take(a, indices, axis=3)`` is equivalent to</span>
<span class="sd">    ``a[:, :, :, indices, ...]``.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.take`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}, (Ni..., M, Nk...)</span>
<span class="sd">        The source array.</span>
<span class="sd">    indices : {array_like, scalars}, (Nj...)</span>
<span class="sd">        The indices of the values to extract.</span>
<span class="sd">        Also allow scalars for `indices`.</span>
<span class="sd">    axis : {None, int, bool, 0-d array of integer dtype}, optional</span>
<span class="sd">        The axis over which to select values. By default, the flattened</span>
<span class="sd">        input array is used.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    out : {None, dpnp.ndarray, usm_ndarray}, optional (Ni..., Nj..., Nk...)</span>
<span class="sd">        If provided, the result will be placed in this array. It should</span>
<span class="sd">        be of the appropriate shape and dtype.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    mode : {&quot;wrap&quot;, &quot;clip&quot;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will be handled. Possible values</span>
<span class="sd">        are:</span>

<span class="sd">        - ``&quot;wrap&quot;``: clamps indices to (``-n &lt;= i &lt; n``), then wraps</span>
<span class="sd">          negative indices.</span>
<span class="sd">        - ``&quot;clip&quot;``: clips indices to (``0 &lt;= i &lt; n``).</span>

<span class="sd">        Default: ``&quot;wrap&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray, (Ni..., Nj..., Nk...)</span>
<span class="sd">        The returned array has the same type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.compress` : Take elements using a boolean mask.</span>
<span class="sd">    :obj:`dpnp.ndarray.take` : Equivalent method.</span>
<span class="sd">    :obj:`dpnp.take_along_axis` : Take elements by matching the array and</span>
<span class="sd">                                  the index arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([4, 3, 5, 7, 6, 8])</span>
<span class="sd">    &gt;&gt;&gt; indices = np.array([0, 1, 4])</span>
<span class="sd">    &gt;&gt;&gt; np.take(x, indices)</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    In this example &quot;fancy&quot; indexing can be used.</span>

<span class="sd">    &gt;&gt;&gt; x[indices]</span>
<span class="sd">    array([4, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; indices = dpnp.array([-1, -6, -7, 5, 6])</span>
<span class="sd">    &gt;&gt;&gt; np.take(x, indices)</span>
<span class="sd">    array([8, 4, 4, 8, 8])</span>

<span class="sd">    &gt;&gt;&gt; np.take(x, indices, mode=&quot;clip&quot;)</span>
<span class="sd">    array([4, 4, 4, 8, 8])</span>

<span class="sd">    If `indices` is not one dimensional, the output also has these dimensions.</span>

<span class="sd">    &gt;&gt;&gt; np.take(x, [[0, 1], [2, 3]])</span>
<span class="sd">    array([[4, 3],</span>
<span class="sd">           [5, 7]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># sets mode to 0 for &quot;wrap&quot; and 1 for &quot;clip&quot;, raises otherwise</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_get_indexing_mode</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">is_supported_array_type</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
        <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">usm_type</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span> <span class="n">sycl_queue</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">sycl_queue</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">exec_q</span> <span class="o">=</span> <span class="n">get_usm_allocations</span><span class="p">([</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_ind</span><span class="p">])</span>

    <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># flatten input array</span>
            <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">a_ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">normalize_axis_index</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">a_ndim</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">usm_ind</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="c1"># dpt.take supports only integer dtype for array of indices</span>
        <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">usm_ind</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span><span class="p">)</span>

    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">_take_index</span><span class="p">(</span>
        <span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_ind</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">exec_q</span><span class="p">,</span> <span class="n">res_usm_type</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_result_array</span><span class="p">(</span><span class="n">usm_res</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="take_along_axis">
<a class="viewcode-back" href="../../reference/generated/dpnp.take_along_axis.html#dpnp.take_along_axis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take values from the input array by matching 1d index and data slices.</span>

<span class="sd">    This iterates over matching 1d slices oriented along the specified axis in</span>
<span class="sd">    the index and data arrays, and uses the former to look up values in the</span>
<span class="sd">    latter. These slices can be different lengths.</span>

<span class="sd">    Functions returning an index along an `axis`, like :obj:`dpnp.argsort` and</span>
<span class="sd">    :obj:`dpnp.argpartition`, produce suitable indices for this function.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.take_along_axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {dpnp.ndarray, usm_ndarray}, (Ni..., M, Nk...)</span>
<span class="sd">        Source array</span>
<span class="sd">    indices : {dpnp.ndarray, usm_ndarray}, (Ni..., J, Nk...)</span>
<span class="sd">        Indices to take along each 1d slice of `a`. This must match the</span>
<span class="sd">        dimension of the input array, but dimensions ``Ni`` and ``Nj``</span>
<span class="sd">        only need to broadcast against `a`.</span>
<span class="sd">    axis : {None, int}</span>
<span class="sd">        The axis to take 1d slices along. If axis is ``None``, the input array</span>
<span class="sd">        is treated as if it had first been flattened to 1d. The default is</span>
<span class="sd">        ``-1``, which takes 1d slices along the last axis. These behaviors are</span>
<span class="sd">        consistent with :obj:`dpnp.sort` and :obj:`dpnp.argsort`.</span>

<span class="sd">        Default: ``-1``.</span>
<span class="sd">    mode : {&quot;wrap&quot;, &quot;clip&quot;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will be handled. Possible values</span>
<span class="sd">        are:</span>

<span class="sd">        - ``&quot;wrap&quot;``: clamps indices to (``-n &lt;= i &lt; n``), then wraps</span>
<span class="sd">          negative indices.</span>
<span class="sd">        - ``&quot;clip&quot;``: clips indices to (``0 &lt;= i &lt; n``).</span>

<span class="sd">        Default: ``&quot;wrap&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : dpnp.ndarray</span>
<span class="sd">        The indexed result of the same data type as `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.take` : Take along an axis, using the same indices for</span>
<span class="sd">                       every 1d slice.</span>
<span class="sd">    :obj:`dpnp.put_along_axis` : Put values into the destination array</span>
<span class="sd">                                 by matching 1d index and data slices.</span>
<span class="sd">    :obj:`dpnp.argsort` : Return the indices that would sort an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For this sample array</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]])</span>

<span class="sd">    We can sort either by using :obj:`dpnp.sort` directly, or</span>
<span class="sd">    :obj:`dpnp.argsort` and this function:</span>

<span class="sd">    &gt;&gt;&gt; np.sort(a, axis=1)</span>
<span class="sd">    array([[10, 20, 30],</span>
<span class="sd">           [40, 50, 60]])</span>
<span class="sd">    &gt;&gt;&gt; ai = np.argsort(a, axis=1)</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([[0, 2, 1],</span>
<span class="sd">           [1, 2, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)</span>
<span class="sd">    array([[10, 20, 30],</span>
<span class="sd">           [40, 50, 60]])</span>

<span class="sd">    The same works for :obj:`dpnp.max` and :obj:`dpnp.min`, if you maintain</span>
<span class="sd">    the trivial dimension with ``keepdims``:</span>

<span class="sd">    &gt;&gt;&gt; np.max(a, axis=1, keepdims=True)</span>
<span class="sd">    array([[30],</span>
<span class="sd">           [60]])</span>
<span class="sd">    &gt;&gt;&gt; ai = np.argmax(a, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([[1],</span>
<span class="sd">           [0]])</span>
<span class="sd">    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)</span>
<span class="sd">    array([[30],</span>
<span class="sd">           [60]])</span>

<span class="sd">    If we want to get the max and min at the same time, we can stack the</span>
<span class="sd">    indices first:</span>

<span class="sd">    &gt;&gt;&gt; ai_min = np.argmin(a, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; ai_max = np.argmax(a, axis=1, keepdims=True)</span>
<span class="sd">    &gt;&gt;&gt; ai = np.concatenate([ai_min, ai_max], axis=1)</span>
<span class="sd">    &gt;&gt;&gt; ai</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)</span>
<span class="sd">    array([[10, 30],</span>
<span class="sd">           [40, 60]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;when axis=None, `indices` must have a single dimension.&quot;</span>
            <span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">usm_a</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">usm_ind</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">get_usm_ndarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="n">usm_res</span> <span class="o">=</span> <span class="n">dpt</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">usm_a</span><span class="p">,</span> <span class="n">usm_ind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dpnp_array</span><span class="o">.</span><span class="n">_create_from_usm_ndarray</span><span class="p">(</span><span class="n">usm_res</span><span class="p">)</span></div>



<div class="viewcode-block" id="tril_indices">
<a class="viewcode-back" href="../../reference/generated/dpnp.tril_indices.html#dpnp.tril_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tril_indices</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span>
    <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices for the lower-triangle of an (n, m) array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.tril_indices`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The row dimension of the arrays for which the returned</span>
<span class="sd">        indices will be valid.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Diagonal offset (see :obj:`dpnp.tril` for details).</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    m : {None, int}, optional</span>
<span class="sd">        The column dimension of the arrays for which the returned</span>
<span class="sd">        arrays will be valid.</span>
<span class="sd">        By default `m` is taken equal to `n`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {&quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``&quot;device&quot;``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inds : tuple of dpnp.ndarray</span>
<span class="sd">        The row and column indices, respectively. The row indices are sorted in</span>
<span class="sd">        non-decreasing order, and the corresponding column indices are strictly</span>
<span class="sd">        increasing for each row.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.triu_indices` : similar function, for upper-triangular.</span>
<span class="sd">    :obj:`dpnp.mask_indices` : generic function accepting an arbitrary mask</span>
<span class="sd">                               function.</span>
<span class="sd">    :obj:`dpnp.tril` : Return lower triangle of an array.</span>
<span class="sd">    :obj:`dpnp.triu` : Return upper triangle of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute two different sets of indices to access 4x4 arrays, one for the</span>
<span class="sd">    lower triangular part starting at the main diagonal, and one starting two</span>
<span class="sd">    diagonals further right:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; il1 = np.tril_indices(4)</span>
<span class="sd">    &gt;&gt;&gt; il1</span>
<span class="sd">    (array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]),</span>
<span class="sd">     array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))</span>

<span class="sd">    Note that row indices (first array) are non-decreasing, and the</span>
<span class="sd">    corresponding column indices (second array) are strictly increasing for</span>
<span class="sd">    each row.</span>

<span class="sd">    Here is how they can be used with a sample array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>

<span class="sd">    Both for indexing:</span>

<span class="sd">    &gt;&gt;&gt; a[il1]</span>
<span class="sd">    array([ 0,  4,  5, ..., 13, 14, 15])</span>

<span class="sd">    And for assigning values:</span>

<span class="sd">    &gt;&gt;&gt; a[il1] = -1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[-1,  1,  2,  3],</span>
<span class="sd">           [-1, -1,  6,  7],</span>
<span class="sd">           [-1, -1, -1, 11],</span>
<span class="sd">           [-1, -1, -1, -1]])</span>

<span class="sd">    These cover almost the whole array (two diagonals right of the main one):</span>

<span class="sd">    &gt;&gt;&gt; il2 = np.tril_indices(4, 2)</span>
<span class="sd">    &gt;&gt;&gt; a[il2] = -10</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[-10, -10, -10,   3],</span>
<span class="sd">           [-10, -10, -10, -10],</span>
<span class="sd">           [-10, -10, -10, -10],</span>
<span class="sd">           [-10, -10, -10, -10]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tri_</span> <span class="o">=</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">tri_</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">tri_</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">(</span>
            <span class="n">tri_</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="tril_indices_from">
<a class="viewcode-back" href="../../reference/generated/dpnp.tril_indices_from.html#dpnp.tril_indices_from">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tril_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices for the lower-triangle of arr.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.tril_indices_from`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The indices will be valid for square arrays whose dimensions are</span>
<span class="sd">        the same as arr.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Diagonal offset (see :obj:`dpnp.tril` for details).</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inds : tuple of dpnp.ndarray</span>
<span class="sd">        The indices for the triangle. The returned tuple contains two arrays,</span>
<span class="sd">        each with the indices along one dimension of the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.tril_indices` : Return the indices for the lower-triangle of an</span>
<span class="sd">                               (n, m) array.</span>
<span class="sd">    :obj:`dpnp.tril` : Return lower triangle of an array.</span>
<span class="sd">    :obj:`dpnp.triu_indices_from` : similar function, for upper-triangular.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a 4 by 4 array.</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>

<span class="sd">    Pass the array to get the indices of the lower triangular elements.</span>

<span class="sd">    &gt;&gt;&gt; trili = np.tril_indices_from(a)</span>
<span class="sd">    &gt;&gt;&gt; trili</span>
<span class="sd">    (array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]),</span>
<span class="sd">     array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))</span>

<span class="sd">    &gt;&gt;&gt; a[trili]</span>
<span class="sd">    array([ 0,  4,  5,  8,  9, 10, 12, 13, 14, 15])</span>

<span class="sd">    This is syntactic sugar for tril_indices().</span>

<span class="sd">    &gt;&gt;&gt; np.tril_indices(a.shape[0])</span>
<span class="sd">    (array([0, 1, 1, 2, 2, 2, 3, 3, 3, 3]),</span>
<span class="sd">     array([0, 0, 1, 0, 1, 2, 0, 1, 2, 3]))</span>

<span class="sd">    Use the `k` parameter to return the indices for the lower triangular array</span>
<span class="sd">    up to the k-th diagonal.</span>

<span class="sd">    &gt;&gt;&gt; trili1 = np.tril_indices_from(a, k=1)</span>
<span class="sd">    &gt;&gt;&gt; a[trili1]</span>
<span class="sd">    array([ 0,  1,  4,  5,  6,  8,  9, 10, 11, 12, 13, 14, 15])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be 2-d&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tril_indices</span><span class="p">(</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="triu_indices">
<a class="viewcode-back" href="../../reference/generated/dpnp.triu_indices.html#dpnp.triu_indices">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">triu_indices</span><span class="p">(</span>
    <span class="n">n</span><span class="p">,</span>
    <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">usm_type</span><span class="o">=</span><span class="s2">&quot;device&quot;</span><span class="p">,</span>
    <span class="n">sycl_queue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices for the upper-triangle of an (n, m) array.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.triu_indices`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">        The size of the arrays for which the returned indices will</span>
<span class="sd">        be valid.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Diagonal offset (see :obj:`dpnp.triu` for details).</span>

<span class="sd">        Default: ``0``.</span>
<span class="sd">    m : int, optional</span>
<span class="sd">        The column dimension of the arrays for which the returned</span>
<span class="sd">        arrays will be valid.</span>
<span class="sd">        By default `m` is taken equal to `n`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    device : {None, string, SyclDevice, SyclQueue, Device}, optional</span>
<span class="sd">        An array API concept of device where the output array is created.</span>
<span class="sd">        `device` can be ``None``, a oneAPI filter selector string, an instance</span>
<span class="sd">        of :class:`dpctl.SyclDevice` corresponding to a non-partitioned SYCL</span>
<span class="sd">        device, an instance of :class:`dpctl.SyclQueue`, or a</span>
<span class="sd">        :class:`dpctl.tensor.Device` object returned by</span>
<span class="sd">        :attr:`dpnp.ndarray.device`.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    usm_type : {&quot;device&quot;, &quot;shared&quot;, &quot;host&quot;}, optional</span>
<span class="sd">        The type of SYCL USM allocation for the output array.</span>

<span class="sd">        Default: ``None``.</span>
<span class="sd">    sycl_queue : {None, SyclQueue}, optional</span>
<span class="sd">        A SYCL queue to use for output array allocation and copying. The</span>
<span class="sd">        `sycl_queue` can be passed as ``None`` (the default), which means</span>
<span class="sd">        to get the SYCL queue from `device` keyword if present or to use</span>
<span class="sd">        a default queue.</span>

<span class="sd">        Default: ``None``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inds : tuple of dpnp.ndarray</span>
<span class="sd">        The row and column indices, respectively. The row indices are sorted in</span>
<span class="sd">        non-decreasing order, and the corresponding column indices are strictly</span>
<span class="sd">        increasing for each row.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.tril_indices` : similar function, for lower-triangular.</span>
<span class="sd">    :obj:`dpnp.mask_indices` : generic function accepting an arbitrary mask</span>
<span class="sd">                               function.</span>
<span class="sd">    :obj:`dpnp.tril` : Return lower triangle of an array.</span>
<span class="sd">    :obj:`dpnp.triu` : Return upper triangle of an array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Compute two different sets of indices to access 4x4 arrays, one for the</span>
<span class="sd">    upper triangular part starting at the main diagonal, and one starting two</span>
<span class="sd">    diagonals further right:</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; iu1 = np.triu_indices(4)</span>
<span class="sd">    &gt;&gt;&gt; iu1</span>
<span class="sd">    (array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]),</span>
<span class="sd">     array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))</span>

<span class="sd">    Note that row indices (first array) are non-decreasing, and the</span>
<span class="sd">    corresponding column indices (second array) are strictly increasing for</span>
<span class="sd">    each row.</span>

<span class="sd">    Here is how they can be used with a sample array:</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>

<span class="sd">    Both for indexing:</span>

<span class="sd">    &gt;&gt;&gt; a[iu1]</span>
<span class="sd">    array([ 0,  1,  2, ..., 10, 11, 15])</span>

<span class="sd">    And for assigning values:</span>

<span class="sd">    &gt;&gt;&gt; a[iu1] = -1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[-1, -1, -1, -1],</span>
<span class="sd">           [ 4, -1, -1, -1],</span>
<span class="sd">           [ 8,  9, -1, -1],</span>
<span class="sd">           [12, 13, 14, -1]])</span>

<span class="sd">    These cover only a small part of the whole array (two diagonals right</span>
<span class="sd">    of the main one):</span>

<span class="sd">    &gt;&gt;&gt; iu2 = np.triu_indices(4, 2)</span>
<span class="sd">    &gt;&gt;&gt; a[iu2] = -10</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ -1,  -1, -10, -10],</span>
<span class="sd">           [  4,  -1,  -1, -10],</span>
<span class="sd">           [  8,   9,  -1,  -1],</span>
<span class="sd">           [ 12,  13,  14,  -1]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tri_</span> <span class="o">=</span> <span class="o">~</span><span class="n">dpnp</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span>
        <span class="n">n</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span>
        <span class="n">dpnp</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">tri_</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="n">tri_</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">(</span>
            <span class="n">tri_</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">,</span>
            <span class="n">usm_type</span><span class="o">=</span><span class="n">usm_type</span><span class="p">,</span>
            <span class="n">sycl_queue</span><span class="o">=</span><span class="n">sycl_queue</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="triu_indices_from">
<a class="viewcode-back" href="../../reference/generated/dpnp.triu_indices_from.html#dpnp.triu_indices_from">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">triu_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices for the lower-triangle of arr.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.triu_indices_from`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        The indices will be valid for square arrays whose dimensions are</span>
<span class="sd">        the same as arr.</span>
<span class="sd">    k : int, optional</span>
<span class="sd">        Diagonal offset (see :obj:`dpnp.triu` for details).</span>

<span class="sd">        Default: ``0``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    inds : tuple of dpnp.ndarray</span>
<span class="sd">        The indices for the triangle. The returned tuple contains two arrays,</span>
<span class="sd">        each with the indices along one dimension of the array. Can be used</span>
<span class="sd">        to slice a ndarray of shape(`n`, `n`).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.triu_indices` : Return the indices for the upper-triangle of an</span>
<span class="sd">                               (n, m) array.</span>
<span class="sd">    :obj:`dpnp.triu` : Return upper triangle of an array.</span>
<span class="sd">    :obj:`dpnp.tril_indices_from` : similar function, for lower-triangular.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a 4 by 4 array.</span>

<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(16).reshape(4, 4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 0,  1,  2,  3],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 8,  9, 10, 11],</span>
<span class="sd">           [12, 13, 14, 15]])</span>

<span class="sd">    Pass the array to get the indices of the upper triangular elements.</span>

<span class="sd">    &gt;&gt;&gt; triui = np.triu_indices_from(a)</span>
<span class="sd">    &gt;&gt;&gt; triui</span>
<span class="sd">    (array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]),</span>
<span class="sd">     array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))</span>

<span class="sd">    &gt;&gt;&gt; a[triui]</span>
<span class="sd">    array([ 0,  1,  2,  3,  5,  6,  7, 10, 11, 15])</span>

<span class="sd">    This is syntactic sugar for triu_indices().</span>

<span class="sd">    &gt;&gt;&gt; np.triu_indices(a.shape[0])</span>
<span class="sd">    (array([0, 0, 0, 0, 1, 1, 1, 2, 2, 3]),</span>
<span class="sd">     array([0, 1, 2, 3, 1, 2, 3, 2, 3, 3]))</span>

<span class="sd">    Use the `k` parameter to return the indices for the upper triangular array</span>
<span class="sd">    from the k-th diagonal.</span>

<span class="sd">    &gt;&gt;&gt; triuim1 = np.triu_indices_from(a, k=1)</span>
<span class="sd">    &gt;&gt;&gt; a[triuim1]</span>
<span class="sd">    array([ 1,  2,  3,  6,  7, 11])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be 2-d&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">triu_indices</span><span class="p">(</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span>
        <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">usm_type</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">usm_type</span><span class="p">,</span>
        <span class="n">sycl_queue</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">sycl_queue</span><span class="p">,</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="unravel_index">
<a class="viewcode-back" href="../../reference/generated/dpnp.unravel_index.html#dpnp.unravel_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts array of flat indices into a tuple of coordinate arrays.</span>

<span class="sd">    For full documentation refer to :obj:`numpy.unravel_index`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    indices : {dpnp.ndarray, usm_ndarray}</span>
<span class="sd">        An integer array whose elements are indices into the flattened version</span>
<span class="sd">        of an array of dimensions `shape`.</span>
<span class="sd">    shape : tuple or list of ints</span>
<span class="sd">        The shape of the array to use for unraveling `indices`.</span>
<span class="sd">    order : {None, &quot;C&quot;, &quot;F&quot;}, optional</span>
<span class="sd">        Determines whether the indices should be viewed as indexing in</span>
<span class="sd">        row-major (C-style) or column-major (Fortran-style) order.</span>

<span class="sd">        Default: ``&quot;C&quot;``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unraveled_coords : tuple of dpnp.ndarray</span>
<span class="sd">        Each array in the tuple has the same shape as the indices array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :obj:`dpnp.ravel_multi_index` : Converts a tuple of index arrays into an</span>
<span class="sd">                                    array of flat indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import dpnp as np</span>
<span class="sd">    &gt;&gt;&gt; np.unravel_index(np.array([22, 41, 37]), (7, 6))</span>
<span class="sd">    (array([3, 6, 6]), array([4, 5, 1]))</span>
<span class="sd">    &gt;&gt;&gt; np.unravel_index(np.array([31, 41, 13]), (7, 6), order=&quot;F&quot;)</span>
<span class="sd">    (array([3, 6, 6]), array([4, 5, 1]))</span>

<span class="sd">    &gt;&gt;&gt; np.unravel_index(np.array(1621), (6, 7, 8, 9))</span>
<span class="sd">    (array(3), array(1), array(4), array(1))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">dpnp</span><span class="o">.</span><span class="n">check_supported_arrays_type</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Unrecognized `order` keyword value, expecting &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;C&#39; or &#39;F&#39;, but got &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>
    <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span> <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">order</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="s2">&quot;same_kind&quot;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Iterator operand 0 dtype could not be cast from dtype(&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">) to dtype(</span><span class="si">{</span><span class="n">dpnp</span><span class="o">.</span><span class="n">int64</span><span class="si">}</span><span class="s2">) according to the rule &quot;</span>
            <span class="s2">&quot;&#39;same_kind&#39;&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in index array&quot;</span><span class="p">)</span>

    <span class="n">unraveled_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
        <span class="n">unraveled_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span> <span class="o">%</span> <span class="n">dim</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">//</span> <span class="n">dim</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in index array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
        <span class="n">unraveled_coords</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">unraveled_coords</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">unraveled_coords</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2025, Intel Corporation.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>