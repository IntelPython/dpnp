

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DPNP API Functions &mdash; dpnp 0.0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DPNP C++ backend API Functions" href="dpnp_backend_api.html" />
    <link rel="prev" title="DPNP" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="contents.html" class="icon icon-home" alt="Documentation Home"> dpnp
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">About dpnp</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">DPNP API</a></li>
<li class="toctree-l1"><a class="reference internal" href="dpnp_backend_api.html">DPNP C++ backend API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="contents.html">dpnp</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="contents.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>DPNP API Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/dpnp_api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dpnp-api-functions">
<span id="dpnp-api"></span><h1>DPNP API Functions (122)<a class="headerlink" href="#dpnp-api-functions" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-dpnp"></span><dl class="py function">
<dt id="dpnp.abs">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#abs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute value element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.add()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.absolute">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">absolute</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#absolute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.absolute" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the absolute value element-wise.</p>
<dl class="simple">
<dt>x1<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
</dl>
<dl class="simple">
<dt>absolute<span class="classifier">ndarray</span></dt><dd><p>An ndarray containing the absolute value of each element in x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.add">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add arguments element-wise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ‘out’ parameter is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>x1  (dpnp.dparray): The left argument.
x2  (dpnp.dparray): The right argument.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: The sum of x1 and x2, element-wise.
This is a scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.add()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.all">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether all array elements along a given axis evaluate to True.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical AND reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical AND over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.
It must have the same shape as the expected output and its
type is preserved (e.g., if <code class="docutils literal notranslate"><span class="pre">dtype(out)</span></code> is float, the result
will consist of 0.0’s and 1.0’s). See <cite>ufuncs-output-type</cite> for more
details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>all</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>all<span class="classifier">ndarray, bool</span></dt><dd><p>A new boolean or array is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity
evaluate to <cite>True</cite> because these are not equal to zero.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.amax">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">amax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#amax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.amax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.
Parameters
———-
input : array_like</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.
.. versionadded:: 1.7.0
If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
</dl>
<dl class="simple">
<dt>amax<span class="classifier">ndarray or scalar</span></dt><dd><p>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.amin">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">amin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#amin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.amin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of an array or minimum along an axis.
Parameters
———-
input : array_like</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.
.. versionadded:: 1.7.0
If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.
If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>amin</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
<dt>initial<span class="classifier">scalar, optional</span></dt><dd><p>The maximum value of an output element. Must be present to allow
computation on empty slice. See <cite>~numpy.ufunc.reduce</cite> for details.
.. versionadded:: 1.15.0</p>
</dd>
<dt>where<span class="classifier">array_like of bool, optional</span></dt><dd><p>Elements to compare for the minimum. See <cite>~numpy.ufunc.reduce</cite>
for details.
.. versionadded:: 1.17.0</p>
</dd>
</dl>
<dl class="simple">
<dt>amin<span class="classifier">ndarray or scalar</span></dt><dd><p>Minimum of <cite>input</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">input.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.any">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#any"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Returns single boolean unless <cite>axis</cite> is not <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Input array or object that can be converted to an array.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which a logical OR reduction is performed.
The default (<code class="docutils literal notranslate"><span class="pre">axis=None</span></code>) is to perform a logical OR over all
the dimensions of the input array. <cite>axis</cite> may be negative, in
which case it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternate output array in which to place the result.  It must have
the same shape as the expected output and its type is preserved
(e.g., if it is of type float, then it will remain so, returning
1.0 for True and 0.0 for False, regardless of the type of <cite>a</cite>).
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the input array.</p>
<p>If the default value is passed, then <cite>keepdims</cite> will not be
passed through to the <cite>any</cite> method of sub-classes of
<cite>ndarray</cite>, however any non-default value will be.  If the
sub-class’ method does not implement <cite>keepdims</cite> any
exceptions will be raised.</p>
</dd>
</dl>
<dl class="simple">
<dt>any<span class="classifier">bool or ndarray</span></dt><dd><p>A new boolean or <cite>ndarray</cite> is returned unless <cite>out</cite> is specified,
in which case a reference to <cite>out</cite> is returned.</p>
</dd>
</dl>
<p>ndarray.any : equivalent method</p>
<p>all : Test whether all elements along a given axis evaluate to True.</p>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate
to <cite>True</cite> because these are not equal to zero.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arange">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arange</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#arange"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arange" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array with evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval [start, stop). The first
three arguments are mapped like the <code class="docutils literal notranslate"><span class="pre">range</span></code> built-in function, i.e. start
and step are optional.</p>
<blockquote>
<div><p>start: Start of the interval.
stop: End of the interval.
step: Step width between each pair of consecutive values.
dtype: Data type specifier. It is inferred from other arguments by</p>
<blockquote>
<div><p>default.</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><p>inumpy.dparray: The 1-D array of range values.</p>
</div></blockquote>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.arange()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arccos">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arccos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arccos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arccos" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of cos so that, if y = cos(x), then x = arccos(y).</p>
<p>x1 : x-coordinate on the unit circle. For real arguments, the domain is [-1, 1].</p>
<p>out : The angle of the ray intersecting the unit circle at the given x-coordinate in radians [0, pi]. This is a scalar if x is a scalar.</p>
<p>cos, arctan, arcsin, emath.arccos</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arccosh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arccosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arccosh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arccosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric inverse hyperbolic cosine, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arcsin">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arcsin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arcsin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arcsin" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse sine, element-wise.</p>
<p>x1 : y-coordinate on the unit circle.</p>
<p>out : The inverse sine of each element in x, in radians and in the closed interval [-pi/2, pi/2]. This is a scalar if x is a scalar.</p>
<p>sin, cos, arccos, tan, arctan, arctan2, emath.arcsin</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arcsinh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arcsinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arcsinh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arcsinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse hyperbolic sine, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arctan">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arctan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arctan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arctan" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric inverse tangent, element-wise.</p>
<p>The inverse of tan, so that if y = tan(x) then x = arctan(y).</p>
<p>x1 : array_like</p>
<p>out : Out has the same shape as x. Its real part is in [-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2). This is a scalar if x is a scalar.</p>
<p>arctan2, angle</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arctan2">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arctan2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arctan2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arctan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise arc tangent of x1/x2 choosing the quadrant correctly.</p>
<p>The quadrant (i.e., branch) is chosen so that arctan2(x1, x2) is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (x2, x1). (Note the role reversal: the “y-coordinate” is the first function parameter, the “x-coordinate” is the second.) By IEEE convention, this function is defined for x2 = +/-0 and for either or both of x1 and x2 = +/-inf (see Notes for specific values).</p>
<p>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use angle.</p>
<p>x1 : y-coordinates.</p>
<p>x2 : x-coordinates. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
<p>out : Array of angles in radians, in the range [-pi, pi]. This is a scalar if both x1 and x2 are scalars.</p>
<p>arctan, tan, angle</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.arctanh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">arctanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#arctanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.arctanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric hyperbolic inverse tangent, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.argmax">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">argmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_searching.html#argmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.argmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the maximum values along an axis.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>Input array.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>By default, the index is into the flattened array, otherwise
along the specified axis.</p>
</dd>
<dt>out<span class="classifier">array, optional</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray of ints</span></dt><dd><p>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
</dl>
<p>ndarray.argmax, argmin
amax : The maximum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">np.expand_dims(index_array,</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>from argmax to an array as if by calling max.</p>
</div></blockquote>
<p>In case of multiple occurrences of the maximum values, the indices
corresponding to the first occurrence are returned.
Examples
——–
&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10
&gt;&gt;&gt; a
array([[10, 11, 12],</p>
<blockquote>
<div><p>[13, 14, 15]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 2])</span>
<span class="go">Indexes of the maximal elements of a N-dimensional array:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(1, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([0, 5, 2, 3, 4, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1, keepdims=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[4],</span>
<span class="go">       [3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([4, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.argmin">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">argmin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_searching.html#argmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.argmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the minimum values along an axis.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>Input array.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">int, optional</span></dt><dd><p>By default, the index is into the flattened array, otherwise
along the specified axis.</p>
</dd>
<dt>out<span class="classifier">array, optional</span></dt><dd><p>If provided, the result will be inserted into this array. It should
be of the appropriate shape and dtype.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray of ints</span></dt><dd><p>Array of indices into the array. It has the same shape as <cite>a.shape</cite>
with the dimension along <cite>axis</cite> removed.</p>
</dd>
</dl>
<p>ndarray.argmin, argmax
amin : The minimum value along a given axis.
unravel_index : Convert a flat index into an index tuple.
take_along_axis : Apply <code class="docutils literal notranslate"><span class="pre">np.expand_dims(index_array,</span> <span class="pre">axis)</span></code></p>
<blockquote>
<div><p>from argmin to an array as if by calling min.</p>
</div></blockquote>
<p>In case of multiple occurrences of the minimum values, the indices
corresponding to the first occurrence are returned.
Examples
——–
&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10
&gt;&gt;&gt; a
array([[10, 11, 12],</p>
<blockquote>
<div><p>[13, 14, 15]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([0, 0])</span>
<span class="go">Indices of the minimum elements of a N-dimensional array:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span>
<span class="go">(0, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([10, 11, 12, 13, 10, 15])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># Only the first occurrence is returned.</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.min(x, axis=-1, keepdims=True)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2],</span>
<span class="go">       [0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Same as np.max(x, axis=-1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">index_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 0])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.argsort">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_sorting.html#argsort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an ndarray of indices that sort the array along the
specified axis.  Masked values are filled beforehand to
<cite>fill_value</cite>.
Parameters
———-
axis : int, optional</p>
<blockquote>
<div><p>Axis along which to sort. If None, the default, the flattened array
is used.
..  versionchanged:: 1.13.0</p>
<blockquote>
<div><p>Previously, the default was documented to be -1, but that was
in error. At some future date, the default will change to -1, as
originally intended.
Until then, the axis should be given explicitly when
<code class="docutils literal notranslate"><span class="pre">arr.ndim</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, to avoid a FutureWarning.</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>kind<span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt><dd><p>The sorting algorithm used.</p>
</dd>
<dt>order<span class="classifier">list, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  Not all fields need be
specified.</p>
</dd>
<dt>endwith<span class="classifier">{True, False}, optional</span></dt><dd><p>Whether missing values (if any) should be treated as the largest values
(True) or the smallest values (False)
When the array contains unmasked values at the same extremes of the
datatype, the ordering of these values and the masked values is
undefined.</p>
</dd>
<dt>fill_value<span class="classifier">{var}, optional</span></dt><dd><p>Value used internally for the masked values.
If <code class="docutils literal notranslate"><span class="pre">fill_value</span></code> is not None, it supersedes <code class="docutils literal notranslate"><span class="pre">endwith</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>index_array<span class="classifier">ndarray, int</span></dt><dd><p>Array of indices that sort <cite>a</cite> along the specified axis.
In other words, <code class="docutils literal notranslate"><span class="pre">a[index_array]</span></code> yields a sorted <cite>a</cite>.</p>
</dd>
</dl>
<p>MaskedArray.sort : Describes sorting algorithms used.
lexsort : Indirect stable sort with multiple keys.
numpy.ndarray.sort : Inplace sort.
Notes
—–
See <cite>sort</cite> for notes on the different sorting algorithms.
Examples
——–
&gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])
&gt;&gt;&gt; a
masked_array(data=[3, 2, –],</p>
<blockquote>
<div><blockquote>
<div><p>mask=[False, False,  True],</p>
</div></blockquote>
<p>fill_value=999999)</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
<span class="go">array([1, 0, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.array">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ndmin</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.array" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an array.</p>
<p>This function currently does not support the <code class="docutils literal notranslate"><span class="pre">subok</span></code> option.</p>
<dl>
<dt>Args:</dt><dd><dl class="simple">
<dt>obj: <code class="xref py py-class docutils literal notranslate"><span class="pre">inumpy.dparray</span></code> object or any other object that can be</dt><dd><p>passed to <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.array()</span></code>.</p>
</dd>
</dl>
<p>dtype: Data type specifier.
copy (bool): If <code class="docutils literal notranslate"><span class="pre">False</span></code>, this function returns <code class="docutils literal notranslate"><span class="pre">obj</span></code> if possible.</p>
<blockquote>
<div><p>Otherwise this function always returns a new array.</p>
</div></blockquote>
<dl class="simple">
<dt>order ({‘C’, ‘F’, ‘A’, ‘K’}): Row-major (C-style) or column-major</dt><dd><p>(Fortran-style) order.
When <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘A’, it uses ‘F’ if <code class="docutils literal notranslate"><span class="pre">a</span></code> is column-major and
uses ‘C’ otherwise.
And when <code class="docutils literal notranslate"><span class="pre">order</span></code> is ‘K’, it keeps strides as closely as
possible.
If <code class="docutils literal notranslate"><span class="pre">obj</span></code> is <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, the function returns ‘C’ or
‘F’ order array.</p>
</dd>
<dt>subok (bool): If True, then sub-classes will be passed-through,</dt><dd><p>otherwise the returned array will be forced to be a base-class
array (default).</p>
</dd>
<dt>ndmin (int): Minimum number of dimensions. Ones are inserted to the</dt><dd><p>head of the shape if needed.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>inumpy.dparray: An array on the current device.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method currently does not support <code class="docutils literal notranslate"><span class="pre">subok</span></code> argument.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.array()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.array_equal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">array_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a1</span></em>, <em class="sig-param"><span class="n">a2</span></em>, <em class="sig-param"><span class="n">equal_nan</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface.html#array_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.array_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>True if two arrays have the same shape and elements, False otherwise.</p>
<dl class="simple">
<dt>Parameters</dt><dd><dl class="simple">
<dt>a1, a2: array_like</dt><dd><p>Input arrays.</p>
</dd>
<dt>equal_nanbool</dt><dd><p>Whether to compare NaN’s as equal. If the dtype of a1 and a2 is complex,
values will be considered equal if either the real or the imaginary component of a given value is nan.
New in version 1.19.0.</p>
</dd>
</dl>
</dd>
<dt>Returns</dt><dd><dl class="simple">
<dt>b: bool</dt><dd><p>Returns True if the arrays are equal.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.allclose()</span></code> <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.array_equiv()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.asarray">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">asarray</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#asarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.asarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an input object into array.</p>
<p>This is equivalent to <code class="docutils literal notranslate"><span class="pre">array(a,</span> <span class="pre">dtype,</span> <span class="pre">copy=False)</span></code>.</p>
<dl>
<dt>Args:</dt><dd><p>input: The source object.
dtype: Data type specifier. It is inferred from the input by default.
order{‘C’, ‘F’}, optional</p>
<blockquote>
<div><p>Whether to use row-major (C-style) or column-major (Fortran-style) memory representation.
Defaults to ‘C’.</p>
</div></blockquote>
</dd>
<dt>Returns:</dt><dd><p>inumpy.dparray populated with input data</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.asarray()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.asnumpy">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">asnumpy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface.html#asnumpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.asnumpy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the NumPy array with input data.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>input: Arbitrary object that can be converted to <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>.</p>
</dd>
<dt>Returns:</dt><dd><p>numpy.ndarray: array with input data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.average">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">average</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">weights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">returned</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#average"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.average" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the weighted average along the specified axis.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>Array containing data to be averaged. If <cite>a</cite> is not an array, a
conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to average <cite>a</cite>.  The default,
axis=None, will average over all of the elements of the input array.
If axis is negative it counts from the last to the first axis.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.7.0.</span></p>
</div>
<p>If axis is a tuple of ints, averaging is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.</p>
</dd>
<dt>weights<span class="classifier">array_like, optional</span></dt><dd><p>An array of weights associated with the values in <cite>a</cite>. Each value in
<cite>a</cite> contributes to the average according to its associated weight.
The weights array can either be 1-D (in which case its length must be
the size of <cite>a</cite> along the given axis) or of the same shape as <cite>a</cite>.
If <cite>weights=None</cite>, then all data in <cite>a</cite> are assumed to have a
weight equal to one.  The 1-D calculation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">weights</span><span class="p">)</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
</pre></div>
</div>
<p>The only constraint on <cite>weights</cite> is that <cite>sum(weights)</cite> must not be 0.</p>
</dd>
<dt>returned<span class="classifier">bool, optional</span></dt><dd><p>Default is <cite>False</cite>. If <cite>True</cite>, the tuple (<cite>average</cite>, <cite>sum_of_weights</cite>)
is returned, otherwise only the average is returned.
If <cite>weights=None</cite>, <cite>sum_of_weights</cite> is equivalent to the number of
elements over which the average is taken.</p>
</dd>
</dl>
<dl class="simple">
<dt>retval, [sum_of_weights]<span class="classifier">array_type or double</span></dt><dd><p>Return the average along the specified axis. When <cite>returned</cite> is <cite>True</cite>,
return a tuple with the average as the first element and the sum
of the weights as the second element. <cite>sum_of_weights</cite> is of the
same type as <cite>retval</cite>. The result dtype follows a genereal pattern.
If <cite>weights</cite> is None, the result dtype will be that of <cite>a</cite> , or <code class="docutils literal notranslate"><span class="pre">float64</span></code>
if <cite>a</cite> is integral. Otherwise, if <cite>weights</cite> is not None and <cite>a</cite> is non-
integral, the result type will be the type of lowest precision capable of
representing values of both <cite>a</cite> and <cite>weights</cite>. If <cite>a</cite> happens to be
integral, the previous rules still applies but the result dtype will
at least be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.</p>
</dd>
</dl>
<dl class="simple">
<dt>ZeroDivisionError</dt><dd><p>When all weights along axis are zero. See <cite>numpy.ma.average</cite> for a
version robust to this type of error.</p>
</dd>
<dt>TypeError</dt><dd><p>When the length of 1D <cite>weights</cite> is not the same as the shape of <cite>a</cite>
along axis.</p>
</dd>
</dl>
<p>mean</p>
<dl class="simple">
<dt>ma.average<span class="classifier">average for masked arrays – useful if your data contains</span></dt><dd><p>“missing” values</p>
</dd>
<dt>numpy.result_type<span class="classifier">Returns the type that results from applying the</span></dt><dd><p>numpy type promotion rules to the arguments.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.bitwise_and">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">bitwise_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#bitwise_and"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.bitwise_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise AND of two arrays element-wise.</p>
<p>Computes the bit-wise AND of the underlying binary representation of the integers in the input arrays.</p>
<dl class="simple">
<dt>x1, x2: array_like or scalar</dt><dd><p>Input arrays or scalars. Only integer and boolean types are handled.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or scalar</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>ogical_and, bitwise_or, bitwise_xor, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.bitwise_not">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">bitwise_not</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="headerlink" href="#dpnp.bitwise_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays.</p>
<dl class="simple">
<dt>x1, x2: array_like or scalar</dt><dd><p>Input arrays or scalars. Only integer and boolean types are handled.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or scalar</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>bitwise_and, bitwise_or, bitwise_xor, logical_not, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.bitwise_or">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">bitwise_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#bitwise_or"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.bitwise_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise OR of two arrays element-wise.</p>
<p>Computes the bit-wise OR of the underlying binary representation of the integers in the input arrays.</p>
<dl class="simple">
<dt>x1, x2: array_like or scalar</dt><dd><p>Input arrays or scalars. Only integer and boolean types are handled.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or scalar</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>logical_or, bitwise_and, bitwise_xor, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.bitwise_xor">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">bitwise_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#bitwise_xor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.bitwise_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the bit-wise XOR of two arrays element-wise.</p>
<p>Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays.</p>
<dl class="simple">
<dt>x1, x2: array_like or scalar</dt><dd><p>Input arrays or scalars. Only integer and boolean types are handled.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or scalar</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>logical_xor, bitwise_and, bitwise_or, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.cbrt">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">cbrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#cbrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.cbrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the cube-root of an array, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.ceil">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#ceil"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute  the ceiling of the input, element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.ceil()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.copyto">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">copyto</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dst</span></em>, <em class="sig-param"><span class="n">src</span></em>, <em class="sig-param"><span class="n">casting</span><span class="o">=</span><span class="default_value">'same_kind'</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#copyto"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.copyto" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies values from one array to another, broadcasting as necessary.
Raises a TypeError if the casting rule is violated, and if where is provided,
it selects which elements to copy.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dst</strong> – ndarray
The array into which values are copied.</p></li>
<li><p><strong>src</strong> – array_like
The array from which values are copied.</p></li>
<li><p><strong>casting</strong> – <p>{‘no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’}, optional
Controls what kind of data casting may occur when copying.</p>
<blockquote>
<div><p>‘no’ means the data types should not be cast at all.</p>
<p>‘equiv’ means only byte-order changes are allowed.</p>
<p>‘safe’ means only casts which can preserve values are allowed.</p>
<p>‘same_kind’ means only safe casts or casts within a kind, like float64 to float32, are allowed.</p>
<p>‘unsafe’ means any data conversions may be done.</p>
</div></blockquote>
</p></li>
<li><p><strong>where</strong> – array_like of bool, optional
A boolean array which is broadcasted to match the dimensions of dst,
and selects elements to copy from src to dst wherever it contains the value True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.cos">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">cos</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#cos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric cosine, element-wise.</p>
<p>x1 : Angle, in radians (2 pi rad equals 360 degrees).</p>
<dl class="simple">
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>The cosine of each element of x. This is a scalar if x is a scalar</p>
</dd>
</dl>
<p>arccos, cosh, sin</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.cosh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">cosh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#cosh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.cosh" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric hyperbolic cosine, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.count_nonzero">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">count_nonzero</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_counting.html#count_nonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.count_nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of non-zero values in the array <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>The word “non-zero” is in reference to the Python 2.x
built-in method <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> (renamed <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
in Python 3.x) of Python objects that tests an object’s
“truthfulness”. For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in <code class="docutils literal notranslate"><span class="pre">a</span></code> (and in
sub-arrays thereof) have their <code class="docutils literal notranslate"><span class="pre">__nonzero__()</span></code> or <code class="docutils literal notranslate"><span class="pre">__bool__()</span></code>
method evaluated to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl>
<dt>a<span class="classifier">array_like</span></dt><dd><p>The array for which to count non-zeros.</p>
</dd>
<dt>axis<span class="classifier">int or tuple, optional</span></dt><dd><p>Axis or tuple of axes along which to count non-zeros.
Default is None, meaning that non-zeros will be counted
along a flattened version of <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.12.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>count<span class="classifier">int or array of int</span></dt><dd><p>Number of non-zero values in the array along a given axis.
Otherwise, the total number of non-zero values in the array
is returned.</p>
</dd>
</dl>
<p>nonzero : Return the coordinates of all the non-zero values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]])</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">19</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([2, 3])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.cov">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">y</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rowvar</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">bias</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fweights</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">aweights</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#cov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate a covariance matrix, given data and weights.</p>
<p>Covariance indicates the level to which two variables vary together.
If we examine N-dimensional samples, <span class="math notranslate nohighlight">\(X = [x_1, x_2, ... x_N]^T\)</span>,
then the covariance matrix element <span class="math notranslate nohighlight">\(C_{ij}\)</span> is the covariance of
<span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(x_j\)</span>. The element <span class="math notranslate nohighlight">\(C_{ii}\)</span> is the variance
of <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>See the notes for an outline of the algorithm.</p>
<dl>
<dt>m<span class="classifier">array_like</span></dt><dd><p>A 1-D or 2-D array containing multiple variables and observations.
Each row of <cite>m</cite> represents a variable, and each column a single
observation of all those variables. Also see <cite>rowvar</cite> below.</p>
</dd>
<dt>y<span class="classifier">array_like, optional</span></dt><dd><p>An additional set of variables and observations. <cite>y</cite> has the same form
as that of <cite>m</cite>.</p>
</dd>
<dt>rowvar<span class="classifier">bool, optional</span></dt><dd><p>If <cite>rowvar</cite> is True (default), then each row represents a
variable, with observations in the columns. Otherwise, the relationship
is transposed: each column represents a variable, while the rows
contain observations.</p>
</dd>
<dt>bias<span class="classifier">bool, optional</span></dt><dd><p>Default normalization (False) is by <code class="docutils literal notranslate"><span class="pre">(N</span> <span class="pre">-</span> <span class="pre">1)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of observations given (unbiased estimate). If <cite>bias</cite> is True,
then normalization is by <code class="docutils literal notranslate"><span class="pre">N</span></code>. These values can be overridden by using
the keyword <code class="docutils literal notranslate"><span class="pre">ddof</span></code> in numpy versions &gt;= 1.5.</p>
</dd>
<dt>ddof<span class="classifier">int, optional</span></dt><dd><p>If not <code class="docutils literal notranslate"><span class="pre">None</span></code> the default value implied by <cite>bias</cite> is overridden.
Note that <code class="docutils literal notranslate"><span class="pre">ddof=1</span></code> will return the unbiased estimate, even if both
<cite>fweights</cite> and <cite>aweights</cite> are specified, and <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> will return
the simple average. See the notes for the details. The default value
is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.5.</span></p>
</div>
</dd>
<dt>fweights<span class="classifier">array_like, int, optional</span></dt><dd><p>1-D array of integer frequency weights; the number of times each
observation vector should be repeated.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
<dt>aweights<span class="classifier">array_like, optional</span></dt><dd><p>1-D array of observation vector weights. These relative weights are
typically large for observations considered “important” and smaller for
observations considered less “important”. If <code class="docutils literal notranslate"><span class="pre">ddof=0</span></code> the array of
weights can be used to assign probabilities to observation vectors.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 1.10.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>The covariance matrix of the variables.</p>
</dd>
</dl>
<p>corrcoef : Normalized covariance matrix</p>
<p>Assume that the observations are in the columns of the observation
array <cite>m</cite> and let <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">fweights</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">aweights</span></code> for brevity. The
steps to compute the weighted covariance are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">/</span> <span class="n">v1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">v1</span> <span class="o">/</span> <span class="p">(</span><span class="n">v1</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that when <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">1</span></code>, the normalization factor
<code class="docutils literal notranslate"><span class="pre">v1</span> <span class="pre">/</span> <span class="pre">(v1**2</span> <span class="pre">-</span> <span class="pre">ddof</span> <span class="pre">*</span> <span class="pre">v2)</span></code> goes over to <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">(np.sum(f)</span> <span class="pre">-</span> <span class="pre">ddof)</span></code>
as it should.</p>
<p>Consider two variables, <span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, which
correlate perfectly, but in opposite directions:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [2, 1, 0]])</span>
</pre></div>
</div>
<p>Note how <span class="math notranslate nohighlight">\(x_0\)</span> increases while <span class="math notranslate nohighlight">\(x_1\)</span> decreases. The covariance
matrix shows this clearly:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[ 1., -1.],</span>
<span class="go">       [-1.,  1.]])</span>
</pre></div>
</div>
<p>Note that element <span class="math notranslate nohighlight">\(C_{0,1}\)</span>, which shows the correlation between
<span class="math notranslate nohighlight">\(x_0\)</span> and <span class="math notranslate nohighlight">\(x_1\)</span>, is negative.</p>
<p>Further, note how <cite>x</cite> and <cite>y</cite> are combined:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">4.3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span>  <span class="mf">1.1</span><span class="p">,</span>  <span class="mf">0.12</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([[11.71      , -4.286     ], # may vary</span>
<span class="go">       [-4.286     ,  2.144133]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array(11.71)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.deg2rad">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">deg2rad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#deg2rad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.deg2rad" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from degrees to radians.
<cite>radians</cite> equivalent function</p>
<p>x1 : Angles in degrees.</p>
<p>out : The corresponding angle in radians. This is a scalar if x is a scalar.</p>
<p>rad2deg, unwrap</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.degrees">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">degrees</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#degrees"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.degrees" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from radians to degrees.</p>
<p>x1 : Input array in radians.</p>
<p>out : The corresponding degree values; if out was supplied this is a reference to it. This is a scalar if x is a scalar.</p>
<p>rad2deg</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.divide">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide arguments element-wise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ‘out’ parameter is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>x1  (dpnp.dparray): The left argument.
x2  (dpnp.dparray): The right argument.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: The division of x1 and x2, element-wise.
This is a scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.divide()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.dot">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">dot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#dot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Dot product of two arrays. Specifically,</p>
<ul>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 1-D arrays, it is inner product of vectors
(without complex conjugation).</p></li>
<li><p>If both <cite>a</cite> and <cite>b</cite> are 2-D arrays, it is matrix multiplication,
but using <a class="reference internal" href="#dpnp.matmul" title="dpnp.matmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">matmul()</span></code></a> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&#64;</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If either <cite>a</cite> or <cite>b</cite> is 0-D (scalar), it is equivalent to <a class="reference internal" href="#dpnp.multiply" title="dpnp.multiply"><code class="xref py py-func docutils literal notranslate"><span class="pre">multiply()</span></code></a>
and using <code class="docutils literal notranslate"><span class="pre">numpy.multiply(a,</span> <span class="pre">b)</span></code> or <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is preferred.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is a 1-D array, it is a sum product over
the last axis of <cite>a</cite> and <cite>b</cite>.</p></li>
<li><p>If <cite>a</cite> is an N-D array and <cite>b</cite> is an M-D array (where <code class="docutils literal notranslate"><span class="pre">M&gt;=2</span></code>), it is a
sum product over the last axis of <cite>a</cite> and the second-to-last axis of <cite>b</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">,:,</span><span class="n">m</span><span class="p">])</span>
</pre></div>
</div>
</li>
</ul>
<dl class="simple">
<dt>a<span class="classifier">array_like</span></dt><dd><p>First argument.</p>
</dd>
<dt>b<span class="classifier">array_like</span></dt><dd><p>Second argument.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Output argument. This must have the exact kind that would be returned
if it was not used. In particular, it must have the right type, must be
C-contiguous, and its dtype must be the dtype that would be returned
for <cite>dot(a,b)</cite>. This is a performance feature. Therefore, if these
conditions are not met, an exception is raised, instead of attempting
to be flexible.</p>
</dd>
</dl>
<dl class="simple">
<dt>output<span class="classifier">ndarray</span></dt><dd><p>Returns the dot product of <cite>a</cite> and <cite>b</cite>.  If <cite>a</cite> and <cite>b</cite> are both
scalars or both 1-D arrays then a scalar is returned; otherwise
an array is returned.
If <cite>out</cite> is given, then it is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.dpnp_queue_initialize">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">dpnp_queue_initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#dpnp.dpnp_queue_initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>File: dpnp/backend.pyx (starting at line 198)
Initialize SYCL queue which will be used for any library operations</p>
<blockquote>
<div><p>It takes visible time and needs to be done in the module loading procedure</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="dpnp.einsum">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">einsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">subscripts</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">operands</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#einsum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.einsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the Einstein summation convention on the operands.
Using the Einstein summation convention, many common multi-dimensional
array operations can be represented in a simple fashion. This function
provides a way to compute such summations.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.einsum()</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.einsum_path">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">einsum_path</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">subscripts</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">operands</span></em>, <em class="sig-param"><span class="n">optimize</span><span class="o">=</span><span class="default_value">'greedy'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#einsum_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.einsum_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.einsum_path()</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.empty">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">empty</code><span class="sig-paren">(</span><em class="sig-param">shape</em>, <em class="sig-param">dtype=&lt;class 'numpy.float64'&gt;</em>, <em class="sig-param">order='C'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#empty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new matrix of given shape and type, without initializing entries.
Parameters
———-
shape : int or tuple of int</p>
<blockquote>
<div><p>Shape of the empty matrix.</p>
</div></blockquote>
<dl class="simple">
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Desired output data-type.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
<p>empty_like, zeros
Notes
—–
<cite>empty</cite>, unlike <cite>zeros</cite>, does not set the matrix values to zero,
and may therefore be marginally faster.  On the other hand, it requires
the user to manually set all the values in the array, and should be
used with caution.
Examples
——–
&gt;&gt;&gt; import numpy.matlib
&gt;&gt;&gt; np.matlib.empty((2, 2))    # filled with random data
matrix([[  6.76425276e-320,   9.79033856e-307], # random</p>
<blockquote>
<div><p>[  7.39337286e-309,   3.22135945e-309]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">matrix([[ 6600475,        0], # random</span>
<span class="go">        [ 6586976, 22740995]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.empty_like">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">empty_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prototype</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#empty_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.empty_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array with the same shape and type as a given array.
Parameters
———-
prototype : array_like</p>
<blockquote>
<div><p>The shape and data-type of <cite>prototype</cite> define these same attributes
of the returned array.</p>
</div></blockquote>
<dl class="simple">
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.
.. versionadded:: 1.6.0</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <code class="docutils literal notranslate"><span class="pre">prototype</span></code> is Fortran
contiguous, ‘C’ otherwise. ‘K’ means match the layout of <code class="docutils literal notranslate"><span class="pre">prototype</span></code>
as closely as possible.
.. versionadded:: 1.6.0</p>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.
.. versionadded:: 1.17.0</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of uninitialized (arbitrary) data with the same
shape and type as <cite>prototype</cite>.</p>
</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
Notes
—–
This function does <em>not</em> initialize the returned array; to do that use
<cite>zeros_like</cite> or <cite>ones_like</cite> instead.  It may be marginally faster than
the functions that do set the array values.
Examples
——–
&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like
&gt;&gt;&gt; np.empty_like(a)
array([[-1073741821, -1073741821,           3],    # uninitialized</p>
<blockquote>
<div><p>[          0,           0, -1073741821]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],[</span><span class="mf">4.</span><span class="p">,</span><span class="mf">5.</span><span class="p">,</span><span class="mf">6.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized</span>
<span class="go">       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.equal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 == x2) element-wise.</p>
<p>Unlike <cite>numpy.equal</cite>, this comparison is performed by first
stripping whitespace characters from the end of the string.  This
behavior is provided for backward-compatibility with numarray.</p>
<dl class="simple">
<dt>x1, x2<span class="classifier">array_like of str or unicode</span></dt><dd><p>Input arrays of the same shape.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray or bool</span></dt><dd><p>Output array of bools, or a single bool if x1 and x2 are scalars.</p>
</dd>
</dl>
<p>not_equal, greater_equal, less_equal, greater, less</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.erf">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">erf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_libmath.html#erf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.erf" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the ‘error function’ at in_array1.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">math.erf()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.exp">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">exp</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#exp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric exponent, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.exp2">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">exp2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#exp2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.exp2" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric exponent2, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.expm1">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">expm1</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#expm1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.expm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric exponent minus 1, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.fabs">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">fabs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#fabs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.fabs" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the absolute values element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.fabs()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.floor">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#floor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the floor of the input, element-wise.</p>
<p>Some spreadsheet programs calculate the “floor-towards-zero”, in other words floor(-2.5) == -2.
dpNP instead uses the definition of floor where floor(-2.5) == -3.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.floor()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.floor_divide">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">floor_divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#floor_divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.floor_divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the largest integer smaller or equal to the division of the inputs.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.floor_divide()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.fmax">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">fmax</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#fmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.fmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise maximum of array elements.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.fmax()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.fmin">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">fmin</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#fmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.fmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise minimum of array elements.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.fmin()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.fmod">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">fmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#fmod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.fmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the element-wise remainder of division.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.fmod()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.full">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">full</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">fill_value</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with <cite>fill_value</cite>.
Parameters
———-
shape : int or sequence of ints</p>
<blockquote>
<div><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</div></blockquote>
<dl>
<dt>fill_value<span class="classifier">scalar or array_like</span></dt><dd><p>Fill value.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><dl class="simple">
<dt>The desired data-type for the array  The default, None, means</dt><dd><p><cite>np.array(fill_value).dtype</cite>.</p>
</dd>
</dl>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional</span></dt><dd><p>Whether to store multidimensional data in C- or Fortran-contiguous
(row- or column-wise) order in memory.</p>
</dd>
<dt>${ARRAY_FUNCTION_LIKE}</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 1.20.0.</span></p>
</div>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.
Examples
——–
&gt;&gt;&gt; np.full((2, 2), np.inf)
array([[inf, inf],</p>
<blockquote>
<div><p>[inf, inf]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">array([[10, 10],</span>
<span class="go">       [10, 10]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [1, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.full_like">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">full_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prototype</span></em>, <em class="sig-param"><span class="n">fill_value</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#full_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.full_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a full array with the same shape and type as a given array.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</div></blockquote>
<dl class="simple">
<dt>fill_value<span class="classifier">scalar</span></dt><dd><p>Fill value.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.</p>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.
.. versionadded:: 1.17.0</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of <cite>fill_value</cite> with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.
Examples
——–
&gt;&gt;&gt; x = np.arange(6, dtype=int)
&gt;&gt;&gt; np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
&gt;&gt;&gt; np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
&gt;&gt;&gt; np.full_like(x, 0.1, dtype=np.double)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
&gt;&gt;&gt; np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])
&gt;&gt;&gt; y = np.arange(6, dtype=np.double)
&gt;&gt;&gt; np.full_like(y, 0.1)
array([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.get_include">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">get_include</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface.html#get_include"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.get_include" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directory that contains the DPNP C++ backend *.h header files.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.greater">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">greater</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#greater"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.greater" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 &gt; x2) element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.greater_equal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">greater_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#greater_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.greater_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 &gt;= x2) element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.hypot">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">hypot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#hypot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.hypot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the “legs” of a right triangle, return its hypotenuse.</p>
<p>Equivalent to sqrt(x1**2 + x2**2), element-wise. If x1 or x2 is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</p>
<p>x1, x2 : Leg of the triangle(s). If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
<p>out : The hypotenuse of the triangle(s). This is a scalar if both x1 and x2 are scalars.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.inner">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">inner</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#inner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.inner" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inner product of two vectors.</p>
<p>The input arrays are flattened into 1-D vectors and then it performs inner
product of these vectors.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.inner()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.invert">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">invert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#invert"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.invert" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays.</p>
<dl class="simple">
<dt>x1, x2: array_like or scalar</dt><dd><p>Input arrays or scalars. Only integer and boolean types are handled.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or scalar</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>bitwise_and, bitwise_or, bitwise_xor, logical_not, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.isclose">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">isclose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">rtol</span><span class="o">=</span><span class="default_value">1e-05</span></em>, <em class="sig-param"><span class="n">atol</span><span class="o">=</span><span class="default_value">1e-08</span></em>, <em class="sig-param"><span class="n">equal_nan</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#isclose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.isclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a boolean array where two arrays are element-wise equal within a tolerance.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.isfinite">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">isfinite</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#isfinite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.isfinite" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input values.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray, bool</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is not positive infinity, negative infinity,
or NaN; false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
<p>isinf, isneginf, isposinf, isnan</p>
<p>Not a Number, positive infinity and negative infinity are considered
to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Also that positive infinity is not equivalent to negative infinity. But
infinity is equivalent to positive infinity.  Errors result if the
second argument is also supplied when <cite>x</cite> is a scalar input, or if
first and second arguments have different shapes.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.isinf">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">isinf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#isinf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.isinf" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for positive or negative infinity.</p>
<p>Returns a boolean array of the same shape as <cite>x</cite>, True where <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">==</span>
<span class="pre">+/-inf</span></code>, otherwise False.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input values</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">bool (scalar) or boolean ndarray</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is positive or negative infinity, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
<p>isneginf, isposinf, isnan, isfinite</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754).</p>
<p>Errors result if the second argument is supplied when the first
argument is a scalar, or if the first and second arguments have
different shapes.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.isnan">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">isnan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#isnan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.isnan" title="Permalink to this definition">¶</a></dt>
<dd><p>Test element-wise for NaN and return result as a boolean array.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Input array.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray or bool</span></dt><dd><p>True where <code class="docutils literal notranslate"><span class="pre">x</span></code> is NaN, false otherwise.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
<p>isinf, isneginf, isposinf, isfinite, isnat</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.kron">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">kron</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#kron"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.kron" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kronecker product of two arrays.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.kron()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.left_shift">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">left_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#left_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.left_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the bits of an integer to the left.</p>
<p>Bits are shifted to the left by appending x2 0s at the right of x1.</p>
<dl class="simple">
<dt>x1, x2: array_like or int</dt><dd><p>Input values.</p>
</dd>
<dt>x1, x2: array_like or int</dt><dd><p>Number of zeros to append to x1. Has to be non-negative.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or int</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>right_shift, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.less">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">less</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#less"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.less" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 &lt; x2) element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.less_equal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">less_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#less_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.less_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 &lt;= x2) element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.log">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">log</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric logarithm, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.log10">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">log10</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#log10"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.log10" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric logarithm, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.log1p">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">log1p</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#log1p"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.log1p" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric logarithm, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.log2">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">log2</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#log2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.log2" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric logarithm, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.logical_and">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">logical_and</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#logical_and"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.logical_and" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 AND x2 element-wise.</p>
<dl class="simple">
<dt>x1, x2<span class="classifier">array_like</span></dt><dd><p>Input arrays. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray or bool</span></dt><dd><p>Boolean result of the logical AND operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
<p>logical_or, logical_not, logical_xor
bitwise_and</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.logical_not">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">logical_not</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#logical_not"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.logical_not" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of NOT x element-wise.</p>
<dl class="simple">
<dt>x<span class="classifier">array_like</span></dt><dd><p>Logical NOT is applied to the elements of <cite>x</cite>.</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id9"><span class="problematic" id="id10">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">bool or ndarray of bool</span></dt><dd><p>Boolean result with the same shape as <cite>x</cite> of the NOT operation
on elements of <cite>x</cite>.
This is a scalar if <cite>x</cite> is a scalar.</p>
</dd>
</dl>
<p>logical_and, logical_or, logical_xor</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.logical_or">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">logical_or</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#logical_or"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.logical_or" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 OR x2 element-wise.</p>
<dl class="simple">
<dt>x1, x2<span class="classifier">array_like</span></dt><dd><p>Logical OR is applied to the elements of <cite>x1</cite> and <cite>x2</cite>.
If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">ndarray or bool</span></dt><dd><p>Boolean result of the logical OR operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
<p>logical_and, logical_not, logical_xor
bitwise_or</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.logical_xor">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">logical_xor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">where</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#logical_xor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.logical_xor" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truth value of x1 XOR x2, element-wise.</p>
<dl class="simple">
<dt>x1, x2<span class="classifier">array_like</span></dt><dd><p>Logical XOR is applied to the elements of <cite>x1</cite> and <cite>x2</cite>. If <code class="docutils literal notranslate"><span class="pre">x1.shape</span> <span class="pre">!=</span> <span class="pre">x2.shape</span></code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
</dd>
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>A location into which the result is stored. If provided, it must have
a shape that the inputs broadcast to. If not provided or None,
a freshly-allocated array is returned. A tuple (possible only as a
keyword argument) must have length equal to the number of outputs.</p>
</dd>
<dt>where<span class="classifier">array_like, optional</span></dt><dd><p>This condition is broadcast over the input. At locations where the
condition is True, the <cite>out</cite> array will be set to the ufunc result.
Elsewhere, the <cite>out</cite> array will retain its original value.
Note that if an uninitialized <cite>out</cite> array is created via the default
<code class="docutils literal notranslate"><span class="pre">out=None</span></code>, locations within it where the condition is False will
remain uninitialized.</p>
</dd>
<dt><a href="#id13"><span class="problematic" id="id14">**</span></a>kwargs</dt><dd><p>For other keyword-only arguments, see the
<span class="xref std std-ref">ufunc docs</span>.</p>
</dd>
</dl>
<dl class="simple">
<dt>y<span class="classifier">bool or ndarray of bool</span></dt><dd><p>Boolean result of the logical XOR operation applied to the elements
of <cite>x1</cite> and <cite>x2</cite>; the shape is determined by broadcasting.
This is a scalar if both <cite>x1</cite> and <cite>x2</cite> are scalars.</p>
</dd>
</dl>
<p>logical_and, logical_or, logical_not, bitwise_xor</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.matmul">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">matmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">in_array2</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface.html#matmul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.matmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the matrix product of two arrays and is the implementation of
the <cite>&#64;</cite> operator introduced in Python 3.5 following PEP465.</p>
<p>The main difference against dpnp.dot are the handling of arrays with more
than 2 dimensions. For more information see <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.matmul()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The out array as input is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>in_array1 (dpnp.dparray): The left argument.
in_array2 (dpnp.dparray): The right argument.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: Output array.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.matmul()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.max">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#max"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of an array or maximum along an axis.
Parameters
———-
input : array_like</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate.  By default, flattened input is
used.
.. versionadded:: 1.7.0
If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result.  Must
be of the same shape and buffer length as the expected output.
See <cite>ufuncs-output-type</cite> for more details.</p>
</dd>
</dl>
<dl class="simple">
<dt>amax<span class="classifier">ndarray or scalar</span></dt><dd><p>Maximum of <cite>a</cite>. If <cite>axis</cite> is None, the result is a scalar value.
If <cite>axis</cite> is given, the result is an array of dimension
<code class="docutils literal notranslate"><span class="pre">a.ndim</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.maximum">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">maximum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#maximum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.maximum" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise maximum of array elements.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.maximum()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.mean">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#mean"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements.</p>
<dl class="simple">
<dt>input<span class="classifier">array_like</span></dt><dd><p>Array containing numbers whose mean is desired. If <cite>input</cite> is not an
array, a conversion is attempted.</p>
</dd>
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which the means are computed. The default is to
compute the mean of the flattened array.
.. versionadded:: 1.7.0
If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
</dl>
<dl class="simple">
<dt>m<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>If <cite>out=None</cite>, returns a new array containing the mean values,
otherwise a reference to the output array is returned.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.median">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">median</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite_input</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#median"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median along the specified axis.
Returns the median of the array elements.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>Input array or object that can be converted to an array.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">{int, sequence of int, None}, optional</span></dt><dd><p>Axis or axes along which the medians are computed. The default
is to compute the median along a flattened version of the array.
A sequence of axes is supported since version 1.9.0.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. It must
have the same shape and buffer length as the expected output,
but the type (of the output) will be cast if necessary.</p>
</dd>
<dt>overwrite_input<span class="classifier">bool, optional</span></dt><dd><p>If True, then allow use of memory of input array <cite>a</cite> for
calculations. The input array will be modified by the call to
<cite>median</cite>. This will save memory when you do not need to preserve
the contents of the input array. Treat the input as undefined,
but it will probably be fully or partially sorted. Default is
False. If <cite>overwrite_input</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code> and <cite>a</cite> is not already an
<cite>ndarray</cite>, an error will be raised.</p>
</dd>
<dt>keepdims<span class="classifier">bool, optional</span></dt><dd><p>If this is set to True, the axes which are reduced are left
in the result as dimensions with size one. With this option,
the result will broadcast correctly against the original <cite>arr</cite>.
.. versionadded:: 1.9.0</p>
</dd>
</dl>
<dl class="simple">
<dt>median<span class="classifier">ndarray</span></dt><dd><p>A new array holding the result. If the input contains integers
or floats smaller than <code class="docutils literal notranslate"><span class="pre">float64</span></code>, then the output data-type is
<code class="docutils literal notranslate"><span class="pre">np.float64</span></code>.  Otherwise, the data-type of the output is the
same as that of the input. If <cite>out</cite> is specified, that array is
returned instead.</p>
</dd>
</dl>
<p>mean, percentile
Notes
—–
Given a vector <code class="docutils literal notranslate"><span class="pre">V</span></code> of length <code class="docutils literal notranslate"><span class="pre">N</span></code>, the median of <code class="docutils literal notranslate"><span class="pre">V</span></code> is the
middle value of a sorted copy of <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> - i
e., <code class="docutils literal notranslate"><span class="pre">V_sorted[(N-1)/2]</span></code>, when <code class="docutils literal notranslate"><span class="pre">N</span></code> is odd, and the average of the
two middle values of <code class="docutils literal notranslate"><span class="pre">V_sorted</span></code> when <code class="docutils literal notranslate"><span class="pre">N</span></code> is even.
Examples
——–
&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],</p>
<blockquote>
<div><p>[ 3,  2,  1]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">array([6.5, 4.5, 2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span>
<span class="go">array([6.5,  4.5,  2.5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([7.,  2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">3.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.min">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">input</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_statistics.html#min"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum along a given axis.
Parameters
———-
input : array_like</p>
<blockquote>
<div><p>Input data.</p>
</div></blockquote>
<dl class="simple">
<dt>axis<span class="classifier">None or int or tuple of ints, optional</span></dt><dd><p>Axis or axes along which to operate. By default, flattened input is used.
New in version 1.7.0.
If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.</p>
</dd>
<dt>out<span class="classifier">ndarray, optional</span></dt><dd><p>Alternative output array in which to place the result. Must be of the
same shape and buffer length as the expected output.
See ufuncs-output-type for more details.</p>
</dd>
</dl>
<dl class="simple">
<dt>m<span class="classifier">ndarray, see dtype parameter above</span></dt><dd><p>Minimum of a. If axis is None, the result is a scalar value.
If axis is given, the result is an array of dimension a.ndim - 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="dpnp.minimum">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">minimum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#minimum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.minimum" title="Permalink to this definition">¶</a></dt>
<dd><p>Element-wise minimum of array elements.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.minimum()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.mod">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#mod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute element-wise remainder of division.</p>
<p>Alias for <a class="reference internal" href="#dpnp.remainder" title="dpnp.remainder"><code class="xref py py-func docutils literal notranslate"><span class="pre">dpnp.remainder()</span></code></a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mod()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.moveaxis">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">moveaxis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">source</span></em>, <em class="sig-param"><span class="n">destination</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#moveaxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.moveaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Move axes of an array to new positions. Other axes remain in their original order.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.multiply">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">multiply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply arguments element-wise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ‘out’ parameter is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>x1  (dpnp.dparray): The left argument.
x2  (dpnp.dparray): The right argument.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: The product of x1 and x2, element-wise.
This is a scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.multiply()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.negative">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">negative</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#negative"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.negative" title="Permalink to this definition">¶</a></dt>
<dd><p>Negative element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.negative()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.not_equal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">not_equal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_logic.html#not_equal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.not_equal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return (x1 != x2) element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.ones">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">ones</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#ones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with ones.</p>
<dl class="simple">
<dt>shape<span class="classifier">int or sequence of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int64</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional, default: C</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">dparray</span></dt><dd><p>Array of ones with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 1., 1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int64</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 1, 1])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[1.],</span>
<span class="go">       [1.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[1.,  1.],</span>
<span class="go">       [1.,  1.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.ones_like">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">ones_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prototype</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#ones_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.ones_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of ones with the same shape and type as a given array.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</div></blockquote>
<dl class="simple">
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.
.. versionadded:: 1.6.0</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.
.. versionadded:: 1.6.0</p>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.
.. versionadded:: 1.17.0</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of ones with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.
Examples
——–
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; x = x.reshape((2, 3))
&gt;&gt;&gt; x
array([[0, 1, 2],</p>
<blockquote>
<div><p>[3, 4, 5]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[1, 1, 1],</span>
<span class="go">       [1, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0., 1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([1.,  1.,  1.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.outer">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">outer</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#outer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.outer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the outer product of two vectors.</p>
<p>The input arrays are flattened into 1-D vectors and then it performs outer
product of these vectors.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.outer()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.power">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">power</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#power"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.power" title="Permalink to this definition">¶</a></dt>
<dd><p>First array elements raised to powers from second array, element-wise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ‘out’ parameter is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>x1  (dpnp.dparray): array.
x2  (dpnp.dparray): array.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: The bases in x1 raised to the exponents in x2.
This is a scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.power()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.prod">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#prod"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate product of array elements over a given axis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.prod()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.rad2deg">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">rad2deg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#rad2deg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.rad2deg" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from radians to degrees.
<cite>degrees</cite> equivalent function</p>
<p>x1 : Angle in radians.</p>
<p>out : The corresponding angle in degrees. This is a scalar if x is a scalar.</p>
<p>deg2rad, unwrap</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.radians">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">radians</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#radians"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.radians" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert angles from degrees to radians.</p>
<p>x1 : Input array in degrees.</p>
<p>out : The corresponding radian values. This is a scalar if x is a scalar.</p>
<p>deg2rad</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.ravel">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">ravel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#ravel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.ravel" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a contiguous flattened array.</p>
<dl class="simple">
<dt>a: array_like</dt><dd><p>Input array.</p>
</dd>
<dt>order: {‘C’, ‘F’, ‘A’, ‘K’}, optional</dt><dd><p>The elements of a are read using this index order.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray</dt><dd><p>Output array.</p>
</dd>
</dl>
<p>flat, flatten, reshape</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.reciprocal">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">reciprocal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#reciprocal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.reciprocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the reciprocal of the argument, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.remainder">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">remainder</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#remainder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.remainder" title="Permalink to this definition">¶</a></dt>
<dd><p>Return element-wise remainder of division.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.repeat">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">repeat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">repeats</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#repeat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeat elements of an array.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.right_shift">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">right_shift</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_bitwise.html#right_shift"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.right_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift the bits of an integer to the right.</p>
<p>Bits are shifted to the right x2.</p>
<dl class="simple">
<dt>x1, x2: array_like or int</dt><dd><p>Input values.</p>
</dd>
<dt>x1, x2: array_like or int</dt><dd><p>Number of bits to remove at the right of x1.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray or int</dt><dd><p>Output array or scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<p>left_shift, binary_repr</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.rollaxis">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">rollaxis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">axis</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#rollaxis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.rollaxis" title="Permalink to this definition">¶</a></dt>
<dd><p>Roll the specified axis backwards, until it lies in a given position.</p>
<dl class="simple">
<dt>a: array_like</dt><dd><p>Input array.</p>
</dd>
<dt>axis: int</dt><dd><p>The axis to be rolled. The positions of the other axes do not change relative to one another.</p>
</dd>
<dt>start: int, optional</dt><dd><p>When start &lt;= axis, the axis is rolled back until it lies in this position.
When start &gt; axis, the axis is rolled until it lies before this position.</p>
</dd>
</dl>
<dl class="simple">
<dt>out: ndarray</dt><dd><p>Output array.</p>
</dd>
</dl>
<p>moveaxis, roll</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sign">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sign</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#sign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sign" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the absolute values element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.sign()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sin">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#sin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric sine, element-wise.</p>
<p>x1 : Angle, in radians (2 pi rad equals 360 degrees).</p>
<dl class="simple">
<dt>out<span class="classifier">ndarray, None, or tuple of ndarray and None, optional</span></dt><dd><p>The sine of each element of x. This is a scalar if x is a scalar</p>
</dd>
</dl>
<p>arcsin, sinh, cos</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sinh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sinh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#sinh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sinh" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric hyperbolic sine, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sort">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">in_array1</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_sorting.html#sort"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sorted copy of an array.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>Array to be sorted.</p>
</div></blockquote>
<dl>
<dt>axis<span class="classifier">int or None, optional</span></dt><dd><p>Axis along which to sort. If None, the array is flattened before
sorting. The default is -1, which sorts along the last axis.</p>
</dd>
<dt>kind<span class="classifier">{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional</span></dt><dd><p>Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’
and ‘mergesort’ use timsort or radix sort under the covers and, in general,
the actual implementation will vary with data type. The ‘mergesort’ option
is retained for backwards compatibility.
.. versionchanged:: 1.15.0.</p>
<blockquote>
<div><p>The ‘stable’ option was added.</p>
</div></blockquote>
</dd>
<dt>order<span class="classifier">str or list of str, optional</span></dt><dd><p>When <cite>a</cite> is an array with fields defined, this argument specifies
which fields to compare first, second, etc.  A single field can
be specified as a string, and not all fields need be specified,
but unspecified fields will still be used, in the order in which
they come up in the dtype, to break ties.</p>
</dd>
</dl>
<dl class="simple">
<dt>sorted_array<span class="classifier">ndarray</span></dt><dd><p>Array of the same type and shape as <cite>a</cite>.</p>
</dd>
</dl>
<p>ndarray.sort : Method to sort an array in-place.
argsort : Indirect sort.
lexsort : Indirect stable sort on multiple keys.
searchsorted : Find elements in a sorted array.
partition : Partial sort.
Notes
—–
The various sorting algorithms are characterized by their average speed,
worst case performance, work space size, and whether they are stable. A
stable sort keeps items with the same key in the same relative
order. The four algorithms implemented in NumPy have the following
properties:
=========== ======= ============= ============ ========</p>
<blockquote>
<div><p>kind      speed   worst case    work space   stable</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The datatype determines which of ‘mergesort’ or ‘timsort’
is actually used, even if ‘mergesort’ is specified. User selection
at a finer scale is not currently available.</p>
</div>
<p>All the sort algorithms make temporary copies of the data when
sorting along any but the last axis.  Consequently, sorting along
the last axis is faster and uses less space than sorting along
any other axis.
The sort order for complex numbers is lexicographic. If both the real
and imaginary parts are non-nan then the order is determined by the
real parts except when they are equal, in which case the order is
determined by the imaginary parts.
Previous to numpy 1.4.0 sorting real and complex arrays containing nan
values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan
values are sorted to the end. The extended sort order is:</p>
<blockquote>
<div><ul class="simple">
<li><p>Real: [R, nan]</p></li>
<li><p>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</p></li>
</ul>
</div></blockquote>
<p>where R is a non-nan real value. Complex values with the same nan
placements are sorted according to the non-nan part if it exists.
Non-nan values are sorted as before.
.. versionadded:: 1.12.0
quicksort has been changed to <a class="reference external" href="https://en.wikipedia.org/wiki/Introsort">introsort</a>.
When sorting does not make enough progress it switches to
<a class="reference external" href="https://en.wikipedia.org/wiki/Heapsort">heapsort</a>.
This implementation makes quicksort O(n*log(n)) in the worst case.
‘stable’ automatically chooses the best stable sorting algorithm
for the data type being sorted.
It, along with ‘mergesort’ is currently mapped to
<a class="reference external" href="https://en.wikipedia.org/wiki/Timsort">timsort</a>
or <a class="reference external" href="https://en.wikipedia.org/wiki/Radix_sort">radix sort</a>
depending on the data type.
API forward compatibility currently limits the
ability to select the implementation and it is hardwired for the different
data types.
.. versionadded:: 1.17.0
Timsort is added for better performance on already or nearly
sorted data. On random data timsort is almost identical to
mergesort. It is now used for stable sort while quicksort is still the
default sort if none is chosen. For timsort details, refer to
<a class="reference external" href="https://github.com/python/cpython/blob/3.7/Objects/listsort.txt">CPython listsort.txt</a>.
‘mergesort’ and ‘stable’ are mapped to radix sort for integer data types. Radix sort is an
O(n) sort instead of O(n log n).
.. versionchanged:: 1.18.0
NaT now sorts to the end of arrays for consistency with NaN.
Examples
——–
&gt;&gt;&gt; a = np.array([[1,4],[3,1]])
&gt;&gt;&gt; np.sort(a)                # sort along the last axis
array([[1, 4],</p>
<blockquote>
<div><p>[1, 3]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>     <span class="c1"># sort the flattened array</span>
<span class="go">array([1, 1, 3, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>        <span class="c1"># sort along the first axis</span>
<span class="go">array([[1, 1],</span>
<span class="go">       [3, 4]])</span>
<span class="go">Use the `order` keyword to specify a field to use when sorting a</span>
<span class="go">structured array:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;S10&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;height&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Arthur&#39;</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">,</span> <span class="mi">41</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Lancelot&#39;</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mi">38</span><span class="p">),</span>
<span class="gp">... </span>          <span class="p">(</span><span class="s1">&#39;Galahad&#39;</span><span class="p">,</span> <span class="mf">1.7</span><span class="p">,</span> <span class="mi">38</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>       <span class="c1"># create a structured array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;height&#39;</span><span class="p">)</span>                        
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Arthur&#39;, 1.8, 41),</span>
<span class="go">       (&#39;Lancelot&#39;, 1.8999999999999999, 38)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
<span class="go">Sort by age, then height if ages are equal:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;height&#39;</span><span class="p">])</span>               
<span class="go">array([(&#39;Galahad&#39;, 1.7, 38), (&#39;Lancelot&#39;, 1.8999999999999999, 38),</span>
<span class="go">       (&#39;Arthur&#39;, 1.8, 41)],</span>
<span class="go">      dtype=[(&#39;name&#39;, &#39;|S10&#39;), (&#39;height&#39;, &#39;&lt;f8&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sqrt">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sqrt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#sqrt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the positive square-root of an array, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.square">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">square</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#square"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.square" title="Permalink to this definition">¶</a></dt>
<dd><p>Return X1 * x1, element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.subtract">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">subtract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#subtract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtract arguments, element-wise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ‘out’ parameter is currently not supported.</p>
</div>
<dl class="simple">
<dt>Args:</dt><dd><p>x1  (dpnp.dparray): array.
x2  (dpnp.dparray): array.
out (dpnp.dparray): Output array.</p>
</dd>
<dt>Returns:</dt><dd><p>dpnp.dparray: The difference of x1 and x2, element-wise.
This is a scalar if both x1 and x2 are scalars.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.subtract()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.sum">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum of array elements over a given axis.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.sum()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.swapaxes">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">swapaxes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">axis1</span></em>, <em class="sig-param"><span class="n">axis2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#swapaxes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.swapaxes" title="Permalink to this definition">¶</a></dt>
<dd><p>Interchange two axes of an array.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.tan">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">tan</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#tan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tangent element-wise.</p>
<p>Equivalent to np.sin(x)/np.cos(x) element-wise.</p>
<p>x1 : Input array.</p>
<p>out : The corresponding tangent values. This is a scalar if x is a scalar.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.tanh">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">tanh</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#tanh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute hyperbolic tangent element-wise.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.tensordot">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">tensordot</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">x2</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">2</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#tensordot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.tensordot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute tensor dot product along specified axes.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.tensordot()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.transpose">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="n">axes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_manipulation.html#transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse or permute the axes of an array; returns the modified array.</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.true_divide">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">true_divide</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#true_divide"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.true_divide" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a true division of the inputs, element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.true_divide()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.trunc">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">trunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_mathematical.html#trunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the truncated value of the input, element-wise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.trunc()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.unwrap">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">unwrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x1</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_trigonometric.html#unwrap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.unwrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Unwrap by changing deltas between values to 2*pi complement.</p>
<p>Unwrap radian phase p by changing absolute jumps greater than discont to their 2*pi complement along the given axis.</p>
<p>x1 : Input array.</p>
<p>out : Output array.</p>
<p>rad2deg, deg2rad</p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.vdot">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">vdot</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_linearalgebra.html#vdot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.vdot" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dot product of two vectors.</p>
<p><code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.vdot()</span></code></p>
</dd></dl>

<dl class="py function">
<dt id="dpnp.zeros">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">zeros</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">shape</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#zeros"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new array of given shape and type, filled with zeros.</p>
<dl class="simple">
<dt>shape<span class="classifier">int or tuple of ints</span></dt><dd><p>Shape of the new array, e.g., <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">3)</span></code> or <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
</dd>
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>The desired data-type for the array, e.g., <cite>numpy.int8</cite>.  Default is
<cite>numpy.float64</cite>.</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’}, optional, default: ‘C’</span></dt><dd><p>Whether to store multi-dimensional data in row-major
(C-style) or column-major (Fortran-style) order in
memory.</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the given shape, dtype, and order.</p>
</dd>
</dl>
<p>zeros_like : Return an array of zeros with shape and type of input.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
full : Return a new array of given shape filled with value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">array([ 0.,  0.,  0.,  0.,  0.])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 0, 0, 0, 0])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">array([[ 0.],</span>
<span class="go">       [ 0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="go">array([[ 0.,  0.],</span>
<span class="go">       [ 0.,  0.]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i4&#39;</span><span class="p">)])</span> <span class="c1"># custom dtype</span>
<span class="go">array([(0, 0), (0, 0)],</span>
<span class="go">      dtype=[(&#39;x&#39;, &#39;&lt;i4&#39;), (&#39;y&#39;, &#39;&lt;i4&#39;)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="dpnp.zeros_like">
<code class="sig-prename descclassname">dpnp.</code><code class="sig-name descname">zeros_like</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">prototype</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'C'</span></em>, <em class="sig-param"><span class="n">subok</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">shape</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/dpnp/dpnp_iface_arraycreation.html#zeros_like"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#dpnp.zeros_like" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of zeros with the same shape and type as a given array.
Parameters
———-
a : array_like</p>
<blockquote>
<div><p>The shape and data-type of <cite>a</cite> define these same attributes of
the returned array.</p>
</div></blockquote>
<dl class="simple">
<dt>dtype<span class="classifier">data-type, optional</span></dt><dd><p>Overrides the data type of the result.
.. versionadded:: 1.6.0</p>
</dd>
<dt>order<span class="classifier">{‘C’, ‘F’, ‘A’, or ‘K’}, optional</span></dt><dd><p>Overrides the memory layout of the result. ‘C’ means C-order,
‘F’ means F-order, ‘A’ means ‘F’ if <cite>a</cite> is Fortran contiguous,
‘C’ otherwise. ‘K’ means match the layout of <cite>a</cite> as closely
as possible.
.. versionadded:: 1.6.0</p>
</dd>
<dt>subok<span class="classifier">bool, optional.</span></dt><dd><p>If True, then the newly created array will use the sub-class
type of ‘a’, otherwise it will be a base-class array. Defaults
to True.</p>
</dd>
<dt>shape<span class="classifier">int or sequence of ints, optional.</span></dt><dd><p>Overrides the shape of the result. If order=’K’ and the number of
dimensions is unchanged, will try to keep order, otherwise,
order=’C’ is implied.
.. versionadded:: 1.17.0</p>
</dd>
</dl>
<dl class="simple">
<dt>out<span class="classifier">ndarray</span></dt><dd><p>Array of zeros with the same shape and type as <cite>a</cite>.</p>
</dd>
</dl>
<p>empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.
Examples
——–
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; x = x.reshape((2, 3))
&gt;&gt;&gt; x
array([[0, 1, 2],</p>
<blockquote>
<div><p>[3, 4, 5]])</p>
</div></blockquote>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">array([[0, 0, 0],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([0., 1., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="go">array([0.,  0.,  0.])</span>
</pre></div>
</div>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dpnp_backend_api.html" class="btn btn-neutral float-right" title="DPNP C++ backend API Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="DPNP" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Intel

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>